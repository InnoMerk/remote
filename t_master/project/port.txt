; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o.\port.o --asm_dir=.\ --list_dir=.\ --depend=.\port.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\project -I..\hooks -I..\lcd -I..\led -I..\load_cpu -I..\main -I..\printf -I..\rtos -I..\control_task -I..\mode_task -I..\lcdTask -I..\..\CMSIS\CM3\CoreSupport -I..\..\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\STM32F10x_StdPeriph_Driver\inc -I..\..\STM32F10x_StdPeriph_Driver\src -I..\radio -I..\..\rtos -I"C:\Program Files\keil\ARM\RV31\INC" -I"C:\Program Files\keil\ARM\PACK\ARM\CMSIS\3.20.4\CMSIS\Include" -I"C:\Program Files\keil\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include" -DSTM32F10X_MD_VL -DUSE_STDPERIPH_DRIVER --omf_browse=.\port.crf ..\..\rtos\port.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  prvTaskExitError PROC
;;;230    
;;;231    static void prvTaskExitError( void )
000000  485b              LDR      r0,|L1.368|
;;;232    {
;;;233    	/* A function that implements a task must not exit or attempt to return to
;;;234    	its caller as there is nothing to return to.  If a task wants to exit it
;;;235    	should instead call vTaskDelete( NULL ).
;;;236    
;;;237    	Artificially force an assert() to be triggered if configASSERT() is
;;;238    	defined, then stop here so application writers can catch the error. */
;;;239    	configASSERT( uxCriticalNesting == ~0UL );
000002  6840              LDR      r0,[r0,#4]  ; uxCriticalNesting
000004  1c40              ADDS     r0,r0,#1
000006  d002              BEQ      |L1.14|
000008  f7fffffe          BL       ulPortSetInterruptMask
                  |L1.12|
00000c  e7fe              B        |L1.12|
                  |L1.14|
;;;240    	portDISABLE_INTERRUPTS();
00000e  f7fffffe          BL       ulPortSetInterruptMask
                  |L1.18|
;;;241    	for( ;; );
000012  e7fe              B        |L1.18|
;;;242    }
;;;243    /*-----------------------------------------------------------*/
                          ENDP

                  pxPortInitialiseStack PROC
;;;211     */
;;;212    StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
000014  b510              PUSH     {r4,lr}
;;;213    {
;;;214    	/* Simulate the stack frame as it would be created by a context switch
;;;215    	interrupt. */
;;;216    	pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
000016  1f03              SUBS     r3,r0,#4
;;;217    	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
000018  f04f7480          MOV      r4,#0x1000000
;;;218    	pxTopOfStack--;
;;;219    	*pxTopOfStack = ( StackType_t ) pxCode;	/* PC */
;;;220    	pxTopOfStack--;
;;;221    	*pxTopOfStack = ( StackType_t ) prvTaskExitError;	/* LR */
;;;222    
;;;223    	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
;;;224    	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
;;;225    	pxTopOfStack -= 8;	/* R11, R10, R9, R8, R7, R6, R5 and R4. */
;;;226    
;;;227    	return pxTopOfStack;
00001c  601c              STR      r4,[r3,#0]
00001e  1f1b              SUBS     r3,r3,#4
000020  6019              STR      r1,[r3,#0]
000022  1f19              SUBS     r1,r3,#4
000024  4b53              LDR      r3,|L1.372|
000026  600b              STR      r3,[r1,#0]
000028  3914              SUBS     r1,r1,#0x14
00002a  3840              SUBS     r0,r0,#0x40           ;224
00002c  600a              STR      r2,[r1,#0]            ;224
;;;228    }
00002e  bd10              POP      {r4,pc}
;;;229    /*-----------------------------------------------------------*/
                          ENDP

                  vPortSetupTimerInterrupt PROC
;;;615    
;;;616    	void vPortSetupTimerInterrupt( void )
000030  f04f20e0          MOV      r0,#0xe000e000
;;;617    	{
;;;618    		/* Calculate the constants required to configure the tick interrupt. */
;;;619    		#if configUSE_TICKLESS_IDLE == 1
;;;620    		{
;;;621    			ulTimerCountsForOneTick = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ );
;;;622    			xMaximumPossibleSuppressedTicks = portMAX_24_BIT_NUMBER / ulTimerCountsForOneTick;
;;;623    			ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
;;;624    		}
;;;625    		#endif /* configUSE_TICKLESS_IDLE */
;;;626    
;;;627    		/* Configure SysTick to interrupt at the requested rate. */
;;;628    		portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
000034  f64551bf          MOV      r1,#0x5dbf
000038  6141              STR      r1,[r0,#0x14]
;;;629    		portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
00003a  2107              MOVS     r1,#7
00003c  6101              STR      r1,[r0,#0x10]
;;;630    	}
00003e  4770              BX       lr
;;;631    
                          ENDP

                  xPortStartScheduler PROC
;;;286     */
;;;287    BaseType_t xPortStartScheduler( void )
000040  b51c              PUSH     {r2-r4,lr}
;;;288    {
;;;289    	#if( configASSERT_DEFINED == 1 )
;;;290    	{
;;;291    		volatile uint32_t ulOriginalPriority;
;;;292    		volatile uint8_t * const pucFirstUserPriorityRegister = ( uint8_t * ) ( portNVIC_IP_REGISTERS_OFFSET_16 + portFIRST_USER_INTERRUPT_NUMBER );
000042  494d              LDR      r1,|L1.376|
;;;293    		volatile uint8_t ucMaxPriorityValue;
;;;294    
;;;295    		/* Determine the maximum priority from which ISR safe FreeRTOS API
;;;296    		functions can be called.  ISR safe functions are those that end in
;;;297    		"FromISR".  FreeRTOS maintains separate thread and ISR API functions to
;;;298    		ensure interrupt entry is as fast and simple as possible.
;;;299    
;;;300    		Save the interrupt priority value that is about to be clobbered. */
;;;301    		ulOriginalPriority = *pucFirstUserPriorityRegister;
000044  7808              LDRB     r0,[r1,#0]
;;;302    
;;;303    		/* Determine the number of priority bits available.  First write to all
;;;304    		possible bits. */
;;;305    		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
000046  9001              STR      r0,[sp,#4]
000048  20ff              MOVS     r0,#0xff
00004a  7008              STRB     r0,[r1,#0]
;;;306    
;;;307    		/* Read the value back to see how many bits stuck. */
;;;308    		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
00004c  7808              LDRB     r0,[r1,#0]
00004e  f88d0000          STRB     r0,[sp,#0]
;;;309    
;;;310    		/* Use the same mask on the maximum system call priority. */
;;;311    		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
000052  f89d0000          LDRB     r0,[sp,#0]
000056  4a46              LDR      r2,|L1.368|
000058  f0000050          AND      r0,r0,#0x50
00005c  7010              STRB     r0,[r2,#0]
;;;312    
;;;313    		/* Calculate the maximum acceptable priority group value for the number
;;;314    		of bits read back. */
;;;315    		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
00005e  2007              MOVS     r0,#7
000060  6090              STR      r0,[r2,#8]            ;288  ; ulMaxPRIGROUPValue
000062  e005              B        |L1.112|
                  |L1.100|
;;;316    		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
;;;317    		{
;;;318    			ulMaxPRIGROUPValue--;
;;;319    			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
000064  f89d3000          LDRB     r3,[sp,#0]
000068  005b              LSLS     r3,r3,#1
00006a  f88d3000          STRB     r3,[sp,#0]
00006e  1e40              SUBS     r0,r0,#1
                  |L1.112|
000070  f89d3000          LDRB     r3,[sp,#0]            ;316
000074  061b              LSLS     r3,r3,#24             ;316
000076  d4f5              BMI      |L1.100|
;;;320    		}
;;;321    
;;;322    		/* Shift the priority group value back to its position within the AIRCR
;;;323    		register. */
;;;324    		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
000078  0200              LSLS     r0,r0,#8
;;;325    		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
00007a  f40060e0          AND      r0,r0,#0x700
;;;326    
;;;327    		/* Restore the clobbered interrupt priority register to its original
;;;328    		value. */
;;;329    		*pucFirstUserPriorityRegister = ulOriginalPriority;
00007e  6090              STR      r0,[r2,#8]  ; ulMaxPRIGROUPValue
000080  9801              LDR      r0,[sp,#4]
000082  7008              STRB     r0,[r1,#0]
;;;330    	}
;;;331    	#endif /* conifgASSERT_DEFINED */
;;;332    
;;;333    	/* Make PendSV and SysTick the lowest priority interrupts. */
;;;334    	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
000084  483d              LDR      r0,|L1.380|
000086  6801              LDR      r1,[r0,#0]
000088  f4410170          ORR      r1,r1,#0xf00000
00008c  6001              STR      r1,[r0,#0]
;;;335    	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
00008e  6801              LDR      r1,[r0,#0]
000090  f0414170          ORR      r1,r1,#0xf0000000
000094  6001              STR      r1,[r0,#0]
;;;336    
;;;337    	/* Start the timer that generates the tick ISR.  Interrupts are disabled
;;;338    	here already. */
;;;339    	vPortSetupTimerInterrupt();
000096  f7fffffe          BL       vPortSetupTimerInterrupt
;;;340    
;;;341    	/* Initialise the critical nesting count ready for the first task. */
;;;342    	uxCriticalNesting = 0;
00009a  2000              MOVS     r0,#0
;;;343    
;;;344    	/* Start the first task. */
;;;345    	prvStartFirstTask();
00009c  6050              STR      r0,[r2,#4]  ; uxCriticalNesting
00009e  f7fffffe          BL       __asm___6_port_c_39a90d8d__prvStartFirstTask
;;;346    
;;;347    	/* Should not get here! */
;;;348    	return 0;
0000a2  2000              MOVS     r0,#0
;;;349    }
0000a4  bd1c              POP      {r2-r4,pc}
;;;350    /*-----------------------------------------------------------*/
                          ENDP

                  vPortEndScheduler PROC
;;;351    
;;;352    void vPortEndScheduler( void )
0000a6  4832              LDR      r0,|L1.368|
;;;353    {
0000a8  b510              PUSH     {r4,lr}
;;;354    	/* Not implemented in ports where there is nothing to return to.
;;;355    	Artificially force an assert. */
;;;356    	configASSERT( uxCriticalNesting == 1000UL );
0000aa  6840              LDR      r0,[r0,#4]  ; uxCriticalNesting
0000ac  f5b07f7a          CMP      r0,#0x3e8
0000b0  d002              BEQ      |L1.184|
0000b2  f7fffffe          BL       ulPortSetInterruptMask
                  |L1.182|
0000b6  e7fe              B        |L1.182|
                  |L1.184|
;;;357    }
0000b8  bd10              POP      {r4,pc}
;;;358    /*-----------------------------------------------------------*/
                          ENDP

                  vPortYield PROC
;;;359    
;;;360    void vPortYield( void )
0000ba  4930              LDR      r1,|L1.380|
;;;361    {
;;;362    	/* Set a PendSV to request a context switch. */
;;;363    	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
0000bc  f04f5080          MOV      r0,#0x10000000
0000c0  391c              SUBS     r1,r1,#0x1c
0000c2  6008              STR      r0,[r1,#0]
;;;364    
;;;365    	/* Barriers are normally not required but do ensure the code is completely
;;;366    	within the specified behaviour for the architecture. */
;;;367    	__dsb( portSY_FULL_READ_WRITE );
0000c4  f3bf8f4f          DSB      
;;;368    	__isb( portSY_FULL_READ_WRITE );
0000c8  f3bf8f6f          ISB      
;;;369    }
0000cc  4770              BX       lr
;;;370    /*-----------------------------------------------------------*/
                          ENDP

                  vPortEnterCritical PROC
;;;371    
;;;372    void vPortEnterCritical( void )
0000ce  b510              PUSH     {r4,lr}
;;;373    {
;;;374    	portDISABLE_INTERRUPTS();
0000d0  f7fffffe          BL       ulPortSetInterruptMask
;;;375    	uxCriticalNesting++;
0000d4  4826              LDR      r0,|L1.368|
0000d6  6841              LDR      r1,[r0,#4]  ; uxCriticalNesting
0000d8  1c49              ADDS     r1,r1,#1
;;;376    	__dsb( portSY_FULL_READ_WRITE );
0000da  f3bf8f4f          DSB      
;;;377    	__isb( portSY_FULL_READ_WRITE );
0000de  f3bf8f6f          ISB      
;;;378    
;;;379    	/* This is not the interrupt safe version of the enter critical function so
;;;380    	assert() if it is being called from an interrupt context.  Only API
;;;381    	functions that end in "FromISR" can be used in an interrupt.  Only assert if
;;;382    	the critical nesting count is 1 to protect against recursive calls if the
;;;383    	assert function also uses a critical section. */
;;;384    	if( uxCriticalNesting == 1 )
0000e2  6041              STR      r1,[r0,#4]  ; uxCriticalNesting
0000e4  2901              CMP      r1,#1
0000e6  d107              BNE      |L1.248|
;;;385    	{
;;;386    		configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
0000e8  4824              LDR      r0,|L1.380|
0000ea  381c              SUBS     r0,r0,#0x1c
0000ec  6800              LDR      r0,[r0,#0]
0000ee  06c0              LSLS     r0,r0,#27
0000f0  d002              BEQ      |L1.248|
0000f2  f7fffffe          BL       ulPortSetInterruptMask
                  |L1.246|
0000f6  e7fe              B        |L1.246|
                  |L1.248|
;;;387    	}
;;;388    }
0000f8  bd10              POP      {r4,pc}
;;;389    /*-----------------------------------------------------------*/
                          ENDP

                  vPortExitCritical PROC
;;;390    
;;;391    void vPortExitCritical( void )
0000fa  491d              LDR      r1,|L1.368|
;;;392    {
0000fc  b510              PUSH     {r4,lr}
0000fe  6848              LDR      r0,[r1,#4]  ; uxCriticalNesting
000100  b130              CBZ      r0,|L1.272|
000102  1e40              SUBS     r0,r0,#1
;;;393    	configASSERT( uxCriticalNesting );
;;;394    	uxCriticalNesting--;
;;;395    	if( uxCriticalNesting == 0 )
000104  6048              STR      r0,[r1,#4]  ; uxCriticalNesting
000106  d106              BNE      |L1.278|
;;;396    	{
;;;397    		portENABLE_INTERRUPTS();
000108  e8bd4010          POP      {r4,lr}
00010c  f7ffbffe          B.W      vPortClearInterruptMask
                  |L1.272|
000110  f7fffffe          BL       ulPortSetInterruptMask
                  |L1.276|
000114  e7fe              B        |L1.276|
                  |L1.278|
;;;398    	}
;;;399    }
000116  bd10              POP      {r4,pc}
;;;400    /*-----------------------------------------------------------*/
                          ENDP

                  SysTick_Handler PROC
;;;436    
;;;437    void xPortSysTickHandler( void )
000118  b510              PUSH     {r4,lr}
;;;438    {
;;;439    	/* The SysTick runs at the lowest interrupt priority, so when this interrupt
;;;440    	executes all interrupts must be unmasked.  There is therefore no need to
;;;441    	save and then restore the interrupt mask value as its value is already
;;;442    	known. */
;;;443    	( void ) portSET_INTERRUPT_MASK_FROM_ISR();
00011a  f7fffffe          BL       ulPortSetInterruptMask
;;;444    	{
;;;445    		/* Increment the RTOS tick. */
;;;446    		if( xTaskIncrementTick() != pdFALSE )
00011e  f7fffffe          BL       xTaskIncrementTick
000122  b120              CBZ      r0,|L1.302|
;;;447    		{
;;;448    			/* A context switch is required.  Context switching is performed in
;;;449    			the PendSV interrupt.  Pend the PendSV interrupt. */
;;;450    			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
000124  4915              LDR      r1,|L1.380|
000126  f04f5080          MOV      r0,#0x10000000
00012a  391c              SUBS     r1,r1,#0x1c
00012c  6008              STR      r0,[r1,#0]
                  |L1.302|
;;;451    		}
;;;452    	}
;;;453    	portCLEAR_INTERRUPT_MASK_FROM_ISR( 0 );
00012e  e8bd4010          POP      {r4,lr}
000132  2000              MOVS     r0,#0
000134  f7ffbffe          B.W      vPortClearInterruptMask
;;;454    }
;;;455    /*-----------------------------------------------------------*/
                          ENDP

                  vPortValidateInterruptPriority PROC
;;;665    
;;;666    	void vPortValidateInterruptPriority( void )
000138  b510              PUSH     {r4,lr}
;;;667    	{
;;;668    	uint32_t ulCurrentInterrupt;
;;;669    	uint8_t ucCurrentPriority;
;;;670    
;;;671    		/* Obtain the number of the currently executing interrupt. */
;;;672    		ulCurrentInterrupt = vPortGetIPSR();
00013a  f7fffffe          BL       vPortGetIPSR
;;;673    
;;;674    		/* Is the interrupt number a user defined interrupt? */
;;;675    		if( ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER )
;;;676    		{
;;;677    			/* Look up the interrupt's priority. */
;;;678    			ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
;;;679    
;;;680    			/* The following assertion will fail if a service routine (ISR) for
;;;681    			an interrupt that has been assigned a priority above
;;;682    			configMAX_SYSCALL_INTERRUPT_PRIORITY calls an ISR safe FreeRTOS API
;;;683    			function.  ISR safe FreeRTOS API functions must *only* be called
;;;684    			from interrupts that have been assigned a priority at or below
;;;685    			configMAX_SYSCALL_INTERRUPT_PRIORITY.
;;;686    
;;;687    			Numerically low interrupt priority numbers represent logically high
;;;688    			interrupt priorities, therefore the priority of the interrupt must
;;;689    			be set to a value equal to or numerically *higher* than
;;;690    			configMAX_SYSCALL_INTERRUPT_PRIORITY.
;;;691    
;;;692    			Interrupts that	use the FreeRTOS API must not be left at their
;;;693    			default priority of	zero as that is the highest possible priority,
;;;694    			which is guaranteed to be above configMAX_SYSCALL_INTERRUPT_PRIORITY,
;;;695    			and	therefore also guaranteed to be invalid.
;;;696    
;;;697    			FreeRTOS maintains separate thread and ISR API functions to ensure
;;;698    			interrupt entry is as fast and simple as possible.
;;;699    
;;;700    			The following links provide detailed information:
;;;701    			http://www.freertos.org/RTOS-Cortex-M3-M4.html
;;;702    			http://www.freertos.org/FAQHelp.html */
;;;703    			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
00013e  490c              LDR      r1,|L1.368|
000140  2810              CMP      r0,#0x10              ;675
000142  d309              BCC      |L1.344|
000144  f10020e0          ADD      r0,r0,#0xe000e000     ;675
000148  f89003f0          LDRB     r0,[r0,#0x3f0]        ;678
00014c  780a              LDRB     r2,[r1,#0]  ; ucMaxSysCallPriority
00014e  4290              CMP      r0,r2
000150  d202              BCS      |L1.344|
000152  f7fffffe          BL       ulPortSetInterruptMask
                  |L1.342|
000156  e7fe              B        |L1.342|
                  |L1.344|
;;;704    		}
;;;705    
;;;706    		/* Priority grouping:  The interrupt controller (NVIC) allows the bits
;;;707    		that define each interrupt's priority to be split between bits that
;;;708    		define the interrupt's pre-emption priority bits and bits that define
;;;709    		the interrupt's sub-priority.  For simplicity all bits must be defined
;;;710    		to be pre-emption priority bits.  The following assertion will fail if
;;;711    		this is not the case (if some bits represent a sub-priority).
;;;712    
;;;713    		If the application only uses CMSIS libraries for interrupt
;;;714    		configuration then the correct setting can be achieved on all Cortex-M
;;;715    		devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
;;;716    		scheduler.  Note however that some vendor specific peripheral libraries
;;;717    		assume a non-zero priority group setting, in which cases using a value
;;;718    		of zero will result in unpredicable behaviour. */
;;;719    		configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
000158  4808              LDR      r0,|L1.380|
00015a  3814              SUBS     r0,r0,#0x14
00015c  6800              LDR      r0,[r0,#0]
00015e  6889              LDR      r1,[r1,#8]  ; ulMaxPRIGROUPValue
000160  f40060e0          AND      r0,r0,#0x700
000164  4288              CMP      r0,r1
000166  d902              BLS      |L1.366|
000168  f7fffffe          BL       ulPortSetInterruptMask
                  |L1.364|
00016c  e7fe              B        |L1.364|
                  |L1.366|
;;;720    	}
00016e  bd10              POP      {r4,pc}
;;;721    
                          ENDP

                  |L1.368|
                          DCD      ||.data||
                  |L1.372|
                          DCD      prvTaskExitError
                  |L1.376|
                          DCD      0xe000e400
                  |L1.380|
                          DCD      0xe000ed20

                          AREA ||.data||, DATA, ALIGN=2

                  ucMaxSysCallPriority
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  uxCriticalNesting
                          DCD      0xaaaaaaaa
                  ulMaxPRIGROUPValue
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\rtos\\port.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |SVC_Handler|
#line 245
|SVC_Handler| PROC
#line 246

 PRESERVE8

 ldr r3, =pxCurrentTCB  
 ldr r1, [r3]  
 ldr r0, [r1]  
 ldmia r0!, {r4-r11}  
 msr psp, r0  
 isb
 mov r0, #0
 msr basepri, r0
 orr r14, #0xd
 bx r14
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___6_port_c_39a90d8d__prvStartFirstTask|
#line 262
|__asm___6_port_c_39a90d8d__prvStartFirstTask| PROC
#line 263

 PRESERVE8

 
 ldr r0, =0xE000ED08
 ldr r0, [r0]
 ldr r0, [r0]
 
 msr msp, r0
 
 cpsie i
 cpsie f
 dsb
 isb
 
 svc 0
 nop
 nop
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |PendSV_Handler|
#line 402
|PendSV_Handler| PROC
#line 403

 extern uxCriticalNesting
 extern pxCurrentTCB
 extern vTaskSwitchContext

 PRESERVE8

 mrs r0, psp
 isb

 ldr r3, =pxCurrentTCB  
 ldr r2, [r3]

 stmdb r0!, {r4-r11}  
 str r0, [r2]  

 stmdb sp!, {r3, r14}
 mov r0, #( 5 << (8 - 4) )
 msr basepri, r0
 bl vTaskSwitchContext
 mov r0, #0
 msr basepri, r0
 ldmia sp!, {r3, r14}

 ldr r1, [r3]
 ldr r0, [r1]  
 ldmia r0!, {r4-r11}  
 msr psp, r0
 isb
 bx r14
 nop
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |ulPortSetInterruptMask|
#line 635
|ulPortSetInterruptMask| PROC
#line 636

 PRESERVE8

 mrs r0, basepri
 mov r1, #( 5 << (8 - 4) )
 msr basepri, r1
 bx r14
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |vPortClearInterruptMask|
#line 646
|vPortClearInterruptMask| PROC
#line 647

 PRESERVE8

 msr basepri, r0
 bx r14
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |vPortGetIPSR|
#line 655
|vPortGetIPSR| PROC
#line 656

 PRESERVE8

 mrs r0, ipsr
 bx r14
	ENDP

;*** End   embedded assembler ***
