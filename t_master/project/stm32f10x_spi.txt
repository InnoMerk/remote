; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o.\stm32f10x_spi.o --asm_dir=.\ --list_dir=.\ --depend=.\stm32f10x_spi.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\project -I..\hooks -I..\lcd -I..\led -I..\load_cpu -I..\main -I..\printf -I..\rtos -I..\control_task -I..\mode_task -I..\lcdTask -I..\..\CMSIS\CM3\CoreSupport -I..\..\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\STM32F10x_StdPeriph_Driver\inc -I..\..\STM32F10x_StdPeriph_Driver\src -I..\radio -I..\..\rtos -I"C:\Program Files\keil\ARM\RV31\INC" -I"C:\Program Files\keil\ARM\PACK\ARM\CMSIS\3.20.4\CMSIS\Include" -I"C:\Program Files\keil\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include" -DSTM32F10X_MD_VL -DUSE_STDPERIPH_DRIVER --omf_browse=.\stm32f10x_spi.crf ..\..\STM32F10x_StdPeriph_Driver\src\stm32f10x_spi.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  SPI_I2S_DeInit PROC
;;;118      */
;;;119    void SPI_I2S_DeInit(SPI_TypeDef* SPIx)
000000  b570              PUSH     {r4-r6,lr}
;;;120    {
000002  4604              MOV      r4,r0
;;;121      /* Check the parameters */
;;;122      assert_param(IS_SPI_ALL_PERIPH(SPIx));
000004  48fe              LDR      r0,|L1.1024|
000006  4284              CMP      r4,r0
000008  d00e              BEQ      |L1.40|
00000a  4dfe              LDR      r5,|L1.1028|
00000c  4efe              LDR      r6,|L1.1032|
00000e  42ac              CMP      r4,r5
000010  d005              BEQ      |L1.30|
000012  42b4              CMP      r4,r6
000014  d015              BEQ      |L1.66|
000016  217a              MOVS     r1,#0x7a
000018  a0fc              ADR      r0,|L1.1036|
00001a  f7fffffe          BL       assert_failed
                  |L1.30|
;;;123    
;;;124      if (SPIx == SPI1)
;;;125      {
;;;126        /* Enable SPI1 reset state */
;;;127        RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, ENABLE);
;;;128        /* Release SPI1 from reset state */
;;;129        RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, DISABLE);
;;;130      }
;;;131      else if (SPIx == SPI2)
00001e  42ac              CMP      r4,r5
000020  d10d              BNE      |L1.62|
;;;132      {
;;;133        /* Enable SPI2 reset state */
;;;134        RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, ENABLE);
000022  2101              MOVS     r1,#1
000024  038c              LSLS     r4,r1,#14
;;;135        /* Release SPI2 from reset state */
;;;136        RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, DISABLE);
000026  e00e              B        |L1.70|
                  |L1.40|
000028  2101              MOVS     r1,#1                 ;127
00002a  030c              LSLS     r4,r1,#12             ;127
00002c  4620              MOV      r0,r4                 ;127
00002e  f7fffffe          BL       RCC_APB2PeriphResetCmd
000032  4620              MOV      r0,r4                 ;129
000034  e8bd4070          POP      {r4-r6,lr}            ;129
000038  2100              MOVS     r1,#0                 ;129
00003a  f7ffbffe          B.W      RCC_APB2PeriphResetCmd
                  |L1.62|
;;;137      }
;;;138      else
;;;139      {
;;;140        if (SPIx == SPI3)
00003e  42b4              CMP      r4,r6
000040  d10a              BNE      |L1.88|
                  |L1.66|
;;;141        {
;;;142          /* Enable SPI3 reset state */
;;;143          RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, ENABLE);
000042  2101              MOVS     r1,#1
000044  03cc              LSLS     r4,r1,#15
                  |L1.70|
000046  4620              MOV      r0,r4
000048  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;144          /* Release SPI3 from reset state */
;;;145          RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, DISABLE);
00004c  4620              MOV      r0,r4
00004e  e8bd4070          POP      {r4-r6,lr}
000052  2100              MOVS     r1,#0
000054  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L1.88|
;;;146        }
;;;147      }
;;;148    }
000058  bd70              POP      {r4-r6,pc}
;;;149    
                          ENDP

                  SPI_Init PROC
;;;157      */
;;;158    void SPI_Init(SPI_TypeDef* SPIx, SPI_InitTypeDef* SPI_InitStruct)
00005a  b570              PUSH     {r4-r6,lr}
;;;159    {
00005c  4605              MOV      r5,r0
;;;160      uint16_t tmpreg = 0;
;;;161      
;;;162      /* check the parameters */
;;;163      assert_param(IS_SPI_ALL_PERIPH(SPIx));   
00005e  48e8              LDR      r0,|L1.1024|
000060  460c              MOV      r4,r1                 ;159
000062  4285              CMP      r5,r0
000064  d009              BEQ      |L1.122|
000066  48e7              LDR      r0,|L1.1028|
000068  4285              CMP      r5,r0
00006a  d006              BEQ      |L1.122|
00006c  48e6              LDR      r0,|L1.1032|
00006e  4285              CMP      r5,r0
000070  d003              BEQ      |L1.122|
000072  21a3              MOVS     r1,#0xa3
000074  a0e5              ADR      r0,|L1.1036|
000076  f7fffffe          BL       assert_failed
                  |L1.122|
;;;164      
;;;165      /* Check the SPI parameters */
;;;166      assert_param(IS_SPI_DIRECTION_MODE(SPI_InitStruct->SPI_Direction));
00007a  8820              LDRH     r0,[r4,#0]
00007c  b160              CBZ      r0,|L1.152|
00007e  f5b06f80          CMP      r0,#0x400
000082  d009              BEQ      |L1.152|
000084  f5b04f00          CMP      r0,#0x8000
000088  d006              BEQ      |L1.152|
00008a  f5b04f40          CMP      r0,#0xc000
00008e  d003              BEQ      |L1.152|
000090  21a6              MOVS     r1,#0xa6
000092  a0de              ADR      r0,|L1.1036|
000094  f7fffffe          BL       assert_failed
                  |L1.152|
;;;167      assert_param(IS_SPI_MODE(SPI_InitStruct->SPI_Mode));
000098  8860              LDRH     r0,[r4,#2]
00009a  f5b07f82          CMP      r0,#0x104
00009e  d004              BEQ      |L1.170|
0000a0  b118              CBZ      r0,|L1.170|
0000a2  21a7              MOVS     r1,#0xa7
0000a4  a0d9              ADR      r0,|L1.1036|
0000a6  f7fffffe          BL       assert_failed
                  |L1.170|
;;;168      assert_param(IS_SPI_DATASIZE(SPI_InitStruct->SPI_DataSize));
0000aa  88a0              LDRH     r0,[r4,#4]
0000ac  f5b06f00          CMP      r0,#0x800
0000b0  d004              BEQ      |L1.188|
0000b2  b118              CBZ      r0,|L1.188|
0000b4  21a8              MOVS     r1,#0xa8
0000b6  a0d5              ADR      r0,|L1.1036|
0000b8  f7fffffe          BL       assert_failed
                  |L1.188|
;;;169      assert_param(IS_SPI_CPOL(SPI_InitStruct->SPI_CPOL));
0000bc  88e0              LDRH     r0,[r4,#6]
0000be  b128              CBZ      r0,|L1.204|
0000c0  2802              CMP      r0,#2
0000c2  d003              BEQ      |L1.204|
0000c4  21a9              MOVS     r1,#0xa9
0000c6  a0d1              ADR      r0,|L1.1036|
0000c8  f7fffffe          BL       assert_failed
                  |L1.204|
;;;170      assert_param(IS_SPI_CPHA(SPI_InitStruct->SPI_CPHA));
0000cc  8920              LDRH     r0,[r4,#8]
0000ce  b128              CBZ      r0,|L1.220|
0000d0  2801              CMP      r0,#1
0000d2  d003              BEQ      |L1.220|
0000d4  21aa              MOVS     r1,#0xaa
0000d6  a0cd              ADR      r0,|L1.1036|
0000d8  f7fffffe          BL       assert_failed
                  |L1.220|
;;;171      assert_param(IS_SPI_NSS(SPI_InitStruct->SPI_NSS));
0000dc  8960              LDRH     r0,[r4,#0xa]
0000de  f5b07f00          CMP      r0,#0x200
0000e2  d004              BEQ      |L1.238|
0000e4  b118              CBZ      r0,|L1.238|
0000e6  21ab              MOVS     r1,#0xab
0000e8  a0c8              ADR      r0,|L1.1036|
0000ea  f7fffffe          BL       assert_failed
                  |L1.238|
;;;172      assert_param(IS_SPI_BAUDRATE_PRESCALER(SPI_InitStruct->SPI_BaudRatePrescaler));
0000ee  89a0              LDRH     r0,[r4,#0xc]
0000f0  b188              CBZ      r0,|L1.278|
0000f2  2808              CMP      r0,#8
0000f4  d00f              BEQ      |L1.278|
0000f6  2810              CMP      r0,#0x10
0000f8  d00d              BEQ      |L1.278|
0000fa  2818              CMP      r0,#0x18
0000fc  d00b              BEQ      |L1.278|
0000fe  2820              CMP      r0,#0x20
000100  d009              BEQ      |L1.278|
000102  2828              CMP      r0,#0x28
000104  d007              BEQ      |L1.278|
000106  2830              CMP      r0,#0x30
000108  d005              BEQ      |L1.278|
00010a  2838              CMP      r0,#0x38
00010c  d003              BEQ      |L1.278|
00010e  21ac              MOVS     r1,#0xac
000110  a0be              ADR      r0,|L1.1036|
000112  f7fffffe          BL       assert_failed
                  |L1.278|
;;;173      assert_param(IS_SPI_FIRST_BIT(SPI_InitStruct->SPI_FirstBit));
000116  89e0              LDRH     r0,[r4,#0xe]
000118  b128              CBZ      r0,|L1.294|
00011a  2880              CMP      r0,#0x80
00011c  d003              BEQ      |L1.294|
00011e  21ad              MOVS     r1,#0xad
000120  a0ba              ADR      r0,|L1.1036|
000122  f7fffffe          BL       assert_failed
                  |L1.294|
;;;174      assert_param(IS_SPI_CRC_POLYNOMIAL(SPI_InitStruct->SPI_CRCPolynomial));
000126  8a20              LDRH     r0,[r4,#0x10]
000128  b918              CBNZ     r0,|L1.306|
00012a  21ae              MOVS     r1,#0xae
00012c  a0b7              ADR      r0,|L1.1036|
00012e  f7fffffe          BL       assert_failed
                  |L1.306|
;;;175    
;;;176    /*---------------------------- SPIx CR1 Configuration ------------------------*/
;;;177      /* Get the SPIx CR1 value */
;;;178      tmpreg = SPIx->CR1;
000132  8828              LDRH     r0,[r5,#0]
;;;179      /* Clear BIDIMode, BIDIOE, RxONLY, SSM, SSI, LSBFirst, BR, MSTR, CPOL and CPHA bits */
;;;180      tmpreg &= CR1_CLEAR_Mask;
;;;181      /* Configure SPIx: direction, NSS management, first transmitted bit, BaudRate prescaler
;;;182         master/salve mode, CPOL and CPHA */
;;;183      /* Set BIDImode, BIDIOE and RxONLY bits according to SPI_Direction value */
;;;184      /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
;;;185      /* Set LSBFirst bit according to SPI_FirstBit value */
;;;186      /* Set BR bits according to SPI_BaudRatePrescaler value */
;;;187      /* Set CPOL bit according to SPI_CPOL value */
;;;188      /* Set CPHA bit according to SPI_CPHA value */
;;;189      tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode |
000134  8862              LDRH     r2,[r4,#2]
000136  f4005141          AND      r1,r0,#0x3040         ;180
00013a  8820              LDRH     r0,[r4,#0]
00013c  88e3              LDRH     r3,[r4,#6]
00013e  4310              ORRS     r0,r0,r2
000140  88a2              LDRH     r2,[r4,#4]
000142  431a              ORRS     r2,r2,r3
000144  4310              ORRS     r0,r0,r2
000146  8922              LDRH     r2,[r4,#8]
000148  4310              ORRS     r0,r0,r2
00014a  8962              LDRH     r2,[r4,#0xa]
00014c  4310              ORRS     r0,r0,r2
00014e  89a2              LDRH     r2,[r4,#0xc]
000150  4310              ORRS     r0,r0,r2
000152  89e2              LDRH     r2,[r4,#0xe]
000154  4310              ORRS     r0,r0,r2
000156  4308              ORRS     r0,r0,r1
;;;190                      SPI_InitStruct->SPI_DataSize | SPI_InitStruct->SPI_CPOL |  
;;;191                      SPI_InitStruct->SPI_CPHA | SPI_InitStruct->SPI_NSS |  
;;;192                      SPI_InitStruct->SPI_BaudRatePrescaler | SPI_InitStruct->SPI_FirstBit);
;;;193      /* Write to SPIx CR1 */
;;;194      SPIx->CR1 = tmpreg;
000158  8028              STRH     r0,[r5,#0]
;;;195      
;;;196      /* Activate the SPI mode (Reset I2SMOD bit in I2SCFGR register) */
;;;197      SPIx->I2SCFGR &= SPI_Mode_Select;		
00015a  8ba8              LDRH     r0,[r5,#0x1c]
00015c  f4206000          BIC      r0,r0,#0x800
000160  83a8              STRH     r0,[r5,#0x1c]
;;;198    
;;;199    /*---------------------------- SPIx CRCPOLY Configuration --------------------*/
;;;200      /* Write to SPIx CRCPOLY */
;;;201      SPIx->CRCPR = SPI_InitStruct->SPI_CRCPolynomial;
000162  8a20              LDRH     r0,[r4,#0x10]
000164  8228              STRH     r0,[r5,#0x10]
;;;202    }
000166  bd70              POP      {r4-r6,pc}
;;;203    
                          ENDP

                  I2S_Init PROC
;;;218      */
;;;219    void I2S_Init(SPI_TypeDef* SPIx, I2S_InitTypeDef* I2S_InitStruct)
000168  e92d47f0          PUSH     {r4-r10,lr}
;;;220    {
00016c  4605              MOV      r5,r0
;;;221      uint16_t tmpreg = 0, i2sdiv = 2, i2sodd = 0, packetlength = 1;
;;;222      uint32_t tmp = 0;
;;;223      RCC_ClocksTypeDef RCC_Clocks;
;;;224      uint32_t sourceclock = 0;
;;;225      
;;;226      /* Check the I2S parameters */
;;;227      assert_param(IS_SPI_23_PERIPH(SPIx));
00016e  48a5              LDR      r0,|L1.1028|
000170  2602              MOVS     r6,#2                 ;221
000172  2700              MOVS     r7,#0                 ;221
000174  b086              SUB      sp,sp,#0x18           ;220
000176  460c              MOV      r4,r1                 ;220
000178  f04f0801          MOV      r8,#1                 ;221
00017c  4285              CMP      r5,r0
00017e  d006              BEQ      |L1.398|
000180  48a1              LDR      r0,|L1.1032|
000182  4285              CMP      r5,r0
000184  d003              BEQ      |L1.398|
000186  21e3              MOVS     r1,#0xe3
000188  a0a0              ADR      r0,|L1.1036|
00018a  f7fffffe          BL       assert_failed
                  |L1.398|
;;;228      assert_param(IS_I2S_MODE(I2S_InitStruct->I2S_Mode));
00018e  8820              LDRH     r0,[r4,#0]
000190  f44f7900          MOV      r9,#0x200
000194  b158              CBZ      r0,|L1.430|
000196  f5b07f80          CMP      r0,#0x100
00019a  d008              BEQ      |L1.430|
00019c  4548              CMP      r0,r9
00019e  d006              BEQ      |L1.430|
0001a0  f5b07f40          CMP      r0,#0x300
0001a4  d003              BEQ      |L1.430|
0001a6  21e4              MOVS     r1,#0xe4
0001a8  a098              ADR      r0,|L1.1036|
0001aa  f7fffffe          BL       assert_failed
                  |L1.430|
;;;229      assert_param(IS_I2S_STANDARD(I2S_InitStruct->I2S_Standard));
0001ae  8860              LDRH     r0,[r4,#2]
0001b0  b158              CBZ      r0,|L1.458|
0001b2  2810              CMP      r0,#0x10
0001b4  d009              BEQ      |L1.458|
0001b6  2820              CMP      r0,#0x20
0001b8  d007              BEQ      |L1.458|
0001ba  2830              CMP      r0,#0x30
0001bc  d005              BEQ      |L1.458|
0001be  28b0              CMP      r0,#0xb0
0001c0  d003              BEQ      |L1.458|
0001c2  21e5              MOVS     r1,#0xe5
0001c4  a091              ADR      r0,|L1.1036|
0001c6  f7fffffe          BL       assert_failed
                  |L1.458|
;;;230      assert_param(IS_I2S_DATA_FORMAT(I2S_InitStruct->I2S_DataFormat));
0001ca  88a0              LDRH     r0,[r4,#4]
0001cc  b148              CBZ      r0,|L1.482|
0001ce  2801              CMP      r0,#1
0001d0  d007              BEQ      |L1.482|
0001d2  2803              CMP      r0,#3
0001d4  d005              BEQ      |L1.482|
0001d6  2805              CMP      r0,#5
0001d8  d003              BEQ      |L1.482|
0001da  21e6              MOVS     r1,#0xe6
0001dc  a08b              ADR      r0,|L1.1036|
0001de  f7fffffe          BL       assert_failed
                  |L1.482|
;;;231      assert_param(IS_I2S_MCLK_OUTPUT(I2S_InitStruct->I2S_MCLKOutput));
0001e2  88e0              LDRH     r0,[r4,#6]
0001e4  46ca              MOV      r10,r9
0001e6  4550              CMP      r0,r10
0001e8  d004              BEQ      |L1.500|
0001ea  b118              CBZ      r0,|L1.500|
0001ec  21e7              MOVS     r1,#0xe7
0001ee  a087              ADR      r0,|L1.1036|
0001f0  f7fffffe          BL       assert_failed
                  |L1.500|
;;;232      assert_param(IS_I2S_AUDIO_FREQ(I2S_InitStruct->I2S_AudioFreq));
0001f4  68a0              LDR      r0,[r4,#8]
0001f6  4a93              LDR      r2,|L1.1092|
0001f8  f5a051fa          SUB      r1,r0,#0x1f40
0001fc  4291              CMP      r1,r2
0001fe  d905              BLS      |L1.524|
000200  2802              CMP      r0,#2
000202  d003              BEQ      |L1.524|
000204  21e8              MOVS     r1,#0xe8
000206  a081              ADR      r0,|L1.1036|
000208  f7fffffe          BL       assert_failed
                  |L1.524|
;;;233      assert_param(IS_I2S_CPOL(I2S_InitStruct->I2S_CPOL));  
00020c  89a0              LDRH     r0,[r4,#0xc]
00020e  b128              CBZ      r0,|L1.540|
000210  2808              CMP      r0,#8
000212  d003              BEQ      |L1.540|
000214  21e9              MOVS     r1,#0xe9
000216  a07d              ADR      r0,|L1.1036|
000218  f7fffffe          BL       assert_failed
                  |L1.540|
;;;234    
;;;235    /*----------------------- SPIx I2SCFGR & I2SPR Configuration -----------------*/
;;;236      /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
;;;237      SPIx->I2SCFGR &= I2SCFGR_CLEAR_Mask; 
00021c  8ba8              LDRH     r0,[r5,#0x1c]
00021e  f24f0140          MOV      r1,#0xf040
000222  4008              ANDS     r0,r0,r1
000224  83a8              STRH     r0,[r5,#0x1c]
;;;238      SPIx->I2SPR = 0x0002;
000226  2002              MOVS     r0,#2
000228  8428              STRH     r0,[r5,#0x20]
;;;239      
;;;240      /* Get the I2SCFGR register value */
;;;241      tmpreg = SPIx->I2SCFGR;
00022a  f8b5901c          LDRH     r9,[r5,#0x1c]
;;;242      
;;;243      /* If the default value has to be written, reinitialize i2sdiv and i2sodd*/
;;;244      if(I2S_InitStruct->I2S_AudioFreq == I2S_AudioFreq_Default)
00022e  68a0              LDR      r0,[r4,#8]
000230  2802              CMP      r0,#2
000232  d029              BEQ      |L1.648|
;;;245      {
;;;246        i2sodd = (uint16_t)0;
;;;247        i2sdiv = (uint16_t)2;   
;;;248      }
;;;249      /* If the requested audio frequency is not the default, compute the prescaler */
;;;250      else
;;;251      {
;;;252        /* Check the frame length (For the Prescaler computing) */
;;;253        if(I2S_InitStruct->I2S_DataFormat == I2S_DataFormat_16b)
000234  88a0              LDRH     r0,[r4,#4]
000236  b108              CBZ      r0,|L1.572|
;;;254        {
;;;255          /* Packet length is 16 bits */
;;;256          packetlength = 1;
;;;257        }
;;;258        else
;;;259        {
;;;260          /* Packet length is 32 bits */
;;;261          packetlength = 2;
000238  f04f0802          MOV      r8,#2
                  |L1.572|
;;;262        }
;;;263    
;;;264        /* Get the I2S clock source mask depending on the peripheral number */
;;;265        if(((uint32_t)SPIx) == SPI2_BASE)
;;;266        {
;;;267          /* The mask is relative to I2S2 */
;;;268          tmp = I2S2_CLOCK_SRC;
;;;269        }
;;;270        else 
;;;271        {
;;;272          /* The mask is relative to I2S3 */      
;;;273          tmp = I2S3_CLOCK_SRC;
;;;274        }
;;;275    
;;;276        /* Check the I2S clock source configuration depending on the Device:
;;;277           Only Connectivity line devices have the PLL3 VCO clock */
;;;278    #ifdef STM32F10X_CL
;;;279        if((RCC->CFGR2 & tmp) != 0)
;;;280        {
;;;281          /* Get the configuration bits of RCC PLL3 multiplier */
;;;282          tmp = (uint32_t)((RCC->CFGR2 & I2S_MUL_MASK) >> 12);
;;;283    
;;;284          /* Get the value of the PLL3 multiplier */      
;;;285          if((tmp > 5) && (tmp < 15))
;;;286          {
;;;287            /* Multiplier is between 8 and 14 (value 15 is forbidden) */
;;;288            tmp += 2;
;;;289          }
;;;290          else
;;;291          {
;;;292            if (tmp == 15)
;;;293            {
;;;294              /* Multiplier is 20 */
;;;295              tmp = 20;
;;;296            }
;;;297          }      
;;;298          /* Get the PREDIV2 value */
;;;299          sourceclock = (uint32_t)(((RCC->CFGR2 & I2S_DIV_MASK) >> 4) + 1);
;;;300          
;;;301          /* Calculate the Source Clock frequency based on PLL3 and PREDIV2 values */
;;;302          sourceclock = (uint32_t) ((HSE_Value / sourceclock) * tmp * 2); 
;;;303        }
;;;304        else
;;;305        {
;;;306          /* I2S Clock source is System clock: Get System Clock frequency */
;;;307          RCC_GetClocksFreq(&RCC_Clocks);      
;;;308          
;;;309          /* Get the source clock value: based on System Clock value */
;;;310          sourceclock = RCC_Clocks.SYSCLK_Frequency;
;;;311        }        
;;;312    #else /* STM32F10X_HD */
;;;313        /* I2S Clock source is System clock: Get System Clock frequency */
;;;314        RCC_GetClocksFreq(&RCC_Clocks);      
00023c  4668              MOV      r0,sp
00023e  f7fffffe          BL       RCC_GetClocksFreq
;;;315          
;;;316        /* Get the source clock value: based on System Clock value */
;;;317        sourceclock = RCC_Clocks.SYSCLK_Frequency;    
;;;318    #endif /* STM32F10X_CL */    
;;;319    
;;;320        /* Compute the Real divider depending on the MCLK output state with a floating point */
;;;321        if(I2S_InitStruct->I2S_MCLKOutput == I2S_MCLKOutput_Enable)
000242  88e1              LDRH     r1,[r4,#6]
000244  9800              LDR      r0,[sp,#0]
000246  4551              CMP      r1,r10
000248  d101              BNE      |L1.590|
;;;322        {
;;;323          /* MCLK output is enabled */
;;;324          tmp = (uint16_t)(((((sourceclock / 256) * 10) / I2S_InitStruct->I2S_AudioFreq)) + 5);
00024a  0a00              LSRS     r0,r0,#8
00024c  e003              B        |L1.598|
                  |L1.590|
;;;325        }
;;;326        else
;;;327        {
;;;328          /* MCLK output is disabled */
;;;329          tmp = (uint16_t)(((((sourceclock / (32 * packetlength)) *10 ) / I2S_InitStruct->I2S_AudioFreq)) + 5);
00024e  ea4f1148          LSL      r1,r8,#5
000252  fbb0f0f1          UDIV     r0,r0,r1
                  |L1.598|
000256  eb000080          ADD      r0,r0,r0,LSL #2
00025a  68a1              LDR      r1,[r4,#8]
00025c  0040              LSLS     r0,r0,#1
00025e  fbb0f0f1          UDIV     r0,r0,r1
000262  1d40              ADDS     r0,r0,#5
000264  b280              UXTH     r0,r0
;;;330        }
;;;331        
;;;332        /* Remove the floating point */
;;;333        tmp = tmp / 10;  
000266  210a              MOVS     r1,#0xa
000268  fbb0f1f1          UDIV     r1,r0,r1
;;;334          
;;;335        /* Check the parity of the divider */
;;;336        i2sodd = (uint16_t)(tmp & (uint16_t)0x0001);
00026c  f0010001          AND      r0,r1,#1
;;;337       
;;;338        /* Compute the i2sdiv prescaler */
;;;339        i2sdiv = (uint16_t)((tmp - i2sodd) / 2);
000270  1a09              SUBS     r1,r1,r0
000272  f3c1064f          UBFX     r6,r1,#1,#16
;;;340       
;;;341        /* Get the Mask for the Odd bit (SPI_I2SPR[8]) register */
;;;342        i2sodd = (uint16_t) (i2sodd << 8);
000276  f64f71ff          MOV      r1,#0xffff
00027a  ea012700          AND      r7,r1,r0,LSL #8
;;;343      }
;;;344      
;;;345      /* Test if the divider is 1 or 0 or greater than 0xFF */
;;;346      if ((i2sdiv < 2) || (i2sdiv > 0xFF))
00027e  1eb0              SUBS     r0,r6,#2
000280  28fe              CMP      r0,#0xfe
000282  d301              BCC      |L1.648|
;;;347      {
;;;348        /* Set the default values */
;;;349        i2sdiv = 2;
000284  2602              MOVS     r6,#2
;;;350        i2sodd = 0;
000286  2700              MOVS     r7,#0
                  |L1.648|
;;;351      }
;;;352    
;;;353      /* Write to SPIx I2SPR register the computed value */
;;;354      SPIx->I2SPR = (uint16_t)(i2sdiv | (uint16_t)(i2sodd | (uint16_t)I2S_InitStruct->I2S_MCLKOutput));  
000288  88e0              LDRH     r0,[r4,#6]
00028a  433e              ORRS     r6,r6,r7
00028c  4330              ORRS     r0,r0,r6
00028e  8428              STRH     r0,[r5,#0x20]
;;;355     
;;;356      /* Configure the I2S with the SPI_InitStruct values */
;;;357      tmpreg |= (uint16_t)(I2S_Mode_Select | (uint16_t)(I2S_InitStruct->I2S_Mode | \
000290  8820              LDRH     r0,[r4,#0]
000292  8861              LDRH     r1,[r4,#2]
000294  89a2              LDRH     r2,[r4,#0xc]
000296  4308              ORRS     r0,r0,r1
000298  88a1              LDRH     r1,[r4,#4]
00029a  4311              ORRS     r1,r1,r2
00029c  4308              ORRS     r0,r0,r1
00029e  ea400009          ORR      r0,r0,r9
0002a2  f4406000          ORR      r0,r0,#0x800
;;;358                      (uint16_t)(I2S_InitStruct->I2S_Standard | (uint16_t)(I2S_InitStruct->I2S_DataFormat | \
;;;359                      (uint16_t)I2S_InitStruct->I2S_CPOL))));
;;;360     
;;;361      /* Write to SPIx I2SCFGR */  
;;;362      SPIx->I2SCFGR = tmpreg;   
0002a6  83a8              STRH     r0,[r5,#0x1c]
;;;363    }
0002a8  b006              ADD      sp,sp,#0x18
0002aa  e8bd87f0          POP      {r4-r10,pc}
;;;364    
                          ENDP

                  SPI_StructInit PROC
;;;369      */
;;;370    void SPI_StructInit(SPI_InitTypeDef* SPI_InitStruct)
0002ae  2100              MOVS     r1,#0
;;;371    {
;;;372    /*--------------- Reset SPI init structure parameters values -----------------*/
;;;373      /* Initialize the SPI_Direction member */
;;;374      SPI_InitStruct->SPI_Direction = SPI_Direction_2Lines_FullDuplex;
0002b0  8001              STRH     r1,[r0,#0]
;;;375      /* initialize the SPI_Mode member */
;;;376      SPI_InitStruct->SPI_Mode = SPI_Mode_Slave;
0002b2  8041              STRH     r1,[r0,#2]
;;;377      /* initialize the SPI_DataSize member */
;;;378      SPI_InitStruct->SPI_DataSize = SPI_DataSize_8b;
0002b4  8081              STRH     r1,[r0,#4]
;;;379      /* Initialize the SPI_CPOL member */
;;;380      SPI_InitStruct->SPI_CPOL = SPI_CPOL_Low;
0002b6  80c1              STRH     r1,[r0,#6]
;;;381      /* Initialize the SPI_CPHA member */
;;;382      SPI_InitStruct->SPI_CPHA = SPI_CPHA_1Edge;
0002b8  8101              STRH     r1,[r0,#8]
;;;383      /* Initialize the SPI_NSS member */
;;;384      SPI_InitStruct->SPI_NSS = SPI_NSS_Hard;
0002ba  8141              STRH     r1,[r0,#0xa]
;;;385      /* Initialize the SPI_BaudRatePrescaler member */
;;;386      SPI_InitStruct->SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_2;
0002bc  8181              STRH     r1,[r0,#0xc]
;;;387      /* Initialize the SPI_FirstBit member */
;;;388      SPI_InitStruct->SPI_FirstBit = SPI_FirstBit_MSB;
0002be  81c1              STRH     r1,[r0,#0xe]
;;;389      /* Initialize the SPI_CRCPolynomial member */
;;;390      SPI_InitStruct->SPI_CRCPolynomial = 7;
0002c0  2107              MOVS     r1,#7
0002c2  8201              STRH     r1,[r0,#0x10]
;;;391    }
0002c4  4770              BX       lr
;;;392    
                          ENDP

                  I2S_StructInit PROC
;;;397      */
;;;398    void I2S_StructInit(I2S_InitTypeDef* I2S_InitStruct)
0002c6  2100              MOVS     r1,#0
;;;399    {
;;;400    /*--------------- Reset I2S init structure parameters values -----------------*/
;;;401      /* Initialize the I2S_Mode member */
;;;402      I2S_InitStruct->I2S_Mode = I2S_Mode_SlaveTx;
0002c8  8001              STRH     r1,[r0,#0]
;;;403      
;;;404      /* Initialize the I2S_Standard member */
;;;405      I2S_InitStruct->I2S_Standard = I2S_Standard_Phillips;
0002ca  8041              STRH     r1,[r0,#2]
;;;406      
;;;407      /* Initialize the I2S_DataFormat member */
;;;408      I2S_InitStruct->I2S_DataFormat = I2S_DataFormat_16b;
0002cc  8081              STRH     r1,[r0,#4]
;;;409      
;;;410      /* Initialize the I2S_MCLKOutput member */
;;;411      I2S_InitStruct->I2S_MCLKOutput = I2S_MCLKOutput_Disable;
0002ce  80c1              STRH     r1,[r0,#6]
;;;412      
;;;413      /* Initialize the I2S_AudioFreq member */
;;;414      I2S_InitStruct->I2S_AudioFreq = I2S_AudioFreq_Default;
0002d0  2202              MOVS     r2,#2
;;;415      
;;;416      /* Initialize the I2S_CPOL member */
;;;417      I2S_InitStruct->I2S_CPOL = I2S_CPOL_Low;
0002d2  6082              STR      r2,[r0,#8]
0002d4  8181              STRH     r1,[r0,#0xc]
;;;418    }
0002d6  4770              BX       lr
;;;419    
                          ENDP

                  SPI_Cmd PROC
;;;426      */
;;;427    void SPI_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
0002d8  b570              PUSH     {r4-r6,lr}
;;;428    {
0002da  4604              MOV      r4,r0
;;;429      /* Check the parameters */
;;;430      assert_param(IS_SPI_ALL_PERIPH(SPIx));
0002dc  4848              LDR      r0,|L1.1024|
0002de  460d              MOV      r5,r1                 ;428
0002e0  4284              CMP      r4,r0
0002e2  d00a              BEQ      |L1.762|
0002e4  4847              LDR      r0,|L1.1028|
0002e6  4284              CMP      r4,r0
0002e8  d007              BEQ      |L1.762|
0002ea  4847              LDR      r0,|L1.1032|
0002ec  4284              CMP      r4,r0
0002ee  d004              BEQ      |L1.762|
0002f0  f44f71d7          MOV      r1,#0x1ae
0002f4  a045              ADR      r0,|L1.1036|
0002f6  f7fffffe          BL       assert_failed
                  |L1.762|
;;;431      assert_param(IS_FUNCTIONAL_STATE(NewState));
0002fa  b155              CBZ      r5,|L1.786|
0002fc  2d01              CMP      r5,#1
0002fe  d004              BEQ      |L1.778|
000300  f24011af          MOV      r1,#0x1af
000304  a041              ADR      r0,|L1.1036|
000306  f7fffffe          BL       assert_failed
                  |L1.778|
;;;432      if (NewState != DISABLE)
;;;433      {
;;;434        /* Enable the selected SPI peripheral */
;;;435        SPIx->CR1 |= CR1_SPE_Set;
00030a  8820              LDRH     r0,[r4,#0]
00030c  f0400040          ORR      r0,r0,#0x40
000310  e002              B        |L1.792|
                  |L1.786|
;;;436      }
;;;437      else
;;;438      {
;;;439        /* Disable the selected SPI peripheral */
;;;440        SPIx->CR1 &= CR1_SPE_Reset;
000312  8820              LDRH     r0,[r4,#0]
000314  f0200040          BIC      r0,r0,#0x40
                  |L1.792|
000318  8020              STRH     r0,[r4,#0]            ;435
;;;441      }
;;;442    }
00031a  bd70              POP      {r4-r6,pc}
;;;443    
                          ENDP

                  I2S_Cmd PROC
;;;450      */
;;;451    void I2S_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
00031c  b570              PUSH     {r4-r6,lr}
;;;452    {
00031e  4604              MOV      r4,r0
;;;453      /* Check the parameters */
;;;454      assert_param(IS_SPI_23_PERIPH(SPIx));
000320  4838              LDR      r0,|L1.1028|
000322  460d              MOV      r5,r1                 ;452
000324  4284              CMP      r4,r0
000326  d007              BEQ      |L1.824|
000328  4837              LDR      r0,|L1.1032|
00032a  4284              CMP      r4,r0
00032c  d004              BEQ      |L1.824|
00032e  f44f71e3          MOV      r1,#0x1c6
000332  a036              ADR      r0,|L1.1036|
000334  f7fffffe          BL       assert_failed
                  |L1.824|
;;;455      assert_param(IS_FUNCTIONAL_STATE(NewState));
000338  b155              CBZ      r5,|L1.848|
00033a  2d01              CMP      r5,#1
00033c  d004              BEQ      |L1.840|
00033e  f24011c7          MOV      r1,#0x1c7
000342  a032              ADR      r0,|L1.1036|
000344  f7fffffe          BL       assert_failed
                  |L1.840|
;;;456      if (NewState != DISABLE)
;;;457      {
;;;458        /* Enable the selected SPI peripheral (in I2S mode) */
;;;459        SPIx->I2SCFGR |= I2SCFGR_I2SE_Set;
000348  8ba0              LDRH     r0,[r4,#0x1c]
00034a  f4406080          ORR      r0,r0,#0x400
00034e  e002              B        |L1.854|
                  |L1.848|
;;;460      }
;;;461      else
;;;462      {
;;;463        /* Disable the selected SPI peripheral (in I2S mode) */
;;;464        SPIx->I2SCFGR &= I2SCFGR_I2SE_Reset;
000350  8ba0              LDRH     r0,[r4,#0x1c]
000352  f4206080          BIC      r0,r0,#0x400
                  |L1.854|
000356  83a0              STRH     r0,[r4,#0x1c]         ;459
;;;465      }
;;;466    }
000358  bd70              POP      {r4-r6,pc}
;;;467    
                          ENDP

                  SPI_I2S_ITConfig PROC
;;;481      */
;;;482    void SPI_I2S_ITConfig(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT, FunctionalState NewState)
00035a  b570              PUSH     {r4-r6,lr}
;;;483    {
00035c  4604              MOV      r4,r0
;;;484      uint16_t itpos = 0, itmask = 0 ;
;;;485      /* Check the parameters */
;;;486      assert_param(IS_SPI_ALL_PERIPH(SPIx));
00035e  4828              LDR      r0,|L1.1024|
000360  4616              MOV      r6,r2                 ;483
000362  460d              MOV      r5,r1                 ;483
000364  4284              CMP      r4,r0
000366  d00a              BEQ      |L1.894|
000368  4826              LDR      r0,|L1.1028|
00036a  4284              CMP      r4,r0
00036c  d007              BEQ      |L1.894|
00036e  4826              LDR      r0,|L1.1032|
000370  4284              CMP      r4,r0
000372  d004              BEQ      |L1.894|
000374  f44f71f3          MOV      r1,#0x1e6
000378  a024              ADR      r0,|L1.1036|
00037a  f7fffffe          BL       assert_failed
                  |L1.894|
;;;487      assert_param(IS_FUNCTIONAL_STATE(NewState));
00037e  b136              CBZ      r6,|L1.910|
000380  2e01              CMP      r6,#1
000382  d004              BEQ      |L1.910|
000384  f24011e7          MOV      r1,#0x1e7
000388  a020              ADR      r0,|L1.1036|
00038a  f7fffffe          BL       assert_failed
                  |L1.910|
;;;488      assert_param(IS_SPI_I2S_CONFIG_IT(SPI_I2S_IT));
00038e  2d71              CMP      r5,#0x71
000390  d008              BEQ      |L1.932|
000392  2d60              CMP      r5,#0x60
000394  d006              BEQ      |L1.932|
000396  2d50              CMP      r5,#0x50
000398  d004              BEQ      |L1.932|
00039a  f44f71f4          MOV      r1,#0x1e8
00039e  a01b              ADR      r0,|L1.1036|
0003a0  f7fffffe          BL       assert_failed
                  |L1.932|
;;;489    
;;;490      /* Get the SPI/I2S IT index */
;;;491      itpos = SPI_I2S_IT >> 4;
0003a4  0928              LSRS     r0,r5,#4
;;;492    
;;;493      /* Set the IT mask */
;;;494      itmask = (uint16_t)1 << (uint16_t)itpos;
0003a6  2101              MOVS     r1,#1
0003a8  4081              LSLS     r1,r1,r0
0003aa  b288              UXTH     r0,r1
;;;495    
;;;496      if (NewState != DISABLE)
;;;497      {
;;;498        /* Enable the selected SPI/I2S interrupt */
;;;499        SPIx->CR2 |= itmask;
;;;500      }
;;;501      else
;;;502      {
;;;503        /* Disable the selected SPI/I2S interrupt */
;;;504        SPIx->CR2 &= (uint16_t)~itmask;
0003ac  88a1              LDRH     r1,[r4,#4]
0003ae  b10e              CBZ      r6,|L1.948|
0003b0  4301              ORRS     r1,r1,r0              ;499
0003b2  e000              B        |L1.950|
                  |L1.948|
0003b4  4381              BICS     r1,r1,r0
                  |L1.950|
0003b6  80a1              STRH     r1,[r4,#4]            ;499
;;;505      }
;;;506    }
0003b8  bd70              POP      {r4-r6,pc}
;;;507    
                          ENDP

                  SPI_I2S_DMACmd PROC
;;;520      */
;;;521    void SPI_I2S_DMACmd(SPI_TypeDef* SPIx, uint16_t SPI_I2S_DMAReq, FunctionalState NewState)
0003ba  b570              PUSH     {r4-r6,lr}
;;;522    {
0003bc  4604              MOV      r4,r0
;;;523      /* Check the parameters */
;;;524      assert_param(IS_SPI_ALL_PERIPH(SPIx));
0003be  4810              LDR      r0,|L1.1024|
0003c0  4616              MOV      r6,r2                 ;522
0003c2  460d              MOV      r5,r1                 ;522
0003c4  4284              CMP      r4,r0
0003c6  d00a              BEQ      |L1.990|
0003c8  480e              LDR      r0,|L1.1028|
0003ca  4284              CMP      r4,r0
0003cc  d007              BEQ      |L1.990|
0003ce  480e              LDR      r0,|L1.1032|
0003d0  4284              CMP      r4,r0
0003d2  d004              BEQ      |L1.990|
0003d4  f44f7103          MOV      r1,#0x20c
0003d8  a00c              ADR      r0,|L1.1036|
0003da  f7fffffe          BL       assert_failed
                  |L1.990|
;;;525      assert_param(IS_FUNCTIONAL_STATE(NewState));
0003de  b136              CBZ      r6,|L1.1006|
0003e0  2e01              CMP      r6,#1
0003e2  d004              BEQ      |L1.1006|
0003e4  f240210d          MOV      r1,#0x20d
0003e8  a008              ADR      r0,|L1.1036|
0003ea  f7fffffe          BL       assert_failed
                  |L1.1006|
;;;526      assert_param(IS_SPI_I2S_DMAREQ(SPI_I2S_DMAReq));
0003ee  08a8              LSRS     r0,r5,#2
0003f0  d100              BNE      |L1.1012|
0003f2  b925              CBNZ     r5,|L1.1022|
                  |L1.1012|
0003f4  f240210e          MOV      r1,#0x20e
0003f8  a004              ADR      r0,|L1.1036|
0003fa  f7fffffe          BL       assert_failed
                  |L1.1022|
;;;527      if (NewState != DISABLE)
;;;528      {
;;;529        /* Enable the selected SPI/I2S DMA requests */
;;;530        SPIx->CR2 |= SPI_I2S_DMAReq;
;;;531      }
;;;532      else
;;;533      {
;;;534        /* Disable the selected SPI/I2S DMA requests */
;;;535        SPIx->CR2 &= (uint16_t)~SPI_I2S_DMAReq;
0003fe  e023              B        |L1.1096|
                  |L1.1024|
                          DCD      0x40013000
                  |L1.1028|
                          DCD      0x40003800
                  |L1.1032|
                          DCD      0x40003c00
                  |L1.1036|
00040c  2e2e5c2e          DCB      "..\\..\\STM32F10x_StdPeriph_Driver\\src\\stm32f10x_spi."
000410  2e5c5354
000414  4d333246
000418  3130785f
00041c  53746450
000420  65726970
000424  685f4472
000428  69766572
00042c  5c737263
000430  5c73746d
000434  33326631
000438  30785f73
00043c  70692e  
00043f  6300              DCB      "c",0
000441  00                DCB      0
000442  00                DCB      0
000443  00                DCB      0
                  |L1.1092|
                          DCD      0x0002cec0
                  |L1.1096|
000448  88a0              LDRH     r0,[r4,#4]
00044a  b10e              CBZ      r6,|L1.1104|
00044c  4328              ORRS     r0,r0,r5              ;530
00044e  e000              B        |L1.1106|
                  |L1.1104|
000450  43a8              BICS     r0,r0,r5
                  |L1.1106|
000452  80a0              STRH     r0,[r4,#4]            ;530
;;;536      }
;;;537    }
000454  bd70              POP      {r4-r6,pc}
;;;538    
                          ENDP

                  SPI_I2S_SendData PROC
;;;546      */
;;;547    void SPI_I2S_SendData(SPI_TypeDef* SPIx, uint16_t Data)
000456  b570              PUSH     {r4-r6,lr}
;;;548    {
000458  4604              MOV      r4,r0
;;;549      /* Check the parameters */
;;;550      assert_param(IS_SPI_ALL_PERIPH(SPIx));
00045a  48e6              LDR      r0,|L1.2036|
00045c  460d              MOV      r5,r1                 ;548
00045e  4284              CMP      r4,r0
000460  d00b              BEQ      |L1.1146|
000462  48e5              LDR      r0,|L1.2040|
000464  4284              CMP      r4,r0
000466  d008              BEQ      |L1.1146|
000468  48e4              LDR      r0,|L1.2044|
00046a  4284              CMP      r4,r0
00046c  d005              BEQ      |L1.1146|
00046e  f2402126          MOV      r1,#0x226
000472  f2af0068          ADR      r0,|L1.1036|
000476  f7fffffe          BL       assert_failed
                  |L1.1146|
;;;551      
;;;552      /* Write in the DR register the data to be sent */
;;;553      SPIx->DR = Data;
00047a  81a5              STRH     r5,[r4,#0xc]
;;;554    }
00047c  bd70              POP      {r4-r6,pc}
;;;555    
                          ENDP

                  SPI_I2S_ReceiveData PROC
;;;562      */
;;;563    uint16_t SPI_I2S_ReceiveData(SPI_TypeDef* SPIx)
00047e  b510              PUSH     {r4,lr}
;;;564    {
000480  4604              MOV      r4,r0
;;;565      /* Check the parameters */
;;;566      assert_param(IS_SPI_ALL_PERIPH(SPIx));
000482  48dc              LDR      r0,|L1.2036|
000484  4284              CMP      r4,r0
000486  d00b              BEQ      |L1.1184|
000488  48db              LDR      r0,|L1.2040|
00048a  4284              CMP      r4,r0
00048c  d008              BEQ      |L1.1184|
00048e  48db              LDR      r0,|L1.2044|
000490  4284              CMP      r4,r0
000492  d005              BEQ      |L1.1184|
000494  f2402136          MOV      r1,#0x236
000498  f2af0090          ADR      r0,|L1.1036|
00049c  f7fffffe          BL       assert_failed
                  |L1.1184|
;;;567      
;;;568      /* Return the data in the DR register */
;;;569      return SPIx->DR;
0004a0  89a0              LDRH     r0,[r4,#0xc]
;;;570    }
0004a2  bd10              POP      {r4,pc}
;;;571    
                          ENDP

                  SPI_NSSInternalSoftwareConfig PROC
;;;580      */
;;;581    void SPI_NSSInternalSoftwareConfig(SPI_TypeDef* SPIx, uint16_t SPI_NSSInternalSoft)
0004a4  b570              PUSH     {r4-r6,lr}
;;;582    {
0004a6  4604              MOV      r4,r0
;;;583      /* Check the parameters */
;;;584      assert_param(IS_SPI_ALL_PERIPH(SPIx));
0004a8  48d2              LDR      r0,|L1.2036|
0004aa  460d              MOV      r5,r1                 ;582
0004ac  4284              CMP      r4,r0
0004ae  d00b              BEQ      |L1.1224|
0004b0  48d1              LDR      r0,|L1.2040|
0004b2  4284              CMP      r4,r0
0004b4  d008              BEQ      |L1.1224|
0004b6  48d1              LDR      r0,|L1.2044|
0004b8  4284              CMP      r4,r0
0004ba  d005              BEQ      |L1.1224|
0004bc  f44f7112          MOV      r1,#0x248
0004c0  f2af00b8          ADR      r0,|L1.1036|
0004c4  f7fffffe          BL       assert_failed
                  |L1.1224|
;;;585      assert_param(IS_SPI_NSS_INTERNAL(SPI_NSSInternalSoft));
0004c8  f64f60ff          MOV      r0,#0xfeff
0004cc  f5b57f80          CMP      r5,#0x100
0004d0  d007              BEQ      |L1.1250|
0004d2  4285              CMP      r5,r0
0004d4  d009              BEQ      |L1.1258|
0004d6  f2402149          MOV      r1,#0x249
0004da  f2af00d0          ADR      r0,|L1.1036|
0004de  f7fffffe          BL       assert_failed
                  |L1.1250|
;;;586      if (SPI_NSSInternalSoft != SPI_NSSInternalSoft_Reset)
;;;587      {
;;;588        /* Set NSS pin internally by software */
;;;589        SPIx->CR1 |= SPI_NSSInternalSoft_Set;
0004e2  8820              LDRH     r0,[r4,#0]
0004e4  f4407080          ORR      r0,r0,#0x100
0004e8  e002              B        |L1.1264|
                  |L1.1258|
;;;590      }
;;;591      else
;;;592      {
;;;593        /* Reset NSS pin internally by software */
;;;594        SPIx->CR1 &= SPI_NSSInternalSoft_Reset;
0004ea  8820              LDRH     r0,[r4,#0]
0004ec  f4207080          BIC      r0,r0,#0x100
                  |L1.1264|
0004f0  8020              STRH     r0,[r4,#0]            ;589
;;;595      }
;;;596    }
0004f2  bd70              POP      {r4-r6,pc}
;;;597    
                          ENDP

                  SPI_SSOutputCmd PROC
;;;604      */
;;;605    void SPI_SSOutputCmd(SPI_TypeDef* SPIx, FunctionalState NewState)
0004f4  b570              PUSH     {r4-r6,lr}
;;;606    {
0004f6  4604              MOV      r4,r0
;;;607      /* Check the parameters */
;;;608      assert_param(IS_SPI_ALL_PERIPH(SPIx));
0004f8  48be              LDR      r0,|L1.2036|
0004fa  460d              MOV      r5,r1                 ;606
0004fc  4284              CMP      r4,r0
0004fe  d00b              BEQ      |L1.1304|
000500  48bd              LDR      r0,|L1.2040|
000502  4284              CMP      r4,r0
000504  d008              BEQ      |L1.1304|
000506  48bd              LDR      r0,|L1.2044|
000508  4284              CMP      r4,r0
00050a  d005              BEQ      |L1.1304|
00050c  f44f7118          MOV      r1,#0x260
000510  f2af1008          ADR      r0,|L1.1036|
000514  f7fffffe          BL       assert_failed
                  |L1.1304|
;;;609      assert_param(IS_FUNCTIONAL_STATE(NewState));
000518  b15d              CBZ      r5,|L1.1330|
00051a  2d01              CMP      r5,#1
00051c  d005              BEQ      |L1.1322|
00051e  f2402161          MOV      r1,#0x261
000522  f2af1018          ADR      r0,|L1.1036|
000526  f7fffffe          BL       assert_failed
                  |L1.1322|
;;;610      if (NewState != DISABLE)
;;;611      {
;;;612        /* Enable the selected SPI SS output */
;;;613        SPIx->CR2 |= CR2_SSOE_Set;
00052a  88a0              LDRH     r0,[r4,#4]
00052c  f0400004          ORR      r0,r0,#4
000530  e002              B        |L1.1336|
                  |L1.1330|
;;;614      }
;;;615      else
;;;616      {
;;;617        /* Disable the selected SPI SS output */
;;;618        SPIx->CR2 &= CR2_SSOE_Reset;
000532  88a0              LDRH     r0,[r4,#4]
000534  f0200004          BIC      r0,r0,#4
                  |L1.1336|
000538  80a0              STRH     r0,[r4,#4]            ;613
;;;619      }
;;;620    }
00053a  bd70              POP      {r4-r6,pc}
;;;621    
                          ENDP

                  SPI_DataSizeConfig PROC
;;;630      */
;;;631    void SPI_DataSizeConfig(SPI_TypeDef* SPIx, uint16_t SPI_DataSize)
00053c  b570              PUSH     {r4-r6,lr}
;;;632    {
00053e  4604              MOV      r4,r0
;;;633      /* Check the parameters */
;;;634      assert_param(IS_SPI_ALL_PERIPH(SPIx));
000540  48ac              LDR      r0,|L1.2036|
000542  460d              MOV      r5,r1                 ;632
000544  4284              CMP      r4,r0
000546  d00b              BEQ      |L1.1376|
000548  48ab              LDR      r0,|L1.2040|
00054a  4284              CMP      r4,r0
00054c  d008              BEQ      |L1.1376|
00054e  48ab              LDR      r0,|L1.2044|
000550  4284              CMP      r4,r0
000552  d005              BEQ      |L1.1376|
000554  f240217a          MOV      r1,#0x27a
000558  f2af1050          ADR      r0,|L1.1036|
00055c  f7fffffe          BL       assert_failed
                  |L1.1376|
;;;635      assert_param(IS_SPI_DATASIZE(SPI_DataSize));
000560  f5b56f00          CMP      r5,#0x800
000564  d006              BEQ      |L1.1396|
000566  b12d              CBZ      r5,|L1.1396|
000568  f240217b          MOV      r1,#0x27b
00056c  f2af1064          ADR      r0,|L1.1036|
000570  f7fffffe          BL       assert_failed
                  |L1.1396|
;;;636      /* Clear DFF bit */
;;;637      SPIx->CR1 &= (uint16_t)~SPI_DataSize_16b;
000574  8820              LDRH     r0,[r4,#0]
000576  f4206000          BIC      r0,r0,#0x800
00057a  8020              STRH     r0,[r4,#0]
;;;638      /* Set new DFF bit value */
;;;639      SPIx->CR1 |= SPI_DataSize;
00057c  8820              LDRH     r0,[r4,#0]
00057e  4328              ORRS     r0,r0,r5
000580  8020              STRH     r0,[r4,#0]
;;;640    }
000582  bd70              POP      {r4-r6,pc}
;;;641    
                          ENDP

                  SPI_TransmitCRC PROC
;;;646      */
;;;647    void SPI_TransmitCRC(SPI_TypeDef* SPIx)
000584  b510              PUSH     {r4,lr}
;;;648    {
000586  4604              MOV      r4,r0
;;;649      /* Check the parameters */
;;;650      assert_param(IS_SPI_ALL_PERIPH(SPIx));
000588  489a              LDR      r0,|L1.2036|
00058a  4284              CMP      r4,r0
00058c  d00b              BEQ      |L1.1446|
00058e  489a              LDR      r0,|L1.2040|
000590  4284              CMP      r4,r0
000592  d008              BEQ      |L1.1446|
000594  4899              LDR      r0,|L1.2044|
000596  4284              CMP      r4,r0
000598  d005              BEQ      |L1.1446|
00059a  f240218a          MOV      r1,#0x28a
00059e  f2af1094          ADR      r0,|L1.1036|
0005a2  f7fffffe          BL       assert_failed
                  |L1.1446|
;;;651      
;;;652      /* Enable the selected SPI CRC transmission */
;;;653      SPIx->CR1 |= CR1_CRCNext_Set;
0005a6  8820              LDRH     r0,[r4,#0]
0005a8  f4405080          ORR      r0,r0,#0x1000
0005ac  8020              STRH     r0,[r4,#0]
;;;654    }
0005ae  bd10              POP      {r4,pc}
;;;655    
                          ENDP

                  SPI_CalculateCRC PROC
;;;662      */
;;;663    void SPI_CalculateCRC(SPI_TypeDef* SPIx, FunctionalState NewState)
0005b0  b570              PUSH     {r4-r6,lr}
;;;664    {
0005b2  4604              MOV      r4,r0
;;;665      /* Check the parameters */
;;;666      assert_param(IS_SPI_ALL_PERIPH(SPIx));
0005b4  488f              LDR      r0,|L1.2036|
0005b6  460d              MOV      r5,r1                 ;664
0005b8  4284              CMP      r4,r0
0005ba  d00b              BEQ      |L1.1492|
0005bc  488e              LDR      r0,|L1.2040|
0005be  4284              CMP      r4,r0
0005c0  d008              BEQ      |L1.1492|
0005c2  488e              LDR      r0,|L1.2044|
0005c4  4284              CMP      r4,r0
0005c6  d005              BEQ      |L1.1492|
0005c8  f240219a          MOV      r1,#0x29a
0005cc  f2af10c4          ADR      r0,|L1.1036|
0005d0  f7fffffe          BL       assert_failed
                  |L1.1492|
;;;667      assert_param(IS_FUNCTIONAL_STATE(NewState));
0005d4  b15d              CBZ      r5,|L1.1518|
0005d6  2d01              CMP      r5,#1
0005d8  d005              BEQ      |L1.1510|
0005da  f240219b          MOV      r1,#0x29b
0005de  f2af10d4          ADR      r0,|L1.1036|
0005e2  f7fffffe          BL       assert_failed
                  |L1.1510|
;;;668      if (NewState != DISABLE)
;;;669      {
;;;670        /* Enable the selected SPI CRC calculation */
;;;671        SPIx->CR1 |= CR1_CRCEN_Set;
0005e6  8820              LDRH     r0,[r4,#0]
0005e8  f4405000          ORR      r0,r0,#0x2000
0005ec  e002              B        |L1.1524|
                  |L1.1518|
;;;672      }
;;;673      else
;;;674      {
;;;675        /* Disable the selected SPI CRC calculation */
;;;676        SPIx->CR1 &= CR1_CRCEN_Reset;
0005ee  8820              LDRH     r0,[r4,#0]
0005f0  f4205000          BIC      r0,r0,#0x2000
                  |L1.1524|
0005f4  8020              STRH     r0,[r4,#0]            ;671
;;;677      }
;;;678    }
0005f6  bd70              POP      {r4-r6,pc}
;;;679    
                          ENDP

                  SPI_GetCRC PROC
;;;688      */
;;;689    uint16_t SPI_GetCRC(SPI_TypeDef* SPIx, uint8_t SPI_CRC)
0005f8  b570              PUSH     {r4-r6,lr}
;;;690    {
0005fa  4604              MOV      r4,r0
;;;691      uint16_t crcreg = 0;
;;;692      /* Check the parameters */
;;;693      assert_param(IS_SPI_ALL_PERIPH(SPIx));
0005fc  487d              LDR      r0,|L1.2036|
0005fe  460d              MOV      r5,r1                 ;690
000600  4284              CMP      r4,r0
000602  d00b              BEQ      |L1.1564|
000604  487c              LDR      r0,|L1.2040|
000606  4284              CMP      r4,r0
000608  d008              BEQ      |L1.1564|
00060a  487c              LDR      r0,|L1.2044|
00060c  4284              CMP      r4,r0
00060e  d005              BEQ      |L1.1564|
000610  f24021b5          MOV      r1,#0x2b5
000614  f2af200c          ADR      r0,|L1.1036|
000618  f7fffffe          BL       assert_failed
                  |L1.1564|
;;;694      assert_param(IS_SPI_CRC(SPI_CRC));
00061c  b13d              CBZ      r5,|L1.1582|
00061e  2d01              CMP      r5,#1
000620  d007              BEQ      |L1.1586|
000622  f24021b6          MOV      r1,#0x2b6
000626  f2af201c          ADR      r0,|L1.1036|
00062a  f7fffffe          BL       assert_failed
                  |L1.1582|
;;;695      if (SPI_CRC != SPI_CRC_Rx)
;;;696      {
;;;697        /* Get the Tx CRC register */
;;;698        crcreg = SPIx->TXCRCR;
00062e  8b20              LDRH     r0,[r4,#0x18]
;;;699      }
;;;700      else
;;;701      {
;;;702        /* Get the Rx CRC register */
;;;703        crcreg = SPIx->RXCRCR;
;;;704      }
;;;705      /* Return the selected CRC register */
;;;706      return crcreg;
;;;707    }
000630  bd70              POP      {r4-r6,pc}
                  |L1.1586|
000632  8aa0              LDRH     r0,[r4,#0x14]         ;703
000634  bd70              POP      {r4-r6,pc}
;;;708    
                          ENDP

                  SPI_GetCRCPolynomial PROC
;;;713      */
;;;714    uint16_t SPI_GetCRCPolynomial(SPI_TypeDef* SPIx)
000636  b510              PUSH     {r4,lr}
;;;715    {
000638  4604              MOV      r4,r0
;;;716      /* Check the parameters */
;;;717      assert_param(IS_SPI_ALL_PERIPH(SPIx));
00063a  486e              LDR      r0,|L1.2036|
00063c  4284              CMP      r4,r0
00063e  d00b              BEQ      |L1.1624|
000640  486d              LDR      r0,|L1.2040|
000642  4284              CMP      r4,r0
000644  d008              BEQ      |L1.1624|
000646  486d              LDR      r0,|L1.2044|
000648  4284              CMP      r4,r0
00064a  d005              BEQ      |L1.1624|
00064c  f24021cd          MOV      r1,#0x2cd
000650  f2af2048          ADR      r0,|L1.1036|
000654  f7fffffe          BL       assert_failed
                  |L1.1624|
;;;718      
;;;719      /* Return the CRC polynomial register */
;;;720      return SPIx->CRCPR;
000658  8a20              LDRH     r0,[r4,#0x10]
;;;721    }
00065a  bd10              POP      {r4,pc}
;;;722    
                          ENDP

                  SPI_BiDirectionalLineConfig PROC
;;;731      */
;;;732    void SPI_BiDirectionalLineConfig(SPI_TypeDef* SPIx, uint16_t SPI_Direction)
00065c  b570              PUSH     {r4-r6,lr}
;;;733    {
00065e  4604              MOV      r4,r0
;;;734      /* Check the parameters */
;;;735      assert_param(IS_SPI_ALL_PERIPH(SPIx));
000660  4864              LDR      r0,|L1.2036|
000662  460d              MOV      r5,r1                 ;733
000664  4284              CMP      r4,r0
000666  d00b              BEQ      |L1.1664|
000668  4863              LDR      r0,|L1.2040|
00066a  4284              CMP      r4,r0
00066c  d008              BEQ      |L1.1664|
00066e  4863              LDR      r0,|L1.2044|
000670  4284              CMP      r4,r0
000672  d005              BEQ      |L1.1664|
000674  f24021df          MOV      r1,#0x2df
000678  f2af2070          ADR      r0,|L1.1036|
00067c  f7fffffe          BL       assert_failed
                  |L1.1664|
;;;736      assert_param(IS_SPI_DIRECTION(SPI_Direction));
000680  f5a5403f          SUB      r0,r5,#0xbf00
000684  38ff              SUBS     r0,r0,#0xff
000686  d008              BEQ      |L1.1690|
000688  f5b54f80          CMP      r5,#0x4000
00068c  d009              BEQ      |L1.1698|
00068e  f44f7138          MOV      r1,#0x2e0
000692  f2af2088          ADR      r0,|L1.1036|
000696  f7fffffe          BL       assert_failed
                  |L1.1690|
;;;737      if (SPI_Direction == SPI_Direction_Tx)
;;;738      {
;;;739        /* Set the Tx only mode */
;;;740        SPIx->CR1 |= SPI_Direction_Tx;
;;;741      }
;;;742      else
;;;743      {
;;;744        /* Set the Rx only mode */
;;;745        SPIx->CR1 &= SPI_Direction_Rx;
00069a  8820              LDRH     r0,[r4,#0]
00069c  f4204080          BIC      r0,r0,#0x4000
0006a0  e002              B        |L1.1704|
                  |L1.1698|
0006a2  8820              LDRH     r0,[r4,#0]            ;740
0006a4  f4404080          ORR      r0,r0,#0x4000         ;740
                  |L1.1704|
0006a8  8020              STRH     r0,[r4,#0]
;;;746      }
;;;747    }
0006aa  bd70              POP      {r4-r6,pc}
;;;748    
                          ENDP

                  SPI_I2S_GetFlagStatus PROC
;;;765      */
;;;766    FlagStatus SPI_I2S_GetFlagStatus(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG)
0006ac  b570              PUSH     {r4-r6,lr}
;;;767    {
0006ae  4605              MOV      r5,r0
;;;768      FlagStatus bitstatus = RESET;
;;;769      /* Check the parameters */
;;;770      assert_param(IS_SPI_ALL_PERIPH(SPIx));
0006b0  4850              LDR      r0,|L1.2036|
0006b2  2600              MOVS     r6,#0                 ;768
0006b4  460c              MOV      r4,r1                 ;767
0006b6  4285              CMP      r5,r0
0006b8  d00b              BEQ      |L1.1746|
0006ba  484f              LDR      r0,|L1.2040|
0006bc  4285              CMP      r5,r0
0006be  d008              BEQ      |L1.1746|
0006c0  484e              LDR      r0,|L1.2044|
0006c2  4285              CMP      r5,r0
0006c4  d005              BEQ      |L1.1746|
0006c6  f2403102          MOV      r1,#0x302
0006ca  f2af20c0          ADR      r0,|L1.1036|
0006ce  f7fffffe          BL       assert_failed
                  |L1.1746|
;;;771      assert_param(IS_SPI_I2S_GET_FLAG(SPI_I2S_FLAG));
0006d2  2c80              CMP      r4,#0x80
0006d4  d013              BEQ      |L1.1790|
0006d6  2c40              CMP      r4,#0x40
0006d8  d011              BEQ      |L1.1790|
0006da  2c20              CMP      r4,#0x20
0006dc  d00f              BEQ      |L1.1790|
0006de  2c10              CMP      r4,#0x10
0006e0  d00d              BEQ      |L1.1790|
0006e2  2c08              CMP      r4,#8
0006e4  d00b              BEQ      |L1.1790|
0006e6  2c04              CMP      r4,#4
0006e8  d009              BEQ      |L1.1790|
0006ea  2c02              CMP      r4,#2
0006ec  d007              BEQ      |L1.1790|
0006ee  2c01              CMP      r4,#1
0006f0  d005              BEQ      |L1.1790|
0006f2  f2403103          MOV      r1,#0x303
0006f6  f2af20ec          ADR      r0,|L1.1036|
0006fa  f7fffffe          BL       assert_failed
                  |L1.1790|
;;;772      /* Check the status of the specified SPI/I2S flag */
;;;773      if ((SPIx->SR & SPI_I2S_FLAG) != (uint16_t)RESET)
0006fe  8928              LDRH     r0,[r5,#8]
000700  4220              TST      r0,r4
000702  d000              BEQ      |L1.1798|
;;;774      {
;;;775        /* SPI_I2S_FLAG is set */
;;;776        bitstatus = SET;
000704  2601              MOVS     r6,#1
                  |L1.1798|
;;;777      }
;;;778      else
;;;779      {
;;;780        /* SPI_I2S_FLAG is reset */
;;;781        bitstatus = RESET;
;;;782      }
;;;783      /* Return the SPI_I2S_FLAG status */
;;;784      return  bitstatus;
000706  4630              MOV      r0,r6
;;;785    }
000708  bd70              POP      {r4-r6,pc}
;;;786    
                          ENDP

                  SPI_I2S_ClearFlag PROC
;;;803      */
;;;804    void SPI_I2S_ClearFlag(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG)
00070a  b570              PUSH     {r4-r6,lr}
;;;805    {
00070c  4604              MOV      r4,r0
;;;806      /* Check the parameters */
;;;807      assert_param(IS_SPI_ALL_PERIPH(SPIx));
00070e  4839              LDR      r0,|L1.2036|
000710  460d              MOV      r5,r1                 ;805
000712  4284              CMP      r4,r0
000714  d00b              BEQ      |L1.1838|
000716  4838              LDR      r0,|L1.2040|
000718  4284              CMP      r4,r0
00071a  d008              BEQ      |L1.1838|
00071c  4837              LDR      r0,|L1.2044|
00071e  4284              CMP      r4,r0
000720  d005              BEQ      |L1.1838|
000722  f2403127          MOV      r1,#0x327
000726  f2af301c          ADR      r0,|L1.1036|
00072a  f7fffffe          BL       assert_failed
                  |L1.1838|
;;;808      assert_param(IS_SPI_I2S_CLEAR_FLAG(SPI_I2S_FLAG));
00072e  2d10              CMP      r5,#0x10
000730  d005              BEQ      |L1.1854|
000732  f44f714a          MOV      r1,#0x328
000736  f2af302c          ADR      r0,|L1.1036|
00073a  f7fffffe          BL       assert_failed
                  |L1.1854|
;;;809        
;;;810        /* Clear the selected SPI CRC Error (CRCERR) flag */
;;;811        SPIx->SR = (uint16_t)~SPI_I2S_FLAG;
00073e  43e8              MVNS     r0,r5
000740  8120              STRH     r0,[r4,#8]
;;;812    }
000742  bd70              POP      {r4-r6,pc}
;;;813    
                          ENDP

                  SPI_I2S_GetITStatus PROC
;;;828      */
;;;829    ITStatus SPI_I2S_GetITStatus(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT)
000744  b570              PUSH     {r4-r6,lr}
;;;830    {
000746  4605              MOV      r5,r0
;;;831      ITStatus bitstatus = RESET;
;;;832      uint16_t itpos = 0, itmask = 0, enablestatus = 0;
;;;833    
;;;834      /* Check the parameters */
;;;835      assert_param(IS_SPI_ALL_PERIPH(SPIx));
000748  482a              LDR      r0,|L1.2036|
00074a  2600              MOVS     r6,#0                 ;831
00074c  460c              MOV      r4,r1                 ;830
00074e  4285              CMP      r5,r0
000750  d00b              BEQ      |L1.1898|
000752  4829              LDR      r0,|L1.2040|
000754  4285              CMP      r5,r0
000756  d008              BEQ      |L1.1898|
000758  4828              LDR      r0,|L1.2044|
00075a  4285              CMP      r5,r0
00075c  d005              BEQ      |L1.1898|
00075e  f2403143          MOV      r1,#0x343
000762  f2af3058          ADR      r0,|L1.1036|
000766  f7fffffe          BL       assert_failed
                  |L1.1898|
;;;836      assert_param(IS_SPI_I2S_GET_IT(SPI_I2S_IT));
00076a  2c60              CMP      r4,#0x60
00076c  d00f              BEQ      |L1.1934|
00076e  2c71              CMP      r4,#0x71
000770  d00d              BEQ      |L1.1934|
000772  2c53              CMP      r4,#0x53
000774  d00b              BEQ      |L1.1934|
000776  2c54              CMP      r4,#0x54
000778  d009              BEQ      |L1.1934|
00077a  2c55              CMP      r4,#0x55
00077c  d007              BEQ      |L1.1934|
00077e  2c56              CMP      r4,#0x56
000780  d005              BEQ      |L1.1934|
000782  f44f7151          MOV      r1,#0x344
000786  f2af307c          ADR      r0,|L1.1036|
00078a  f7fffffe          BL       assert_failed
                  |L1.1934|
;;;837    
;;;838      /* Get the SPI/I2S IT index */
;;;839      itpos = 0x01 << (SPI_I2S_IT & 0x0F);
00078e  f004010f          AND      r1,r4,#0xf
000792  2001              MOVS     r0,#1
000794  fa00f101          LSL      r1,r0,r1
;;;840    
;;;841      /* Get the SPI/I2S IT mask */
;;;842      itmask = SPI_I2S_IT >> 4;
000798  0922              LSRS     r2,r4,#4
;;;843    
;;;844      /* Set the IT mask */
;;;845      itmask = 0x01 << itmask;
00079a  4090              LSLS     r0,r0,r2
;;;846    
;;;847      /* Get the SPI_I2S_IT enable bit status */
;;;848      enablestatus = (SPIx->CR2 & itmask) ;
00079c  88aa              LDRH     r2,[r5,#4]
00079e  b289              UXTH     r1,r1                 ;839
0007a0  b280              UXTH     r0,r0                 ;845
0007a2  4002              ANDS     r2,r2,r0
;;;849    
;;;850      /* Check the status of the specified SPI/I2S interrupt */
;;;851      if (((SPIx->SR & itpos) != (uint16_t)RESET) && enablestatus)
0007a4  8928              LDRH     r0,[r5,#8]
0007a6  4208              TST      r0,r1
0007a8  d001              BEQ      |L1.1966|
0007aa  b102              CBZ      r2,|L1.1966|
;;;852      {
;;;853        /* SPI_I2S_IT is set */
;;;854        bitstatus = SET;
0007ac  2601              MOVS     r6,#1
                  |L1.1966|
;;;855      }
;;;856      else
;;;857      {
;;;858        /* SPI_I2S_IT is reset */
;;;859        bitstatus = RESET;
;;;860      }
;;;861      /* Return the SPI_I2S_IT status */
;;;862      return bitstatus;
0007ae  4630              MOV      r0,r6
;;;863    }
0007b0  bd70              POP      {r4-r6,pc}
;;;864    
                          ENDP

                  SPI_I2S_ClearITPendingBit PROC
;;;882      */
;;;883    void SPI_I2S_ClearITPendingBit(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT)
0007b2  b570              PUSH     {r4-r6,lr}
;;;884    {
0007b4  4604              MOV      r4,r0
;;;885      uint16_t itpos = 0;
;;;886      /* Check the parameters */
;;;887      assert_param(IS_SPI_ALL_PERIPH(SPIx));
0007b6  480f              LDR      r0,|L1.2036|
0007b8  460d              MOV      r5,r1                 ;884
0007ba  4284              CMP      r4,r0
0007bc  d00b              BEQ      |L1.2006|
0007be  480e              LDR      r0,|L1.2040|
0007c0  4284              CMP      r4,r0
0007c2  d008              BEQ      |L1.2006|
0007c4  480d              LDR      r0,|L1.2044|
0007c6  4284              CMP      r4,r0
0007c8  d005              BEQ      |L1.2006|
0007ca  f2403177          MOV      r1,#0x377
0007ce  f2af30c4          ADR      r0,|L1.1036|
0007d2  f7fffffe          BL       assert_failed
                  |L1.2006|
;;;888      assert_param(IS_SPI_I2S_CLEAR_IT(SPI_I2S_IT));
0007d6  2d54              CMP      r5,#0x54
0007d8  d005              BEQ      |L1.2022|
0007da  f44f715e          MOV      r1,#0x378
0007de  f2af30d4          ADR      r0,|L1.1036|
0007e2  f7fffffe          BL       assert_failed
                  |L1.2022|
;;;889    
;;;890      /* Get the SPI IT index */
;;;891      itpos = 0x01 << (SPI_I2S_IT & 0x0F);
0007e6  f005010f          AND      r1,r5,#0xf
0007ea  2001              MOVS     r0,#1
0007ec  4088              LSLS     r0,r0,r1
;;;892    
;;;893      /* Clear the selected SPI CRC Error (CRCERR) interrupt pending bit */
;;;894      SPIx->SR = (uint16_t)~itpos;
0007ee  43c0              MVNS     r0,r0
0007f0  8120              STRH     r0,[r4,#8]
;;;895    }
0007f2  bd70              POP      {r4-r6,pc}
;;;896    /**
                          ENDP

                  |L1.2036|
                          DCD      0x40013000
                  |L1.2040|
                          DCD      0x40003800
                  |L1.2044|
                          DCD      0x40003c00
