; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o.\stm32f10x_usart.o --asm_dir=.\ --list_dir=.\ --depend=.\stm32f10x_usart.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\project -I..\hooks -I..\lcd -I..\led -I..\load_cpu -I..\main -I..\printf -I..\rtos -I..\control_task -I..\mode_task -I..\lcdTask -I..\..\CMSIS\CM3\CoreSupport -I..\..\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\STM32F10x_StdPeriph_Driver\inc -I..\..\STM32F10x_StdPeriph_Driver\src -I..\radio -I..\..\rtos -I"C:\Program Files\keil\ARM\RV31\INC" -I"C:\Program Files\keil\ARM\PACK\ARM\CMSIS\3.20.4\CMSIS\Include" -I"C:\Program Files\keil\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include" -DSTM32F10X_MD_VL -DUSE_STDPERIPH_DRIVER --omf_browse=.\stm32f10x_usart.crf ..\..\STM32F10x_StdPeriph_Driver\src\stm32f10x_usart.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  USART_DeInit PROC
;;;129      */
;;;130    void USART_DeInit(USART_TypeDef* USARTx)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;131    {
000004  4604              MOV      r4,r0
;;;132      /* Check the parameters */
;;;133      assert_param(IS_USART_ALL_PERIPH(USARTx));
000006  48fe              LDR      r0,|L1.1024|
000008  4284              CMP      r4,r0
00000a  d015              BEQ      |L1.56|
00000c  4ffd              LDR      r7,|L1.1028|
00000e  4dfe              LDR      r5,|L1.1032|
000010  4efe              LDR      r6,|L1.1036|
000012  f8df83fc          LDR      r8,|L1.1040|
000016  42bc              CMP      r4,r7
000018  d009              BEQ      |L1.46|
00001a  42ac              CMP      r4,r5
00001c  d007              BEQ      |L1.46|
00001e  42b4              CMP      r4,r6
000020  d005              BEQ      |L1.46|
000022  4544              CMP      r4,r8
000024  d01f              BEQ      |L1.102|
000026  2185              MOVS     r1,#0x85
000028  a0fa              ADR      r0,|L1.1044|
00002a  f7fffffe          BL       assert_failed
                  |L1.46|
;;;134    
;;;135      if (USARTx == USART1)
;;;136      {
;;;137        RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, ENABLE);
;;;138        RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, DISABLE);
;;;139      }
;;;140      else if (USARTx == USART2)
00002e  42bc              CMP      r4,r7
000030  d10d              BNE      |L1.78|
;;;141      {
;;;142        RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, ENABLE);
000032  2101              MOVS     r1,#1
000034  044c              LSLS     r4,r1,#17
;;;143        RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, DISABLE);
000036  e018              B        |L1.106|
                  |L1.56|
000038  2101              MOVS     r1,#1                 ;137
00003a  038c              LSLS     r4,r1,#14             ;137
00003c  4620              MOV      r0,r4                 ;137
00003e  f7fffffe          BL       RCC_APB2PeriphResetCmd
000042  4620              MOV      r0,r4                 ;138
000044  e8bd41f0          POP      {r4-r8,lr}            ;138
000048  2100              MOVS     r1,#0                 ;138
00004a  f7ffbffe          B.W      RCC_APB2PeriphResetCmd
                  |L1.78|
;;;144      }
;;;145      else if (USARTx == USART3)
00004e  42ac              CMP      r4,r5
000050  d102              BNE      |L1.88|
;;;146      {
;;;147        RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, ENABLE);
000052  2101              MOVS     r1,#1
000054  048c              LSLS     r4,r1,#18
;;;148        RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, DISABLE);
000056  e008              B        |L1.106|
                  |L1.88|
;;;149      }    
;;;150      else if (USARTx == UART4)
000058  42b4              CMP      r4,r6
00005a  d102              BNE      |L1.98|
;;;151      {
;;;152        RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, ENABLE);
00005c  2101              MOVS     r1,#1
00005e  04cc              LSLS     r4,r1,#19
;;;153        RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, DISABLE);
000060  e003              B        |L1.106|
                  |L1.98|
;;;154      }    
;;;155      else
;;;156      {
;;;157        if (USARTx == UART5)
000062  4544              CMP      r4,r8
000064  d10a              BNE      |L1.124|
                  |L1.102|
;;;158        { 
;;;159          RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, ENABLE);
000066  2101              MOVS     r1,#1
000068  050c              LSLS     r4,r1,#20
                  |L1.106|
00006a  4620              MOV      r0,r4
00006c  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;160          RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, DISABLE);
000070  4620              MOV      r0,r4
000072  e8bd41f0          POP      {r4-r8,lr}
000076  2100              MOVS     r1,#0
000078  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L1.124|
;;;161        }
;;;162      }
;;;163    }
00007c  e8bd81f0          POP      {r4-r8,pc}
;;;164    
                          ENDP

                  USART_Init PROC
;;;175      */
;;;176    void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
000080  e92d43f0          PUSH     {r4-r9,lr}
;;;177    {
;;;178      uint32_t tmpreg = 0x00, apbclock = 0x00;
;;;179      uint32_t integerdivider = 0x00;
;;;180      uint32_t fractionaldivider = 0x00;
;;;181      uint32_t usartxbase = 0;
;;;182      RCC_ClocksTypeDef RCC_ClocksStatus;
;;;183      /* Check the parameters */
;;;184      assert_param(IS_USART_ALL_PERIPH(USARTx));
000084  4ede              LDR      r6,|L1.1024|
000086  4fdf              LDR      r7,|L1.1028|
000088  f8df837c          LDR      r8,|L1.1032|
00008c  b085              SUB      sp,sp,#0x14           ;177
00008e  460d              MOV      r5,r1                 ;177
000090  4604              MOV      r4,r0                 ;177
000092  42b0              CMP      r0,r6
000094  d00d              BEQ      |L1.178|
000096  42bc              CMP      r4,r7
000098  d00b              BEQ      |L1.178|
00009a  4544              CMP      r4,r8
00009c  d009              BEQ      |L1.178|
00009e  48db              LDR      r0,|L1.1036|
0000a0  4284              CMP      r4,r0
0000a2  d006              BEQ      |L1.178|
0000a4  48da              LDR      r0,|L1.1040|
0000a6  4284              CMP      r4,r0
0000a8  d003              BEQ      |L1.178|
0000aa  21b8              MOVS     r1,#0xb8
0000ac  a0d9              ADR      r0,|L1.1044|
0000ae  f7fffffe          BL       assert_failed
                  |L1.178|
;;;185      assert_param(IS_USART_BAUDRATE(USART_InitStruct->USART_BaudRate));  
0000b2  6828              LDR      r0,[r5,#0]
0000b4  49e5              LDR      r1,|L1.1100|
0000b6  1e40              SUBS     r0,r0,#1
0000b8  4288              CMP      r0,r1
0000ba  d303              BCC      |L1.196|
0000bc  21b9              MOVS     r1,#0xb9
0000be  a0d5              ADR      r0,|L1.1044|
0000c0  f7fffffe          BL       assert_failed
                  |L1.196|
;;;186      assert_param(IS_USART_WORD_LENGTH(USART_InitStruct->USART_WordLength));
0000c4  88a8              LDRH     r0,[r5,#4]
0000c6  f44f5980          MOV      r9,#0x1000
0000ca  b128              CBZ      r0,|L1.216|
0000cc  4548              CMP      r0,r9
0000ce  d003              BEQ      |L1.216|
0000d0  21ba              MOVS     r1,#0xba
0000d2  a0d0              ADR      r0,|L1.1044|
0000d4  f7fffffe          BL       assert_failed
                  |L1.216|
;;;187      assert_param(IS_USART_STOPBITS(USART_InitStruct->USART_StopBits));
0000d8  88e8              LDRH     r0,[r5,#6]
0000da  b158              CBZ      r0,|L1.244|
0000dc  4548              CMP      r0,r9
0000de  d009              BEQ      |L1.244|
0000e0  f5b05f00          CMP      r0,#0x2000
0000e4  d006              BEQ      |L1.244|
0000e6  f5b05f40          CMP      r0,#0x3000
0000ea  d003              BEQ      |L1.244|
0000ec  21bb              MOVS     r1,#0xbb
0000ee  a0c9              ADR      r0,|L1.1044|
0000f0  f7fffffe          BL       assert_failed
                  |L1.244|
;;;188      assert_param(IS_USART_PARITY(USART_InitStruct->USART_Parity));
0000f4  8928              LDRH     r0,[r5,#8]
0000f6  b148              CBZ      r0,|L1.268|
0000f8  f5b06f80          CMP      r0,#0x400
0000fc  d006              BEQ      |L1.268|
0000fe  f5b06fc0          CMP      r0,#0x600
000102  d003              BEQ      |L1.268|
000104  21bc              MOVS     r1,#0xbc
000106  a0c3              ADR      r0,|L1.1044|
000108  f7fffffe          BL       assert_failed
                  |L1.268|
;;;189      assert_param(IS_USART_MODE(USART_InitStruct->USART_Mode));
00010c  8968              LDRH     r0,[r5,#0xa]
00010e  f030010c          BICS     r1,r0,#0xc
000112  d100              BNE      |L1.278|
000114  b918              CBNZ     r0,|L1.286|
                  |L1.278|
000116  21bd              MOVS     r1,#0xbd
000118  a0be              ADR      r0,|L1.1044|
00011a  f7fffffe          BL       assert_failed
                  |L1.286|
;;;190      assert_param(IS_USART_HARDWARE_FLOW_CONTROL(USART_InitStruct->USART_HardwareFlowControl));
00011e  89a8              LDRH     r0,[r5,#0xc]
000120  b1c0              CBZ      r0,|L1.340|
000122  f5b07f80          CMP      r0,#0x100
000126  d00b              BEQ      |L1.320|
000128  f5b07f00          CMP      r0,#0x200
00012c  d008              BEQ      |L1.320|
00012e  f5b07f40          CMP      r0,#0x300
000132  d005              BEQ      |L1.320|
000134  21be              MOVS     r1,#0xbe
000136  a0b7              ADR      r0,|L1.1044|
000138  f7fffffe          BL       assert_failed
;;;191      /* The hardware flow control is available only for USART1, USART2 and USART3 */
;;;192      if (USART_InitStruct->USART_HardwareFlowControl != USART_HardwareFlowControl_None)
00013c  89a8              LDRH     r0,[r5,#0xc]
00013e  b148              CBZ      r0,|L1.340|
                  |L1.320|
;;;193      {
;;;194        assert_param(IS_USART_123_PERIPH(USARTx));
000140  42b4              CMP      r4,r6
000142  d007              BEQ      |L1.340|
000144  42bc              CMP      r4,r7
000146  d005              BEQ      |L1.340|
000148  4544              CMP      r4,r8
00014a  d003              BEQ      |L1.340|
00014c  21c2              MOVS     r1,#0xc2
00014e  a0b1              ADR      r0,|L1.1044|
000150  f7fffffe          BL       assert_failed
                  |L1.340|
;;;195      }
;;;196    
;;;197      usartxbase = (uint32_t)USARTx;
;;;198    
;;;199    /*---------------------------- USART CR2 Configuration -----------------------*/
;;;200      tmpreg = USARTx->CR2;
000154  8a20              LDRH     r0,[r4,#0x10]
;;;201      /* Clear STOP[13:12] bits */
;;;202      tmpreg &= CR2_STOP_CLEAR_Mask;
000156  f64c71ff          MOV      r1,#0xcfff
00015a  4008              ANDS     r0,r0,r1
;;;203      /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit ------------*/
;;;204      /* Set STOP[13:12] bits according to USART_StopBits value */
;;;205      tmpreg |= (uint32_t)USART_InitStruct->USART_StopBits;
00015c  88e9              LDRH     r1,[r5,#6]
00015e  4301              ORRS     r1,r1,r0
;;;206      
;;;207      /* Write to USART CR2 */
;;;208      USARTx->CR2 = (uint16_t)tmpreg;
000160  8221              STRH     r1,[r4,#0x10]
;;;209    
;;;210    /*---------------------------- USART CR1 Configuration -----------------------*/
;;;211      tmpreg = USARTx->CR1;
000162  89a1              LDRH     r1,[r4,#0xc]
;;;212      /* Clear M, PCE, PS, TE and RE bits */
;;;213      tmpreg &= CR1_CLEAR_Mask;
000164  f64e10f3          MOV      r0,#0xe9f3
000168  4001              ANDS     r1,r1,r0
;;;214      /* Configure the USART Word Length, Parity and mode ----------------------- */
;;;215      /* Set the M bits according to USART_WordLength value */
;;;216      /* Set PCE and PS bits according to USART_Parity value */
;;;217      /* Set TE and RE bits according to USART_Mode value */
;;;218      tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
00016a  88a8              LDRH     r0,[r5,#4]
00016c  892a              LDRH     r2,[r5,#8]
00016e  4310              ORRS     r0,r0,r2
000170  896a              LDRH     r2,[r5,#0xa]
000172  430a              ORRS     r2,r2,r1
000174  4310              ORRS     r0,r0,r2
;;;219                USART_InitStruct->USART_Mode;
;;;220      /* Write to USART CR1 */
;;;221      USARTx->CR1 = (uint16_t)tmpreg;
000176  81a0              STRH     r0,[r4,#0xc]
;;;222    
;;;223    /*---------------------------- USART CR3 Configuration -----------------------*/  
;;;224      tmpreg = USARTx->CR3;
000178  8aa0              LDRH     r0,[r4,#0x14]
;;;225      /* Clear CTSE and RTSE bits */
;;;226      tmpreg &= CR3_CLEAR_Mask;
00017a  f64f41ff          MOV      r1,#0xfcff
00017e  4008              ANDS     r0,r0,r1
;;;227      /* Configure the USART HFC -------------------------------------------------*/
;;;228      /* Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
;;;229      tmpreg |= USART_InitStruct->USART_HardwareFlowControl;
000180  89a9              LDRH     r1,[r5,#0xc]
000182  4301              ORRS     r1,r1,r0
;;;230      /* Write to USART CR3 */
;;;231      USARTx->CR3 = (uint16_t)tmpreg;
000184  82a1              STRH     r1,[r4,#0x14]
;;;232    
;;;233    /*---------------------------- USART BRR Configuration -----------------------*/
;;;234      /* Configure the USART Baud Rate -------------------------------------------*/
;;;235      RCC_GetClocksFreq(&RCC_ClocksStatus);
000186  4668              MOV      r0,sp
000188  f7fffffe          BL       RCC_GetClocksFreq
;;;236      if (usartxbase == USART1_BASE)
00018c  42b4              CMP      r4,r6
00018e  d101              BNE      |L1.404|
;;;237      {
;;;238        apbclock = RCC_ClocksStatus.PCLK2_Frequency;
000190  9803              LDR      r0,[sp,#0xc]
000192  e000              B        |L1.406|
                  |L1.404|
;;;239      }
;;;240      else
;;;241      {
;;;242        apbclock = RCC_ClocksStatus.PCLK1_Frequency;
000194  9802              LDR      r0,[sp,#8]
                  |L1.406|
;;;243      }
;;;244      
;;;245      /* Determine the integer part */
;;;246      if ((USARTx->CR1 & CR1_OVER8_Set) != 0)
000196  89a1              LDRH     r1,[r4,#0xc]
000198  0409              LSLS     r1,r1,#16
;;;247      {
;;;248        /* Integer part computing in case Oversampling mode is 8 Samples */
;;;249        integerdivider = ((25 * apbclock) / (2 * (USART_InitStruct->USART_BaudRate)));    
;;;250      }
;;;251      else /* if ((USARTx->CR1 & CR1_OVER8_Set) == 0) */
;;;252      {
;;;253        /* Integer part computing in case Oversampling mode is 16 Samples */
;;;254        integerdivider = ((25 * apbclock) / (4 * (USART_InitStruct->USART_BaudRate)));    
00019a  eb0001c0          ADD      r1,r0,r0,LSL #3
00019e  eb011000          ADD      r0,r1,r0,LSL #4
0001a2  6829              LDR      r1,[r5,#0]            ;246
0001a4  d501              BPL      |L1.426|
0001a6  0049              LSLS     r1,r1,#1              ;249
0001a8  e000              B        |L1.428|
                  |L1.426|
0001aa  0089              LSLS     r1,r1,#2
                  |L1.428|
0001ac  fbb0f0f1          UDIV     r0,r0,r1
;;;255      }
;;;256      tmpreg = (integerdivider / 100) << 4;
0001b0  2264              MOVS     r2,#0x64
0001b2  fbb0f1f2          UDIV     r1,r0,r2
0001b6  0109              LSLS     r1,r1,#4
;;;257    
;;;258      /* Determine the fractional part */
;;;259      fractionaldivider = integerdivider - (100 * (tmpreg >> 4));
0001b8  090b              LSRS     r3,r1,#4
0001ba  f06f0518          MVN      r5,#0x18
0001be  436b              MULS     r3,r5,r3
0001c0  eb000083          ADD      r0,r0,r3,LSL #2
;;;260    
;;;261      /* Implement the fractional part in the register */
;;;262      if ((USARTx->CR1 & CR1_OVER8_Set) != 0)
0001c4  89a3              LDRH     r3,[r4,#0xc]
0001c6  041d              LSLS     r5,r3,#16
;;;263      {
;;;264        tmpreg |= ((((fractionaldivider * 8) + 50) / 100)) & ((uint8_t)0x07);
0001c8  f04f0332          MOV      r3,#0x32
0001cc  d506              BPL      |L1.476|
0001ce  eb0300c0          ADD      r0,r3,r0,LSL #3
0001d2  fbb0f0f2          UDIV     r0,r0,r2
0001d6  f0000007          AND      r0,r0,#7
0001da  e005              B        |L1.488|
                  |L1.476|
;;;265      }
;;;266      else /* if ((USARTx->CR1 & CR1_OVER8_Set) == 0) */
;;;267      {
;;;268        tmpreg |= ((((fractionaldivider * 16) + 50) / 100)) & ((uint8_t)0x0F);
0001dc  eb031000          ADD      r0,r3,r0,LSL #4
0001e0  fbb0f0f2          UDIV     r0,r0,r2
0001e4  f000000f          AND      r0,r0,#0xf
                  |L1.488|
0001e8  4308              ORRS     r0,r0,r1
;;;269      }
;;;270      
;;;271      /* Write to USART BRR */
;;;272      USARTx->BRR = (uint16_t)tmpreg;
0001ea  8120              STRH     r0,[r4,#8]
;;;273    }
0001ec  b005              ADD      sp,sp,#0x14
0001ee  e8bd83f0          POP      {r4-r9,pc}
;;;274    
                          ENDP

                  USART_StructInit PROC
;;;280      */
;;;281    void USART_StructInit(USART_InitTypeDef* USART_InitStruct)
0001f2  f44f5116          MOV      r1,#0x2580
;;;282    {
;;;283      /* USART_InitStruct members default value */
;;;284      USART_InitStruct->USART_BaudRate = 9600;
;;;285      USART_InitStruct->USART_WordLength = USART_WordLength_8b;
0001f6  6001              STR      r1,[r0,#0]
0001f8  2100              MOVS     r1,#0
0001fa  8081              STRH     r1,[r0,#4]
;;;286      USART_InitStruct->USART_StopBits = USART_StopBits_1;
0001fc  80c1              STRH     r1,[r0,#6]
;;;287      USART_InitStruct->USART_Parity = USART_Parity_No ;
0001fe  8101              STRH     r1,[r0,#8]
;;;288      USART_InitStruct->USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
000200  220c              MOVS     r2,#0xc
000202  8142              STRH     r2,[r0,#0xa]
;;;289      USART_InitStruct->USART_HardwareFlowControl = USART_HardwareFlowControl_None;  
000204  8181              STRH     r1,[r0,#0xc]
;;;290    }
000206  4770              BX       lr
;;;291    
                          ENDP

                  USART_ClockInit PROC
;;;301      */
;;;302    void USART_ClockInit(USART_TypeDef* USARTx, USART_ClockInitTypeDef* USART_ClockInitStruct)
000208  b570              PUSH     {r4-r6,lr}
;;;303    {
00020a  4605              MOV      r5,r0
;;;304      uint32_t tmpreg = 0x00;
;;;305      /* Check the parameters */
;;;306      assert_param(IS_USART_123_PERIPH(USARTx));
00020c  487c              LDR      r0,|L1.1024|
00020e  460c              MOV      r4,r1                 ;303
000210  4285              CMP      r5,r0
000212  d00a              BEQ      |L1.554|
000214  487b              LDR      r0,|L1.1028|
000216  4285              CMP      r5,r0
000218  d007              BEQ      |L1.554|
00021a  487b              LDR      r0,|L1.1032|
00021c  4285              CMP      r5,r0
00021e  d004              BEQ      |L1.554|
000220  f44f7199          MOV      r1,#0x132
000224  a07b              ADR      r0,|L1.1044|
000226  f7fffffe          BL       assert_failed
                  |L1.554|
;;;307      assert_param(IS_USART_CLOCK(USART_ClockInitStruct->USART_Clock));
00022a  8820              LDRH     r0,[r4,#0]
00022c  b138              CBZ      r0,|L1.574|
00022e  f5b06f00          CMP      r0,#0x800
000232  d004              BEQ      |L1.574|
000234  f2401133          MOV      r1,#0x133
000238  a076              ADR      r0,|L1.1044|
00023a  f7fffffe          BL       assert_failed
                  |L1.574|
;;;308      assert_param(IS_USART_CPOL(USART_ClockInitStruct->USART_CPOL));
00023e  8860              LDRH     r0,[r4,#2]
000240  b138              CBZ      r0,|L1.594|
000242  f5b06f80          CMP      r0,#0x400
000246  d004              BEQ      |L1.594|
000248  f44f719a          MOV      r1,#0x134
00024c  a071              ADR      r0,|L1.1044|
00024e  f7fffffe          BL       assert_failed
                  |L1.594|
;;;309      assert_param(IS_USART_CPHA(USART_ClockInitStruct->USART_CPHA));
000252  88a0              LDRH     r0,[r4,#4]
000254  b138              CBZ      r0,|L1.614|
000256  f5b07f00          CMP      r0,#0x200
00025a  d004              BEQ      |L1.614|
00025c  f2401135          MOV      r1,#0x135
000260  a06c              ADR      r0,|L1.1044|
000262  f7fffffe          BL       assert_failed
                  |L1.614|
;;;310      assert_param(IS_USART_LASTBIT(USART_ClockInitStruct->USART_LastBit));
000266  88e0              LDRH     r0,[r4,#6]
000268  b138              CBZ      r0,|L1.634|
00026a  f5b07f80          CMP      r0,#0x100
00026e  d004              BEQ      |L1.634|
000270  f44f719b          MOV      r1,#0x136
000274  a067              ADR      r0,|L1.1044|
000276  f7fffffe          BL       assert_failed
                  |L1.634|
;;;311      
;;;312    /*---------------------------- USART CR2 Configuration -----------------------*/
;;;313      tmpreg = USARTx->CR2;
00027a  8a29              LDRH     r1,[r5,#0x10]
;;;314      /* Clear CLKEN, CPOL, CPHA and LBCL bits */
;;;315      tmpreg &= CR2_CLOCK_CLEAR_Mask;
00027c  f24f00ff          MOV      r0,#0xf0ff
000280  4001              ANDS     r1,r1,r0
;;;316      /* Configure the USART Clock, CPOL, CPHA and LastBit ------------*/
;;;317      /* Set CLKEN bit according to USART_Clock value */
;;;318      /* Set CPOL bit according to USART_CPOL value */
;;;319      /* Set CPHA bit according to USART_CPHA value */
;;;320      /* Set LBCL bit according to USART_LastBit value */
;;;321      tmpreg |= (uint32_t)USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
000282  8820              LDRH     r0,[r4,#0]
000284  8862              LDRH     r2,[r4,#2]
000286  88e3              LDRH     r3,[r4,#6]
000288  4310              ORRS     r0,r0,r2
00028a  88a2              LDRH     r2,[r4,#4]
00028c  431a              ORRS     r2,r2,r3
00028e  4310              ORRS     r0,r0,r2
000290  4308              ORRS     r0,r0,r1
;;;322                     USART_ClockInitStruct->USART_CPHA | USART_ClockInitStruct->USART_LastBit;
;;;323      /* Write to USART CR2 */
;;;324      USARTx->CR2 = (uint16_t)tmpreg;
000292  8228              STRH     r0,[r5,#0x10]
;;;325    }
000294  bd70              POP      {r4-r6,pc}
;;;326    
                          ENDP

                  USART_ClockStructInit PROC
;;;332      */
;;;333    void USART_ClockStructInit(USART_ClockInitTypeDef* USART_ClockInitStruct)
000296  2100              MOVS     r1,#0
;;;334    {
;;;335      /* USART_ClockInitStruct members default value */
;;;336      USART_ClockInitStruct->USART_Clock = USART_Clock_Disable;
000298  8001              STRH     r1,[r0,#0]
;;;337      USART_ClockInitStruct->USART_CPOL = USART_CPOL_Low;
00029a  8041              STRH     r1,[r0,#2]
;;;338      USART_ClockInitStruct->USART_CPHA = USART_CPHA_1Edge;
00029c  8081              STRH     r1,[r0,#4]
;;;339      USART_ClockInitStruct->USART_LastBit = USART_LastBit_Disable;
00029e  80c1              STRH     r1,[r0,#6]
;;;340    }
0002a0  4770              BX       lr
;;;341    
                          ENDP

                  USART_Cmd PROC
;;;350      */
;;;351    void USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
0002a2  b570              PUSH     {r4-r6,lr}
;;;352    {
0002a4  4604              MOV      r4,r0
;;;353      /* Check the parameters */
;;;354      assert_param(IS_USART_ALL_PERIPH(USARTx));
0002a6  4856              LDR      r0,|L1.1024|
0002a8  460d              MOV      r5,r1                 ;352
0002aa  4284              CMP      r4,r0
0002ac  d010              BEQ      |L1.720|
0002ae  4855              LDR      r0,|L1.1028|
0002b0  4284              CMP      r4,r0
0002b2  d00d              BEQ      |L1.720|
0002b4  4854              LDR      r0,|L1.1032|
0002b6  4284              CMP      r4,r0
0002b8  d00a              BEQ      |L1.720|
0002ba  4854              LDR      r0,|L1.1036|
0002bc  4284              CMP      r4,r0
0002be  d007              BEQ      |L1.720|
0002c0  4853              LDR      r0,|L1.1040|
0002c2  4284              CMP      r4,r0
0002c4  d004              BEQ      |L1.720|
0002c6  f44f71b1          MOV      r1,#0x162
0002ca  a052              ADR      r0,|L1.1044|
0002cc  f7fffffe          BL       assert_failed
                  |L1.720|
;;;355      assert_param(IS_FUNCTIONAL_STATE(NewState));
0002d0  b155              CBZ      r5,|L1.744|
0002d2  2d01              CMP      r5,#1
0002d4  d004              BEQ      |L1.736|
0002d6  f2401163          MOV      r1,#0x163
0002da  a04e              ADR      r0,|L1.1044|
0002dc  f7fffffe          BL       assert_failed
                  |L1.736|
;;;356      
;;;357      if (NewState != DISABLE)
;;;358      {
;;;359        /* Enable the selected USART by setting the UE bit in the CR1 register */
;;;360        USARTx->CR1 |= CR1_UE_Set;
0002e0  89a0              LDRH     r0,[r4,#0xc]
0002e2  f4405000          ORR      r0,r0,#0x2000
0002e6  e002              B        |L1.750|
                  |L1.744|
;;;361      }
;;;362      else
;;;363      {
;;;364        /* Disable the selected USART by clearing the UE bit in the CR1 register */
;;;365        USARTx->CR1 &= CR1_UE_Reset;
0002e8  89a0              LDRH     r0,[r4,#0xc]
0002ea  f4205000          BIC      r0,r0,#0x2000
                  |L1.750|
0002ee  81a0              STRH     r0,[r4,#0xc]          ;360
;;;366      }
;;;367    }
0002f0  bd70              POP      {r4-r6,pc}
;;;368    
                          ENDP

                  USART_ITConfig PROC
;;;387      */
;;;388    void USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState)
0002f2  e92d47f0          PUSH     {r4-r10,lr}
;;;389    {
;;;390      uint32_t usartreg = 0x00, itpos = 0x00, itmask = 0x00;
;;;391      uint32_t usartxbase = 0x00;
;;;392      /* Check the parameters */
;;;393      assert_param(IS_USART_ALL_PERIPH(USARTx));
0002f6  f8df8108          LDR      r8,|L1.1024|
0002fa  f8df9108          LDR      r9,|L1.1028|
0002fe  f8dfa108          LDR      r10,|L1.1032|
000302  4616              MOV      r6,r2                 ;389
000304  460d              MOV      r5,r1                 ;389
000306  4604              MOV      r4,r0                 ;389
000308  4540              CMP      r0,r8
00030a  d00e              BEQ      |L1.810|
00030c  454c              CMP      r4,r9
00030e  d00c              BEQ      |L1.810|
000310  4554              CMP      r4,r10
000312  d00a              BEQ      |L1.810|
000314  483d              LDR      r0,|L1.1036|
000316  4284              CMP      r4,r0
000318  d007              BEQ      |L1.810|
00031a  483d              LDR      r0,|L1.1040|
00031c  4284              CMP      r4,r0
00031e  d004              BEQ      |L1.810|
000320  f2401189          MOV      r1,#0x189
000324  a03b              ADR      r0,|L1.1044|
000326  f7fffffe          BL       assert_failed
                  |L1.810|
;;;394      assert_param(IS_USART_CONFIG_IT(USART_IT));
00032a  f640176a          MOV      r7,#0x96a
00032e  2d28              CMP      r5,#0x28
000330  d01c              BEQ      |L1.876|
000332  f5a560e0          SUB      r0,r5,#0x700
000336  3827              SUBS     r0,r0,#0x27
000338  d018              BEQ      |L1.876|
00033a  f5a560c0          SUB      r0,r5,#0x600
00033e  3826              SUBS     r0,r0,#0x26
000340  d014              BEQ      |L1.876|
000342  f5a560a0          SUB      r0,r5,#0x500
000346  3825              SUBS     r0,r0,#0x25
000348  d010              BEQ      |L1.876|
00034a  f5a56080          SUB      r0,r5,#0x400
00034e  3824              SUBS     r0,r0,#0x24
000350  d00c              BEQ      |L1.876|
000352  f5a56000          SUB      r0,r5,#0x800
000356  3846              SUBS     r0,r0,#0x46
000358  d008              BEQ      |L1.876|
00035a  42bd              CMP      r5,r7
00035c  d006              BEQ      |L1.876|
00035e  2d60              CMP      r5,#0x60
000360  d004              BEQ      |L1.876|
000362  f44f71c5          MOV      r1,#0x18a
000366  a02b              ADR      r0,|L1.1044|
000368  f7fffffe          BL       assert_failed
                  |L1.876|
;;;395      assert_param(IS_FUNCTIONAL_STATE(NewState));
00036c  b136              CBZ      r6,|L1.892|
00036e  2e01              CMP      r6,#1
000370  d004              BEQ      |L1.892|
000372  f240118b          MOV      r1,#0x18b
000376  a027              ADR      r0,|L1.1044|
000378  f7fffffe          BL       assert_failed
                  |L1.892|
;;;396      /* The CTS interrupt is not available for UART4 and UART5 */
;;;397      if (USART_IT == USART_IT_CTS)
00037c  42bd              CMP      r5,r7
00037e  d10a              BNE      |L1.918|
;;;398      {
;;;399        assert_param(IS_USART_123_PERIPH(USARTx));
000380  4544              CMP      r4,r8
000382  d008              BEQ      |L1.918|
000384  454c              CMP      r4,r9
000386  d006              BEQ      |L1.918|
000388  4554              CMP      r4,r10
00038a  d004              BEQ      |L1.918|
00038c  f240118f          MOV      r1,#0x18f
000390  a020              ADR      r0,|L1.1044|
000392  f7fffffe          BL       assert_failed
                  |L1.918|
;;;400      }   
;;;401      
;;;402      usartxbase = (uint32_t)USARTx;
;;;403    
;;;404      /* Get the USART register index */
;;;405      usartreg = (((uint8_t)USART_IT) >> 0x05);
;;;406    
;;;407      /* Get the interrupt position */
;;;408      itpos = USART_IT & IT_Mask;
000396  f005021f          AND      r2,r5,#0x1f
;;;409      itmask = (((uint32_t)0x01) << itpos);
00039a  2001              MOVS     r0,#1
00039c  f3c51142          UBFX     r1,r5,#5,#3           ;405
0003a0  4090              LSLS     r0,r0,r2
;;;410        
;;;411      if (usartreg == 0x01) /* The IT is in CR1 register */
0003a2  2901              CMP      r1,#1
0003a4  d006              BEQ      |L1.948|
;;;412      {
;;;413        usartxbase += 0x0C;
;;;414      }
;;;415      else if (usartreg == 0x02) /* The IT is in CR2 register */
0003a6  2902              CMP      r1,#2
0003a8  d006              BEQ      |L1.952|
0003aa  3414              ADDS     r4,r4,#0x14
                  |L1.940|
;;;416      {
;;;417        usartxbase += 0x10;
;;;418      }
;;;419      else /* The IT is in CR3 register */
;;;420      {
;;;421        usartxbase += 0x14; 
;;;422      }
;;;423      if (NewState != DISABLE)
;;;424      {
;;;425        *(__IO uint32_t*)usartxbase  |= itmask;
;;;426      }
;;;427      else
;;;428      {
;;;429        *(__IO uint32_t*)usartxbase &= ~itmask;
0003ac  6821              LDR      r1,[r4,#0]
0003ae  b12e              CBZ      r6,|L1.956|
0003b0  4301              ORRS     r1,r1,r0              ;425
0003b2  e004              B        |L1.958|
                  |L1.948|
0003b4  340c              ADDS     r4,r4,#0xc            ;425
0003b6  e7f9              B        |L1.940|
                  |L1.952|
0003b8  3410              ADDS     r4,r4,#0x10           ;413
0003ba  e7f7              B        |L1.940|
                  |L1.956|
0003bc  4381              BICS     r1,r1,r0
                  |L1.958|
0003be  6021              STR      r1,[r4,#0]            ;425
                  |L1.960|
;;;430      }
;;;431    }
0003c0  e8bd87f0          POP      {r4-r10,pc}
;;;432    
                          ENDP

                  USART_DMACmd PROC
;;;447      */
;;;448    void USART_DMACmd(USART_TypeDef* USARTx, uint16_t USART_DMAReq, FunctionalState NewState)
0003c4  b570              PUSH     {r4-r6,lr}
;;;449    {
0003c6  4604              MOV      r4,r0
;;;450      /* Check the parameters */
;;;451      assert_param(IS_USART_ALL_PERIPH(USARTx));
0003c8  480d              LDR      r0,|L1.1024|
0003ca  4616              MOV      r6,r2                 ;449
0003cc  460d              MOV      r5,r1                 ;449
0003ce  4284              CMP      r4,r0
0003d0  d010              BEQ      |L1.1012|
0003d2  480c              LDR      r0,|L1.1028|
0003d4  4284              CMP      r4,r0
0003d6  d00d              BEQ      |L1.1012|
0003d8  480b              LDR      r0,|L1.1032|
0003da  4284              CMP      r4,r0
0003dc  d00a              BEQ      |L1.1012|
0003de  480b              LDR      r0,|L1.1036|
0003e0  4284              CMP      r4,r0
0003e2  d007              BEQ      |L1.1012|
0003e4  480a              LDR      r0,|L1.1040|
0003e6  4284              CMP      r4,r0
0003e8  d004              BEQ      |L1.1012|
0003ea  f24011c3          MOV      r1,#0x1c3
0003ee  a009              ADR      r0,|L1.1044|
0003f0  f7fffffe          BL       assert_failed
                  |L1.1012|
;;;452      assert_param(IS_USART_DMAREQ(USART_DMAReq));  
0003f4  f03500c0          BICS     r0,r5,#0xc0
0003f8  d100              BNE      |L1.1020|
0003fa  b905              CBNZ     r5,|L1.1022|
                  |L1.1020|
0003fc  e028              B        |L1.1104|
                  |L1.1022|
0003fe  e02d              B        |L1.1116|
                  |L1.1024|
                          DCD      0x40013800
                  |L1.1028|
                          DCD      0x40004400
                  |L1.1032|
                          DCD      0x40004800
                  |L1.1036|
                          DCD      0x40004c00
                  |L1.1040|
                          DCD      0x40005000
                  |L1.1044|
000414  2e2e5c2e          DCB      "..\\..\\STM32F10x_StdPeriph_Driver\\src\\stm32f10x_usar"
000418  2e5c5354
00041c  4d333246
000420  3130785f
000424  53746450
000428  65726970
00042c  685f4472
000430  69766572
000434  5c737263
000438  5c73746d
00043c  33326631
000440  30785f75
000444  736172  
000447  742e6300          DCB      "t.c",0
00044b  00                DCB      0
                  |L1.1100|
                          DCD      0x0044aa20
                  |L1.1104|
000450  f44f71e2          MOV      r1,#0x1c4
000454  f2af0044          ADR      r0,|L1.1044|
000458  f7fffffe          BL       assert_failed
                  |L1.1116|
;;;453      assert_param(IS_FUNCTIONAL_STATE(NewState)); 
00045c  b156              CBZ      r6,|L1.1140|
00045e  2e01              CMP      r6,#1
000460  d005              BEQ      |L1.1134|
000462  f24011c5          MOV      r1,#0x1c5
000466  f2af0054          ADR      r0,|L1.1044|
00046a  f7fffffe          BL       assert_failed
                  |L1.1134|
;;;454      if (NewState != DISABLE)
;;;455      {
;;;456        /* Enable the DMA transfer for selected requests by setting the DMAT and/or
;;;457           DMAR bits in the USART CR3 register */
;;;458        USARTx->CR3 |= USART_DMAReq;
00046e  8aa0              LDRH     r0,[r4,#0x14]
000470  4328              ORRS     r0,r0,r5
000472  e001              B        |L1.1144|
                  |L1.1140|
;;;459      }
;;;460      else
;;;461      {
;;;462        /* Disable the DMA transfer for selected requests by clearing the DMAT and/or
;;;463           DMAR bits in the USART CR3 register */
;;;464        USARTx->CR3 &= (uint16_t)~USART_DMAReq;
000474  8aa0              LDRH     r0,[r4,#0x14]
000476  43a8              BICS     r0,r0,r5
                  |L1.1144|
000478  82a0              STRH     r0,[r4,#0x14]         ;458
;;;465      }
;;;466    }
00047a  bd70              POP      {r4-r6,pc}
;;;467    
                          ENDP

                  USART_SetAddress PROC
;;;475      */
;;;476    void USART_SetAddress(USART_TypeDef* USARTx, uint8_t USART_Address)
00047c  b570              PUSH     {r4-r6,lr}
;;;477    {
00047e  4604              MOV      r4,r0
;;;478      /* Check the parameters */
;;;479      assert_param(IS_USART_ALL_PERIPH(USARTx));
000480  48fc              LDR      r0,|L1.2164|
000482  460d              MOV      r5,r1                 ;477
000484  4284              CMP      r4,r0
000486  d011              BEQ      |L1.1196|
000488  48fb              LDR      r0,|L1.2168|
00048a  4284              CMP      r4,r0
00048c  d00e              BEQ      |L1.1196|
00048e  48fb              LDR      r0,|L1.2172|
000490  4284              CMP      r4,r0
000492  d00b              BEQ      |L1.1196|
000494  48fa              LDR      r0,|L1.2176|
000496  4284              CMP      r4,r0
000498  d008              BEQ      |L1.1196|
00049a  48fa              LDR      r0,|L1.2180|
00049c  4284              CMP      r4,r0
00049e  d005              BEQ      |L1.1196|
0004a0  f24011df          MOV      r1,#0x1df
0004a4  f2af0094          ADR      r0,|L1.1044|
0004a8  f7fffffe          BL       assert_failed
                  |L1.1196|
;;;480      assert_param(IS_USART_ADDRESS(USART_Address)); 
0004ac  2d0f              CMP      r5,#0xf
0004ae  d905              BLS      |L1.1212|
0004b0  f44f71f0          MOV      r1,#0x1e0
0004b4  f2af00a4          ADR      r0,|L1.1044|
0004b8  f7fffffe          BL       assert_failed
                  |L1.1212|
;;;481        
;;;482      /* Clear the USART address */
;;;483      USARTx->CR2 &= CR2_Address_Mask;
0004bc  8a20              LDRH     r0,[r4,#0x10]
0004be  f020000f          BIC      r0,r0,#0xf
0004c2  8220              STRH     r0,[r4,#0x10]
;;;484      /* Set the USART address node */
;;;485      USARTx->CR2 |= USART_Address;
0004c4  8a20              LDRH     r0,[r4,#0x10]
0004c6  4328              ORRS     r0,r0,r5
0004c8  8220              STRH     r0,[r4,#0x10]
;;;486    }
0004ca  bd70              POP      {r4-r6,pc}
;;;487    
                          ENDP

                  USART_WakeUpConfig PROC
;;;498      */
;;;499    void USART_WakeUpConfig(USART_TypeDef* USARTx, uint16_t USART_WakeUp)
0004cc  b570              PUSH     {r4-r6,lr}
;;;500    {
0004ce  4604              MOV      r4,r0
;;;501      /* Check the parameters */
;;;502      assert_param(IS_USART_ALL_PERIPH(USARTx));
0004d0  48e8              LDR      r0,|L1.2164|
0004d2  460d              MOV      r5,r1                 ;500
0004d4  4284              CMP      r4,r0
0004d6  d011              BEQ      |L1.1276|
0004d8  48e7              LDR      r0,|L1.2168|
0004da  4284              CMP      r4,r0
0004dc  d00e              BEQ      |L1.1276|
0004de  48e7              LDR      r0,|L1.2172|
0004e0  4284              CMP      r4,r0
0004e2  d00b              BEQ      |L1.1276|
0004e4  48e6              LDR      r0,|L1.2176|
0004e6  4284              CMP      r4,r0
0004e8  d008              BEQ      |L1.1276|
0004ea  48e6              LDR      r0,|L1.2180|
0004ec  4284              CMP      r4,r0
0004ee  d005              BEQ      |L1.1276|
0004f0  f44f71fb          MOV      r1,#0x1f6
0004f4  f2af00e4          ADR      r0,|L1.1044|
0004f8  f7fffffe          BL       assert_failed
                  |L1.1276|
;;;503      assert_param(IS_USART_WAKEUP(USART_WakeUp));
0004fc  b145              CBZ      r5,|L1.1296|
0004fe  f5b56f00          CMP      r5,#0x800
000502  d005              BEQ      |L1.1296|
000504  f24011f7          MOV      r1,#0x1f7
000508  f2af00f8          ADR      r0,|L1.1044|
00050c  f7fffffe          BL       assert_failed
                  |L1.1296|
;;;504      
;;;505      USARTx->CR1 &= CR1_WAKE_Mask;
000510  89a0              LDRH     r0,[r4,#0xc]
000512  f4206000          BIC      r0,r0,#0x800
000516  81a0              STRH     r0,[r4,#0xc]
;;;506      USARTx->CR1 |= USART_WakeUp;
000518  89a0              LDRH     r0,[r4,#0xc]
00051a  4328              ORRS     r0,r0,r5
00051c  81a0              STRH     r0,[r4,#0xc]
;;;507    }
00051e  bd70              POP      {r4-r6,pc}
;;;508    
                          ENDP

                  USART_ReceiverWakeUpCmd PROC
;;;517      */
;;;518    void USART_ReceiverWakeUpCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000520  b570              PUSH     {r4-r6,lr}
;;;519    {
000522  4604              MOV      r4,r0
;;;520      /* Check the parameters */
;;;521      assert_param(IS_USART_ALL_PERIPH(USARTx));
000524  48d3              LDR      r0,|L1.2164|
000526  460d              MOV      r5,r1                 ;519
000528  4284              CMP      r4,r0
00052a  d011              BEQ      |L1.1360|
00052c  48d2              LDR      r0,|L1.2168|
00052e  4284              CMP      r4,r0
000530  d00e              BEQ      |L1.1360|
000532  48d2              LDR      r0,|L1.2172|
000534  4284              CMP      r4,r0
000536  d00b              BEQ      |L1.1360|
000538  48d1              LDR      r0,|L1.2176|
00053a  4284              CMP      r4,r0
00053c  d008              BEQ      |L1.1360|
00053e  48d1              LDR      r0,|L1.2180|
000540  4284              CMP      r4,r0
000542  d005              BEQ      |L1.1360|
000544  f2402109          MOV      r1,#0x209
000548  f2af1038          ADR      r0,|L1.1044|
00054c  f7fffffe          BL       assert_failed
                  |L1.1360|
;;;522      assert_param(IS_FUNCTIONAL_STATE(NewState)); 
000550  b15d              CBZ      r5,|L1.1386|
000552  2d01              CMP      r5,#1
000554  d005              BEQ      |L1.1378|
000556  f240210a          MOV      r1,#0x20a
00055a  f2af1048          ADR      r0,|L1.1044|
00055e  f7fffffe          BL       assert_failed
                  |L1.1378|
;;;523      
;;;524      if (NewState != DISABLE)
;;;525      {
;;;526        /* Enable the USART mute mode  by setting the RWU bit in the CR1 register */
;;;527        USARTx->CR1 |= CR1_RWU_Set;
000562  89a0              LDRH     r0,[r4,#0xc]
000564  f0400002          ORR      r0,r0,#2
000568  e002              B        |L1.1392|
                  |L1.1386|
;;;528      }
;;;529      else
;;;530      {
;;;531        /* Disable the USART mute mode by clearing the RWU bit in the CR1 register */
;;;532        USARTx->CR1 &= CR1_RWU_Reset;
00056a  89a0              LDRH     r0,[r4,#0xc]
00056c  f0200002          BIC      r0,r0,#2
                  |L1.1392|
000570  81a0              STRH     r0,[r4,#0xc]          ;527
;;;533      }
;;;534    }
000572  bd70              POP      {r4-r6,pc}
;;;535    
                          ENDP

                  USART_LINBreakDetectLengthConfig PROC
;;;546      */
;;;547    void USART_LINBreakDetectLengthConfig(USART_TypeDef* USARTx, uint16_t USART_LINBreakDetectLength)
000574  b570              PUSH     {r4-r6,lr}
;;;548    {
000576  4604              MOV      r4,r0
;;;549      /* Check the parameters */
;;;550      assert_param(IS_USART_ALL_PERIPH(USARTx));
000578  48be              LDR      r0,|L1.2164|
00057a  460d              MOV      r5,r1                 ;548
00057c  4284              CMP      r4,r0
00057e  d011              BEQ      |L1.1444|
000580  48bd              LDR      r0,|L1.2168|
000582  4284              CMP      r4,r0
000584  d00e              BEQ      |L1.1444|
000586  48bd              LDR      r0,|L1.2172|
000588  4284              CMP      r4,r0
00058a  d00b              BEQ      |L1.1444|
00058c  48bc              LDR      r0,|L1.2176|
00058e  4284              CMP      r4,r0
000590  d008              BEQ      |L1.1444|
000592  48bc              LDR      r0,|L1.2180|
000594  4284              CMP      r4,r0
000596  d005              BEQ      |L1.1444|
000598  f2402126          MOV      r1,#0x226
00059c  f2af108c          ADR      r0,|L1.1044|
0005a0  f7fffffe          BL       assert_failed
                  |L1.1444|
;;;551      assert_param(IS_USART_LIN_BREAK_DETECT_LENGTH(USART_LINBreakDetectLength));
0005a4  b13d              CBZ      r5,|L1.1462|
0005a6  2d20              CMP      r5,#0x20
0005a8  d005              BEQ      |L1.1462|
0005aa  f2402127          MOV      r1,#0x227
0005ae  f2af109c          ADR      r0,|L1.1044|
0005b2  f7fffffe          BL       assert_failed
                  |L1.1462|
;;;552      
;;;553      USARTx->CR2 &= CR2_LBDL_Mask;
0005b6  8a20              LDRH     r0,[r4,#0x10]
0005b8  f0200020          BIC      r0,r0,#0x20
0005bc  8220              STRH     r0,[r4,#0x10]
;;;554      USARTx->CR2 |= USART_LINBreakDetectLength;  
0005be  8a20              LDRH     r0,[r4,#0x10]
0005c0  4328              ORRS     r0,r0,r5
0005c2  8220              STRH     r0,[r4,#0x10]
;;;555    }
0005c4  bd70              POP      {r4-r6,pc}
;;;556    
                          ENDP

                  USART_LINCmd PROC
;;;565      */
;;;566    void USART_LINCmd(USART_TypeDef* USARTx, FunctionalState NewState)
0005c6  b570              PUSH     {r4-r6,lr}
;;;567    {
0005c8  4604              MOV      r4,r0
;;;568      /* Check the parameters */
;;;569      assert_param(IS_USART_ALL_PERIPH(USARTx));
0005ca  48aa              LDR      r0,|L1.2164|
0005cc  460d              MOV      r5,r1                 ;567
0005ce  4284              CMP      r4,r0
0005d0  d011              BEQ      |L1.1526|
0005d2  48a9              LDR      r0,|L1.2168|
0005d4  4284              CMP      r4,r0
0005d6  d00e              BEQ      |L1.1526|
0005d8  48a8              LDR      r0,|L1.2172|
0005da  4284              CMP      r4,r0
0005dc  d00b              BEQ      |L1.1526|
0005de  48a8              LDR      r0,|L1.2176|
0005e0  4284              CMP      r4,r0
0005e2  d008              BEQ      |L1.1526|
0005e4  48a7              LDR      r0,|L1.2180|
0005e6  4284              CMP      r4,r0
0005e8  d005              BEQ      |L1.1526|
0005ea  f2402139          MOV      r1,#0x239
0005ee  f2af10dc          ADR      r0,|L1.1044|
0005f2  f7fffffe          BL       assert_failed
                  |L1.1526|
;;;570      assert_param(IS_FUNCTIONAL_STATE(NewState));
0005f6  b15d              CBZ      r5,|L1.1552|
0005f8  2d01              CMP      r5,#1
0005fa  d005              BEQ      |L1.1544|
0005fc  f240213a          MOV      r1,#0x23a
000600  f2af10f0          ADR      r0,|L1.1044|
000604  f7fffffe          BL       assert_failed
                  |L1.1544|
;;;571      
;;;572      if (NewState != DISABLE)
;;;573      {
;;;574        /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
;;;575        USARTx->CR2 |= CR2_LINEN_Set;
000608  8a20              LDRH     r0,[r4,#0x10]
00060a  f4404080          ORR      r0,r0,#0x4000
00060e  e002              B        |L1.1558|
                  |L1.1552|
;;;576      }
;;;577      else
;;;578      {
;;;579        /* Disable the LIN mode by clearing the LINEN bit in the CR2 register */
;;;580        USARTx->CR2 &= CR2_LINEN_Reset;
000610  8a20              LDRH     r0,[r4,#0x10]
000612  f4204080          BIC      r0,r0,#0x4000
                  |L1.1558|
000616  8220              STRH     r0,[r4,#0x10]         ;575
;;;581      }
;;;582    }
000618  bd70              POP      {r4-r6,pc}
;;;583    
                          ENDP

                  USART_SendData PROC
;;;591      */
;;;592    void USART_SendData(USART_TypeDef* USARTx, uint16_t Data)
00061a  b570              PUSH     {r4-r6,lr}
;;;593    {
00061c  4604              MOV      r4,r0
;;;594      /* Check the parameters */
;;;595      assert_param(IS_USART_ALL_PERIPH(USARTx));
00061e  4895              LDR      r0,|L1.2164|
000620  460d              MOV      r5,r1                 ;593
000622  4284              CMP      r4,r0
000624  d011              BEQ      |L1.1610|
000626  4894              LDR      r0,|L1.2168|
000628  4284              CMP      r4,r0
00062a  d00e              BEQ      |L1.1610|
00062c  4893              LDR      r0,|L1.2172|
00062e  4284              CMP      r4,r0
000630  d00b              BEQ      |L1.1610|
000632  4893              LDR      r0,|L1.2176|
000634  4284              CMP      r4,r0
000636  d008              BEQ      |L1.1610|
000638  4892              LDR      r0,|L1.2180|
00063a  4284              CMP      r4,r0
00063c  d005              BEQ      |L1.1610|
00063e  f2402153          MOV      r1,#0x253
000642  f2af2030          ADR      r0,|L1.1044|
000646  f7fffffe          BL       assert_failed
                  |L1.1610|
;;;596      assert_param(IS_USART_DATA(Data)); 
00064a  f5b57f00          CMP      r5,#0x200
00064e  d305              BCC      |L1.1628|
000650  f44f7115          MOV      r1,#0x254
000654  f2af2044          ADR      r0,|L1.1044|
000658  f7fffffe          BL       assert_failed
                  |L1.1628|
;;;597        
;;;598      /* Transmit Data */
;;;599      USARTx->DR = (Data & (uint16_t)0x01FF);
00065c  f3c50008          UBFX     r0,r5,#0,#9
000660  80a0              STRH     r0,[r4,#4]
;;;600    }
000662  bd70              POP      {r4-r6,pc}
;;;601    
                          ENDP

                  USART_ReceiveData PROC
;;;608      */
;;;609    uint16_t USART_ReceiveData(USART_TypeDef* USARTx)
000664  b510              PUSH     {r4,lr}
;;;610    {
000666  4604              MOV      r4,r0
;;;611      /* Check the parameters */
;;;612      assert_param(IS_USART_ALL_PERIPH(USARTx));
000668  4882              LDR      r0,|L1.2164|
00066a  4284              CMP      r4,r0
00066c  d011              BEQ      |L1.1682|
00066e  4882              LDR      r0,|L1.2168|
000670  4284              CMP      r4,r0
000672  d00e              BEQ      |L1.1682|
000674  4881              LDR      r0,|L1.2172|
000676  4284              CMP      r4,r0
000678  d00b              BEQ      |L1.1682|
00067a  4881              LDR      r0,|L1.2176|
00067c  4284              CMP      r4,r0
00067e  d008              BEQ      |L1.1682|
000680  4880              LDR      r0,|L1.2180|
000682  4284              CMP      r4,r0
000684  d005              BEQ      |L1.1682|
000686  f44f7119          MOV      r1,#0x264
00068a  f2af2078          ADR      r0,|L1.1044|
00068e  f7fffffe          BL       assert_failed
                  |L1.1682|
;;;613      
;;;614      /* Receive Data */
;;;615      return (uint16_t)(USARTx->DR & (uint16_t)0x01FF);
000692  88a0              LDRH     r0,[r4,#4]
000694  f3c00008          UBFX     r0,r0,#0,#9
;;;616    }
000698  bd10              POP      {r4,pc}
;;;617    
                          ENDP

                  USART_SendBreak PROC
;;;624      */
;;;625    void USART_SendBreak(USART_TypeDef* USARTx)
00069a  b510              PUSH     {r4,lr}
;;;626    {
00069c  4604              MOV      r4,r0
;;;627      /* Check the parameters */
;;;628      assert_param(IS_USART_ALL_PERIPH(USARTx));
00069e  4875              LDR      r0,|L1.2164|
0006a0  4284              CMP      r4,r0
0006a2  d011              BEQ      |L1.1736|
0006a4  4874              LDR      r0,|L1.2168|
0006a6  4284              CMP      r4,r0
0006a8  d00e              BEQ      |L1.1736|
0006aa  4874              LDR      r0,|L1.2172|
0006ac  4284              CMP      r4,r0
0006ae  d00b              BEQ      |L1.1736|
0006b0  4873              LDR      r0,|L1.2176|
0006b2  4284              CMP      r4,r0
0006b4  d008              BEQ      |L1.1736|
0006b6  4873              LDR      r0,|L1.2180|
0006b8  4284              CMP      r4,r0
0006ba  d005              BEQ      |L1.1736|
0006bc  f44f711d          MOV      r1,#0x274
0006c0  f2af20b0          ADR      r0,|L1.1044|
0006c4  f7fffffe          BL       assert_failed
                  |L1.1736|
;;;629      
;;;630      /* Send break characters */
;;;631      USARTx->CR1 |= CR1_SBK_Set;
0006c8  89a0              LDRH     r0,[r4,#0xc]
0006ca  f0400001          ORR      r0,r0,#1
0006ce  81a0              STRH     r0,[r4,#0xc]
;;;632    }
0006d0  bd10              POP      {r4,pc}
;;;633    
                          ENDP

                  USART_SetGuardTime PROC
;;;640      */
;;;641    void USART_SetGuardTime(USART_TypeDef* USARTx, uint8_t USART_GuardTime)
0006d2  b570              PUSH     {r4-r6,lr}
;;;642    {    
0006d4  4604              MOV      r4,r0
;;;643      /* Check the parameters */
;;;644      assert_param(IS_USART_123_PERIPH(USARTx));
0006d6  4867              LDR      r0,|L1.2164|
0006d8  460d              MOV      r5,r1                 ;642
0006da  4284              CMP      r4,r0
0006dc  d00b              BEQ      |L1.1782|
0006de  4866              LDR      r0,|L1.2168|
0006e0  4284              CMP      r4,r0
0006e2  d008              BEQ      |L1.1782|
0006e4  4865              LDR      r0,|L1.2172|
0006e6  4284              CMP      r4,r0
0006e8  d005              BEQ      |L1.1782|
0006ea  f44f7121          MOV      r1,#0x284
0006ee  f2af20dc          ADR      r0,|L1.1044|
0006f2  f7fffffe          BL       assert_failed
                  |L1.1782|
;;;645      
;;;646      /* Clear the USART Guard time */
;;;647      USARTx->GTPR &= GTPR_LSB_Mask;
0006f6  8b20              LDRH     r0,[r4,#0x18]
0006f8  b2c0              UXTB     r0,r0
0006fa  8320              STRH     r0,[r4,#0x18]
;;;648      /* Set the USART guard time */
;;;649      USARTx->GTPR |= (uint16_t)((uint16_t)USART_GuardTime << 0x08);
0006fc  8b20              LDRH     r0,[r4,#0x18]
0006fe  ea402005          ORR      r0,r0,r5,LSL #8
000702  8320              STRH     r0,[r4,#0x18]
;;;650    }
000704  bd70              POP      {r4-r6,pc}
;;;651    
                          ENDP

                  USART_SetPrescaler PROC
;;;660      */
;;;661    void USART_SetPrescaler(USART_TypeDef* USARTx, uint8_t USART_Prescaler)
000706  b570              PUSH     {r4-r6,lr}
;;;662    { 
000708  4604              MOV      r4,r0
;;;663      /* Check the parameters */
;;;664      assert_param(IS_USART_ALL_PERIPH(USARTx));
00070a  485a              LDR      r0,|L1.2164|
00070c  460d              MOV      r5,r1                 ;662
00070e  4284              CMP      r4,r0
000710  d011              BEQ      |L1.1846|
000712  4859              LDR      r0,|L1.2168|
000714  4284              CMP      r4,r0
000716  d00e              BEQ      |L1.1846|
000718  4858              LDR      r0,|L1.2172|
00071a  4284              CMP      r4,r0
00071c  d00b              BEQ      |L1.1846|
00071e  4858              LDR      r0,|L1.2176|
000720  4284              CMP      r4,r0
000722  d008              BEQ      |L1.1846|
000724  4857              LDR      r0,|L1.2180|
000726  4284              CMP      r4,r0
000728  d005              BEQ      |L1.1846|
00072a  f44f7126          MOV      r1,#0x298
00072e  f2af301c          ADR      r0,|L1.1044|
000732  f7fffffe          BL       assert_failed
                  |L1.1846|
;;;665      
;;;666      /* Clear the USART prescaler */
;;;667      USARTx->GTPR &= GTPR_MSB_Mask;
000736  8b20              LDRH     r0,[r4,#0x18]
000738  f400407f          AND      r0,r0,#0xff00
00073c  8320              STRH     r0,[r4,#0x18]
;;;668      /* Set the USART prescaler */
;;;669      USARTx->GTPR |= USART_Prescaler;
00073e  8b20              LDRH     r0,[r4,#0x18]
000740  4328              ORRS     r0,r0,r5
000742  8320              STRH     r0,[r4,#0x18]
;;;670    }
000744  bd70              POP      {r4-r6,pc}
;;;671    
                          ENDP

                  USART_SmartCardCmd PROC
;;;679      */
;;;680    void USART_SmartCardCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000746  b570              PUSH     {r4-r6,lr}
;;;681    {
000748  4604              MOV      r4,r0
;;;682      /* Check the parameters */
;;;683      assert_param(IS_USART_123_PERIPH(USARTx));
00074a  484a              LDR      r0,|L1.2164|
00074c  460d              MOV      r5,r1                 ;681
00074e  4284              CMP      r4,r0
000750  d00b              BEQ      |L1.1898|
000752  4849              LDR      r0,|L1.2168|
000754  4284              CMP      r4,r0
000756  d008              BEQ      |L1.1898|
000758  4848              LDR      r0,|L1.2172|
00075a  4284              CMP      r4,r0
00075c  d005              BEQ      |L1.1898|
00075e  f24021ab          MOV      r1,#0x2ab
000762  f2af3050          ADR      r0,|L1.1044|
000766  f7fffffe          BL       assert_failed
                  |L1.1898|
;;;684      assert_param(IS_FUNCTIONAL_STATE(NewState));
00076a  b15d              CBZ      r5,|L1.1924|
00076c  2d01              CMP      r5,#1
00076e  d005              BEQ      |L1.1916|
000770  f44f712b          MOV      r1,#0x2ac
000774  f2af3064          ADR      r0,|L1.1044|
000778  f7fffffe          BL       assert_failed
                  |L1.1916|
;;;685      if (NewState != DISABLE)
;;;686      {
;;;687        /* Enable the SC mode by setting the SCEN bit in the CR3 register */
;;;688        USARTx->CR3 |= CR3_SCEN_Set;
00077c  8aa0              LDRH     r0,[r4,#0x14]
00077e  f0400020          ORR      r0,r0,#0x20
000782  e002              B        |L1.1930|
                  |L1.1924|
;;;689      }
;;;690      else
;;;691      {
;;;692        /* Disable the SC mode by clearing the SCEN bit in the CR3 register */
;;;693        USARTx->CR3 &= CR3_SCEN_Reset;
000784  8aa0              LDRH     r0,[r4,#0x14]
000786  f0200020          BIC      r0,r0,#0x20
                  |L1.1930|
00078a  82a0              STRH     r0,[r4,#0x14]         ;688
;;;694      }
;;;695    }
00078c  bd70              POP      {r4-r6,pc}
;;;696    
                          ENDP

                  USART_SmartCardNACKCmd PROC
;;;704      */
;;;705    void USART_SmartCardNACKCmd(USART_TypeDef* USARTx, FunctionalState NewState)
00078e  b570              PUSH     {r4-r6,lr}
;;;706    {
000790  4604              MOV      r4,r0
;;;707      /* Check the parameters */
;;;708      assert_param(IS_USART_123_PERIPH(USARTx));  
000792  4838              LDR      r0,|L1.2164|
000794  460d              MOV      r5,r1                 ;706
000796  4284              CMP      r4,r0
000798  d00b              BEQ      |L1.1970|
00079a  4837              LDR      r0,|L1.2168|
00079c  4284              CMP      r4,r0
00079e  d008              BEQ      |L1.1970|
0007a0  4836              LDR      r0,|L1.2172|
0007a2  4284              CMP      r4,r0
0007a4  d005              BEQ      |L1.1970|
0007a6  f44f7131          MOV      r1,#0x2c4
0007aa  f2af3098          ADR      r0,|L1.1044|
0007ae  f7fffffe          BL       assert_failed
                  |L1.1970|
;;;709      assert_param(IS_FUNCTIONAL_STATE(NewState));
0007b2  b15d              CBZ      r5,|L1.1996|
0007b4  2d01              CMP      r5,#1
0007b6  d005              BEQ      |L1.1988|
0007b8  f24021c5          MOV      r1,#0x2c5
0007bc  f2af30ac          ADR      r0,|L1.1044|
0007c0  f7fffffe          BL       assert_failed
                  |L1.1988|
;;;710      if (NewState != DISABLE)
;;;711      {
;;;712        /* Enable the NACK transmission by setting the NACK bit in the CR3 register */
;;;713        USARTx->CR3 |= CR3_NACK_Set;
0007c4  8aa0              LDRH     r0,[r4,#0x14]
0007c6  f0400010          ORR      r0,r0,#0x10
0007ca  e002              B        |L1.2002|
                  |L1.1996|
;;;714      }
;;;715      else
;;;716      {
;;;717        /* Disable the NACK transmission by clearing the NACK bit in the CR3 register */
;;;718        USARTx->CR3 &= CR3_NACK_Reset;
0007cc  8aa0              LDRH     r0,[r4,#0x14]
0007ce  f0200010          BIC      r0,r0,#0x10
                  |L1.2002|
0007d2  82a0              STRH     r0,[r4,#0x14]         ;713
;;;719      }
;;;720    }
0007d4  bd70              POP      {r4-r6,pc}
;;;721    
                          ENDP

                  USART_HalfDuplexCmd PROC
;;;730      */
;;;731    void USART_HalfDuplexCmd(USART_TypeDef* USARTx, FunctionalState NewState)
0007d6  b570              PUSH     {r4-r6,lr}
;;;732    {
0007d8  4604              MOV      r4,r0
;;;733      /* Check the parameters */
;;;734      assert_param(IS_USART_ALL_PERIPH(USARTx));
0007da  4826              LDR      r0,|L1.2164|
0007dc  460d              MOV      r5,r1                 ;732
0007de  4284              CMP      r4,r0
0007e0  d011              BEQ      |L1.2054|
0007e2  4825              LDR      r0,|L1.2168|
0007e4  4284              CMP      r4,r0
0007e6  d00e              BEQ      |L1.2054|
0007e8  4824              LDR      r0,|L1.2172|
0007ea  4284              CMP      r4,r0
0007ec  d00b              BEQ      |L1.2054|
0007ee  4824              LDR      r0,|L1.2176|
0007f0  4284              CMP      r4,r0
0007f2  d008              BEQ      |L1.2054|
0007f4  4823              LDR      r0,|L1.2180|
0007f6  4284              CMP      r4,r0
0007f8  d005              BEQ      |L1.2054|
0007fa  f24021de          MOV      r1,#0x2de
0007fe  f2af30ec          ADR      r0,|L1.1044|
000802  f7fffffe          BL       assert_failed
                  |L1.2054|
;;;735      assert_param(IS_FUNCTIONAL_STATE(NewState));
000806  b15d              CBZ      r5,|L1.2080|
000808  2d01              CMP      r5,#1
00080a  d005              BEQ      |L1.2072|
00080c  f24021df          MOV      r1,#0x2df
000810  f2af4000          ADR      r0,|L1.1044|
000814  f7fffffe          BL       assert_failed
                  |L1.2072|
;;;736      
;;;737      if (NewState != DISABLE)
;;;738      {
;;;739        /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
;;;740        USARTx->CR3 |= CR3_HDSEL_Set;
000818  8aa0              LDRH     r0,[r4,#0x14]
00081a  f0400008          ORR      r0,r0,#8
00081e  e002              B        |L1.2086|
                  |L1.2080|
;;;741      }
;;;742      else
;;;743      {
;;;744        /* Disable the Half-Duplex mode by clearing the HDSEL bit in the CR3 register */
;;;745        USARTx->CR3 &= CR3_HDSEL_Reset;
000820  8aa0              LDRH     r0,[r4,#0x14]
000822  f0200008          BIC      r0,r0,#8
                  |L1.2086|
000826  82a0              STRH     r0,[r4,#0x14]         ;740
;;;746      }
;;;747    }
000828  bd70              POP      {r4-r6,pc}
;;;748    
                          ENDP

                  USART_OverSampling8Cmd PROC
;;;761      */
;;;762    void USART_OverSampling8Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
00082a  b570              PUSH     {r4-r6,lr}
;;;763    {
00082c  4604              MOV      r4,r0
;;;764      /* Check the parameters */
;;;765      assert_param(IS_USART_ALL_PERIPH(USARTx));
00082e  4811              LDR      r0,|L1.2164|
000830  460d              MOV      r5,r1                 ;763
000832  4284              CMP      r4,r0
000834  d011              BEQ      |L1.2138|
000836  4810              LDR      r0,|L1.2168|
000838  4284              CMP      r4,r0
00083a  d00e              BEQ      |L1.2138|
00083c  480f              LDR      r0,|L1.2172|
00083e  4284              CMP      r4,r0
000840  d00b              BEQ      |L1.2138|
000842  480f              LDR      r0,|L1.2176|
000844  4284              CMP      r4,r0
000846  d008              BEQ      |L1.2138|
000848  480e              LDR      r0,|L1.2180|
00084a  4284              CMP      r4,r0
00084c  d005              BEQ      |L1.2138|
00084e  f24021fd          MOV      r1,#0x2fd
000852  f2af4040          ADR      r0,|L1.1044|
000856  f7fffffe          BL       assert_failed
                  |L1.2138|
;;;766      assert_param(IS_FUNCTIONAL_STATE(NewState));
00085a  b1ad              CBZ      r5,|L1.2184|
00085c  2d01              CMP      r5,#1
00085e  d005              BEQ      |L1.2156|
000860  f24021fe          MOV      r1,#0x2fe
000864  f2af4054          ADR      r0,|L1.1044|
000868  f7fffffe          BL       assert_failed
                  |L1.2156|
;;;767      
;;;768      if (NewState != DISABLE)
;;;769      {
;;;770        /* Enable the 8x Oversampling mode by setting the OVER8 bit in the CR1 register */
;;;771        USARTx->CR1 |= CR1_OVER8_Set;
00086c  89a0              LDRH     r0,[r4,#0xc]
00086e  f4404000          ORR      r0,r0,#0x8000
000872  e00c              B        |L1.2190|
                  |L1.2164|
                          DCD      0x40013800
                  |L1.2168|
                          DCD      0x40004400
                  |L1.2172|
                          DCD      0x40004800
                  |L1.2176|
                          DCD      0x40004c00
                  |L1.2180|
                          DCD      0x40005000
                  |L1.2184|
;;;772      }
;;;773      else
;;;774      {
;;;775        /* Disable the 8x Oversampling mode by clearing the OVER8 bit in the CR1 register */
;;;776        USARTx->CR1 &= CR1_OVER8_Reset;
000888  89a0              LDRH     r0,[r4,#0xc]
00088a  f3c0000e          UBFX     r0,r0,#0,#15
                  |L1.2190|
00088e  81a0              STRH     r0,[r4,#0xc]          ;771
;;;777      }
;;;778    }
000890  bd70              POP      {r4-r6,pc}
;;;779    
                          ENDP

                  USART_OneBitMethodCmd PROC
;;;788      */
;;;789    void USART_OneBitMethodCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000892  b570              PUSH     {r4-r6,lr}
;;;790    {
000894  4604              MOV      r4,r0
;;;791      /* Check the parameters */
;;;792      assert_param(IS_USART_ALL_PERIPH(USARTx));
000896  48d1              LDR      r0,|L1.3036|
000898  460d              MOV      r5,r1                 ;790
00089a  4284              CMP      r4,r0
00089c  d011              BEQ      |L1.2242|
00089e  48d0              LDR      r0,|L1.3040|
0008a0  4284              CMP      r4,r0
0008a2  d00e              BEQ      |L1.2242|
0008a4  48cf              LDR      r0,|L1.3044|
0008a6  4284              CMP      r4,r0
0008a8  d00b              BEQ      |L1.2242|
0008aa  48cf              LDR      r0,|L1.3048|
0008ac  4284              CMP      r4,r0
0008ae  d008              BEQ      |L1.2242|
0008b0  48ce              LDR      r0,|L1.3052|
0008b2  4284              CMP      r4,r0
0008b4  d005              BEQ      |L1.2242|
0008b6  f44f7146          MOV      r1,#0x318
0008ba  f2af40a8          ADR      r0,|L1.1044|
0008be  f7fffffe          BL       assert_failed
                  |L1.2242|
;;;793      assert_param(IS_FUNCTIONAL_STATE(NewState));
0008c2  b15d              CBZ      r5,|L1.2268|
0008c4  2d01              CMP      r5,#1
0008c6  d005              BEQ      |L1.2260|
0008c8  f2403119          MOV      r1,#0x319
0008cc  f2af40bc          ADR      r0,|L1.1044|
0008d0  f7fffffe          BL       assert_failed
                  |L1.2260|
;;;794      
;;;795      if (NewState != DISABLE)
;;;796      {
;;;797        /* Enable the one bit method by setting the ONEBITE bit in the CR3 register */
;;;798        USARTx->CR3 |= CR3_ONEBITE_Set;
0008d4  8aa0              LDRH     r0,[r4,#0x14]
0008d6  f4406000          ORR      r0,r0,#0x800
0008da  e002              B        |L1.2274|
                  |L1.2268|
;;;799      }
;;;800      else
;;;801      {
;;;802        /* Disable tthe one bit method by clearing the ONEBITE bit in the CR3 register */
;;;803        USARTx->CR3 &= CR3_ONEBITE_Reset;
0008dc  8aa0              LDRH     r0,[r4,#0x14]
0008de  f4206000          BIC      r0,r0,#0x800
                  |L1.2274|
0008e2  82a0              STRH     r0,[r4,#0x14]         ;798
;;;804      }
;;;805    }
0008e4  bd70              POP      {r4-r6,pc}
;;;806    
                          ENDP

                  USART_IrDAConfig PROC
;;;817      */
;;;818    void USART_IrDAConfig(USART_TypeDef* USARTx, uint16_t USART_IrDAMode)
0008e6  b570              PUSH     {r4-r6,lr}
;;;819    {
0008e8  4604              MOV      r4,r0
;;;820      /* Check the parameters */
;;;821      assert_param(IS_USART_ALL_PERIPH(USARTx));
0008ea  48bc              LDR      r0,|L1.3036|
0008ec  460d              MOV      r5,r1                 ;819
0008ee  4284              CMP      r4,r0
0008f0  d011              BEQ      |L1.2326|
0008f2  48bb              LDR      r0,|L1.3040|
0008f4  4284              CMP      r4,r0
0008f6  d00e              BEQ      |L1.2326|
0008f8  48ba              LDR      r0,|L1.3044|
0008fa  4284              CMP      r4,r0
0008fc  d00b              BEQ      |L1.2326|
0008fe  48ba              LDR      r0,|L1.3048|
000900  4284              CMP      r4,r0
000902  d008              BEQ      |L1.2326|
000904  48b9              LDR      r0,|L1.3052|
000906  4284              CMP      r4,r0
000908  d005              BEQ      |L1.2326|
00090a  f2403135          MOV      r1,#0x335
00090e  f2af40fc          ADR      r0,|L1.1044|
000912  f7fffffe          BL       assert_failed
                  |L1.2326|
;;;822      assert_param(IS_USART_IRDA_MODE(USART_IrDAMode));
000916  2d04              CMP      r5,#4
000918  d006              BEQ      |L1.2344|
00091a  b12d              CBZ      r5,|L1.2344|
00091c  f2403136          MOV      r1,#0x336
000920  f2af5010          ADR      r0,|L1.1044|
000924  f7fffffe          BL       assert_failed
                  |L1.2344|
;;;823        
;;;824      USARTx->CR3 &= CR3_IRLP_Mask;
000928  8aa0              LDRH     r0,[r4,#0x14]
00092a  f0200004          BIC      r0,r0,#4
00092e  82a0              STRH     r0,[r4,#0x14]
;;;825      USARTx->CR3 |= USART_IrDAMode;
000930  8aa0              LDRH     r0,[r4,#0x14]
000932  4328              ORRS     r0,r0,r5
000934  82a0              STRH     r0,[r4,#0x14]
;;;826    }
000936  bd70              POP      {r4-r6,pc}
;;;827    
                          ENDP

                  USART_IrDACmd PROC
;;;836      */
;;;837    void USART_IrDACmd(USART_TypeDef* USARTx, FunctionalState NewState)
000938  b570              PUSH     {r4-r6,lr}
;;;838    {
00093a  4604              MOV      r4,r0
;;;839      /* Check the parameters */
;;;840      assert_param(IS_USART_ALL_PERIPH(USARTx));
00093c  48a7              LDR      r0,|L1.3036|
00093e  460d              MOV      r5,r1                 ;838
000940  4284              CMP      r4,r0
000942  d011              BEQ      |L1.2408|
000944  48a6              LDR      r0,|L1.3040|
000946  4284              CMP      r4,r0
000948  d00e              BEQ      |L1.2408|
00094a  48a6              LDR      r0,|L1.3044|
00094c  4284              CMP      r4,r0
00094e  d00b              BEQ      |L1.2408|
000950  48a5              LDR      r0,|L1.3048|
000952  4284              CMP      r4,r0
000954  d008              BEQ      |L1.2408|
000956  48a5              LDR      r0,|L1.3052|
000958  4284              CMP      r4,r0
00095a  d005              BEQ      |L1.2408|
00095c  f44f7152          MOV      r1,#0x348
000960  f2af5050          ADR      r0,|L1.1044|
000964  f7fffffe          BL       assert_failed
                  |L1.2408|
;;;841      assert_param(IS_FUNCTIONAL_STATE(NewState));
000968  b15d              CBZ      r5,|L1.2434|
00096a  2d01              CMP      r5,#1
00096c  d005              BEQ      |L1.2426|
00096e  f2403149          MOV      r1,#0x349
000972  f2af5060          ADR      r0,|L1.1044|
000976  f7fffffe          BL       assert_failed
                  |L1.2426|
;;;842        
;;;843      if (NewState != DISABLE)
;;;844      {
;;;845        /* Enable the IrDA mode by setting the IREN bit in the CR3 register */
;;;846        USARTx->CR3 |= CR3_IREN_Set;
00097a  8aa0              LDRH     r0,[r4,#0x14]
00097c  f0400002          ORR      r0,r0,#2
000980  e002              B        |L1.2440|
                  |L1.2434|
;;;847      }
;;;848      else
;;;849      {
;;;850        /* Disable the IrDA mode by clearing the IREN bit in the CR3 register */
;;;851        USARTx->CR3 &= CR3_IREN_Reset;
000982  8aa0              LDRH     r0,[r4,#0x14]
000984  f0200002          BIC      r0,r0,#2
                  |L1.2440|
000988  82a0              STRH     r0,[r4,#0x14]         ;846
;;;852      }
;;;853    }
00098a  bd70              POP      {r4-r6,pc}
;;;854    
                          ENDP

                  USART_GetFlagStatus PROC
;;;873      */
;;;874    FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint16_t USART_FLAG)
00098c  e92d47f0          PUSH     {r4-r10,lr}
;;;875    {
;;;876      FlagStatus bitstatus = RESET;
;;;877      /* Check the parameters */
;;;878      assert_param(IS_USART_ALL_PERIPH(USARTx));
000990  4f92              LDR      r7,|L1.3036|
000992  2600              MOVS     r6,#0                 ;876
000994  f8df8248          LDR      r8,|L1.3040|
000998  f8df9248          LDR      r9,|L1.3044|
00099c  460c              MOV      r4,r1                 ;875
00099e  4605              MOV      r5,r0                 ;875
0009a0  42b8              CMP      r0,r7
0009a2  d00f              BEQ      |L1.2500|
0009a4  4545              CMP      r5,r8
0009a6  d00d              BEQ      |L1.2500|
0009a8  454d              CMP      r5,r9
0009aa  d00b              BEQ      |L1.2500|
0009ac  488e              LDR      r0,|L1.3048|
0009ae  4285              CMP      r5,r0
0009b0  d008              BEQ      |L1.2500|
0009b2  488e              LDR      r0,|L1.3052|
0009b4  4285              CMP      r5,r0
0009b6  d005              BEQ      |L1.2500|
0009b8  f240316e          MOV      r1,#0x36e
0009bc  f2af50ac          ADR      r0,|L1.1044|
0009c0  f7fffffe          BL       assert_failed
                  |L1.2500|
;;;879      assert_param(IS_USART_FLAG(USART_FLAG));
0009c4  2c01              CMP      r4,#1
0009c6  d022              BEQ      |L1.2574|
0009c8  2c80              CMP      r4,#0x80
0009ca  d020              BEQ      |L1.2574|
0009cc  2c40              CMP      r4,#0x40
0009ce  d01e              BEQ      |L1.2574|
0009d0  2c20              CMP      r4,#0x20
0009d2  d01c              BEQ      |L1.2574|
0009d4  2c10              CMP      r4,#0x10
0009d6  d01a              BEQ      |L1.2574|
0009d8  f5b47f80          CMP      r4,#0x100
0009dc  d017              BEQ      |L1.2574|
0009de  f5b47f00          CMP      r4,#0x200
0009e2  d008              BEQ      |L1.2550|
0009e4  2c08              CMP      r4,#8
0009e6  d012              BEQ      |L1.2574|
0009e8  2c04              CMP      r4,#4
0009ea  d010              BEQ      |L1.2574|
0009ec  2c02              CMP      r4,#2
0009ee  d00e              BEQ      |L1.2574|
0009f0  f240316f          MOV      r1,#0x36f
0009f4  e007              B        |L1.2566|
                  |L1.2550|
;;;880      /* The CTS flag is not available for UART4 and UART5 */
;;;881      if (USART_FLAG == USART_FLAG_CTS)
;;;882      {
;;;883        assert_param(IS_USART_123_PERIPH(USARTx));
0009f6  42bd              CMP      r5,r7
0009f8  d009              BEQ      |L1.2574|
0009fa  4545              CMP      r5,r8
0009fc  d007              BEQ      |L1.2574|
0009fe  454d              CMP      r5,r9
000a00  d005              BEQ      |L1.2574|
000a02  f2403173          MOV      r1,#0x373
                  |L1.2566|
000a06  f2af50f4          ADR      r0,|L1.1044|
000a0a  f7fffffe          BL       assert_failed
                  |L1.2574|
;;;884      }  
;;;885      
;;;886      if ((USARTx->SR & USART_FLAG) != (uint16_t)RESET)
000a0e  8828              LDRH     r0,[r5,#0]
000a10  4220              TST      r0,r4
000a12  d000              BEQ      |L1.2582|
;;;887      {
;;;888        bitstatus = SET;
000a14  2601              MOVS     r6,#1
                  |L1.2582|
;;;889      }
;;;890      else
;;;891      {
;;;892        bitstatus = RESET;
;;;893      }
;;;894      return bitstatus;
000a16  4630              MOV      r0,r6
;;;895    }
000a18  e4d2              B        |L1.960|
;;;896    
                          ENDP

                  USART_ClearFlag PROC
;;;922      */
;;;923    void USART_ClearFlag(USART_TypeDef* USARTx, uint16_t USART_FLAG)
000a1a  e92d41f0          PUSH     {r4-r8,lr}
;;;924    {
;;;925      /* Check the parameters */
;;;926      assert_param(IS_USART_ALL_PERIPH(USARTx));
000a1e  4e6f              LDR      r6,|L1.3036|
000a20  4f6f              LDR      r7,|L1.3040|
000a22  f8df81c0          LDR      r8,|L1.3044|
000a26  460d              MOV      r5,r1                 ;924
000a28  4604              MOV      r4,r0                 ;924
000a2a  42b0              CMP      r0,r6
000a2c  d00f              BEQ      |L1.2638|
000a2e  42bc              CMP      r4,r7
000a30  d00d              BEQ      |L1.2638|
000a32  4544              CMP      r4,r8
000a34  d00b              BEQ      |L1.2638|
000a36  486c              LDR      r0,|L1.3048|
000a38  4284              CMP      r4,r0
000a3a  d008              BEQ      |L1.2638|
000a3c  486b              LDR      r0,|L1.3052|
000a3e  4284              CMP      r4,r0
000a40  d005              BEQ      |L1.2638|
000a42  f240319e          MOV      r1,#0x39e
000a46  f2af6034          ADR      r0,|L1.1044|
000a4a  f7fffffe          BL       assert_failed
                  |L1.2638|
;;;927      assert_param(IS_USART_CLEAR_FLAG(USART_FLAG));
000a4e  f4357058          BICS     r0,r5,#0x360
000a52  d100              BNE      |L1.2646|
000a54  b92d              CBNZ     r5,|L1.2658|
                  |L1.2646|
000a56  f240319f          MOV      r1,#0x39f
000a5a  f2af6048          ADR      r0,|L1.1044|
000a5e  f7fffffe          BL       assert_failed
                  |L1.2658|
;;;928      /* The CTS flag is not available for UART4 and UART5 */
;;;929      if ((USART_FLAG & USART_FLAG_CTS) == USART_FLAG_CTS)
000a62  05a8              LSLS     r0,r5,#22
000a64  d50b              BPL      |L1.2686|
;;;930      {
;;;931        assert_param(IS_USART_123_PERIPH(USARTx));
000a66  42b4              CMP      r4,r6
000a68  d009              BEQ      |L1.2686|
000a6a  42bc              CMP      r4,r7
000a6c  d007              BEQ      |L1.2686|
000a6e  4544              CMP      r4,r8
000a70  d005              BEQ      |L1.2686|
000a72  f24031a3          MOV      r1,#0x3a3
000a76  f2af6064          ADR      r0,|L1.1044|
000a7a  f7fffffe          BL       assert_failed
                  |L1.2686|
;;;932      } 
;;;933       
;;;934      USARTx->SR = (uint16_t)~USART_FLAG;
000a7e  43e8              MVNS     r0,r5
000a80  8020              STRH     r0,[r4,#0]
                  |L1.2690|
;;;935    }
000a82  e8bd81f0          POP      {r4-r8,pc}
;;;936    
                          ENDP

                  USART_GetITStatus PROC
;;;955      */
;;;956    ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT)
000a86  e92d47f0          PUSH     {r4-r10,lr}
;;;957    {
;;;958      uint32_t bitpos = 0x00, itmask = 0x00, usartreg = 0x00;
;;;959      ITStatus bitstatus = RESET;
;;;960      /* Check the parameters */
;;;961      assert_param(IS_USART_ALL_PERIPH(USARTx));
000a8a  4f54              LDR      r7,|L1.3036|
000a8c  2600              MOVS     r6,#0                 ;959
000a8e  f8df8150          LDR      r8,|L1.3040|
000a92  f8df9150          LDR      r9,|L1.3044|
000a96  460c              MOV      r4,r1                 ;957
000a98  4605              MOV      r5,r0                 ;957
000a9a  42b8              CMP      r0,r7
000a9c  d00f              BEQ      |L1.2750|
000a9e  4545              CMP      r5,r8
000aa0  d00d              BEQ      |L1.2750|
000aa2  454d              CMP      r5,r9
000aa4  d00b              BEQ      |L1.2750|
000aa6  4850              LDR      r0,|L1.3048|
000aa8  4285              CMP      r5,r0
000aaa  d008              BEQ      |L1.2750|
000aac  484f              LDR      r0,|L1.3052|
000aae  4285              CMP      r5,r0
000ab0  d005              BEQ      |L1.2750|
000ab2  f24031c1          MOV      r1,#0x3c1
000ab6  f2af60a4          ADR      r0,|L1.1044|
000aba  f7fffffe          BL       assert_failed
                  |L1.2750|
;;;962      assert_param(IS_USART_GET_IT(USART_IT));
000abe  f640106a          MOV      r0,#0x96a
000ac2  2c28              CMP      r4,#0x28
000ac4  d02d              BEQ      |L1.2850|
000ac6  f5a461e0          SUB      r1,r4,#0x700
000aca  3927              SUBS     r1,r1,#0x27
000acc  d029              BEQ      |L1.2850|
000ace  f5a461c0          SUB      r1,r4,#0x600
000ad2  3926              SUBS     r1,r1,#0x26
000ad4  d025              BEQ      |L1.2850|
000ad6  f5a461a0          SUB      r1,r4,#0x500
000ada  3925              SUBS     r1,r1,#0x25
000adc  d021              BEQ      |L1.2850|
000ade  f5a46180          SUB      r1,r4,#0x400
000ae2  3924              SUBS     r1,r1,#0x24
000ae4  d01d              BEQ      |L1.2850|
000ae6  f5a46100          SUB      r1,r4,#0x800
000aea  3946              SUBS     r1,r1,#0x46
000aec  d019              BEQ      |L1.2850|
000aee  4284              CMP      r4,r0
000af0  d00b              BEQ      |L1.2826|
000af2  f5b47f58          CMP      r4,#0x360
000af6  d014              BEQ      |L1.2850|
000af8  f5b47f18          CMP      r4,#0x260
000afc  d011              BEQ      |L1.2850|
000afe  f5b47fb0          CMP      r4,#0x160
000b02  d00e              BEQ      |L1.2850|
000b04  f24031c2          MOV      r1,#0x3c2
000b08  e007              B        |L1.2842|
                  |L1.2826|
;;;963      /* The CTS interrupt is not available for UART4 and UART5 */ 
;;;964      if (USART_IT == USART_IT_CTS)
;;;965      {
;;;966        assert_param(IS_USART_123_PERIPH(USARTx));
000b0a  42bd              CMP      r5,r7
000b0c  d009              BEQ      |L1.2850|
000b0e  4545              CMP      r5,r8
000b10  d007              BEQ      |L1.2850|
000b12  454d              CMP      r5,r9
000b14  d005              BEQ      |L1.2850|
000b16  f24031c6          MOV      r1,#0x3c6
                  |L1.2842|
000b1a  f2af7008          ADR      r0,|L1.1044|
000b1e  f7fffffe          BL       assert_failed
                  |L1.2850|
;;;967      }   
;;;968      
;;;969      /* Get the USART register index */
;;;970      usartreg = (((uint8_t)USART_IT) >> 0x05);
;;;971      /* Get the interrupt position */
;;;972      itmask = USART_IT & IT_Mask;
000b22  f004031f          AND      r3,r4,#0x1f
;;;973      itmask = (uint32_t)0x01 << itmask;
000b26  2201              MOVS     r2,#1
000b28  f3c41042          UBFX     r0,r4,#5,#3           ;970
000b2c  fa02f103          LSL      r1,r2,r3
;;;974      
;;;975      if (usartreg == 0x01) /* The IT  is in CR1 register */
000b30  2801              CMP      r0,#1
000b32  d00f              BEQ      |L1.2900|
;;;976      {
;;;977        itmask &= USARTx->CR1;
;;;978      }
;;;979      else if (usartreg == 0x02) /* The IT  is in CR2 register */
000b34  2802              CMP      r0,#2
000b36  d00f              BEQ      |L1.2904|
;;;980      {
;;;981        itmask &= USARTx->CR2;
;;;982      }
;;;983      else /* The IT  is in CR3 register */
;;;984      {
;;;985        itmask &= USARTx->CR3;
000b38  8aa8              LDRH     r0,[r5,#0x14]
                  |L1.2874|
000b3a  4208              TST      r0,r1                 ;981
;;;986      }
;;;987      
;;;988      bitpos = USART_IT >> 0x08;
000b3c  ea4f2114          LSR      r1,r4,#8
;;;989      bitpos = (uint32_t)0x01 << bitpos;
000b40  fa02f201          LSL      r2,r2,r1
;;;990      bitpos &= USARTx->SR;
000b44  8829              LDRH     r1,[r5,#0]
000b46  ea010102          AND      r1,r1,r2
000b4a  d001              BEQ      |L1.2896|
;;;991      if ((itmask != (uint16_t)RESET)&&(bitpos != (uint16_t)RESET))
000b4c  b101              CBZ      r1,|L1.2896|
;;;992      {
;;;993        bitstatus = SET;
000b4e  2601              MOVS     r6,#1
                  |L1.2896|
;;;994      }
;;;995      else
;;;996      {
;;;997        bitstatus = RESET;
;;;998      }
;;;999      
;;;1000     return bitstatus;  
000b50  4630              MOV      r0,r6
;;;1001   }
000b52  e435              B        |L1.960|
                  |L1.2900|
000b54  89a8              LDRH     r0,[r5,#0xc]          ;977
000b56  e7f0              B        |L1.2874|
                  |L1.2904|
000b58  8a28              LDRH     r0,[r5,#0x10]         ;981
000b5a  e7ee              B        |L1.2874|
;;;1002   
                          ENDP

                  USART_ClearITPendingBit PROC
;;;1029     */
;;;1030   void USART_ClearITPendingBit(USART_TypeDef* USARTx, uint16_t USART_IT)
000b5c  e92d41f0          PUSH     {r4-r8,lr}
;;;1031   {
;;;1032     uint16_t bitpos = 0x00, itmask = 0x00;
;;;1033     /* Check the parameters */
;;;1034     assert_param(IS_USART_ALL_PERIPH(USARTx));
000b60  4e1e              LDR      r6,|L1.3036|
000b62  4f1f              LDR      r7,|L1.3040|
000b64  f8df807c          LDR      r8,|L1.3044|
000b68  460d              MOV      r5,r1                 ;1031
000b6a  4604              MOV      r4,r0                 ;1031
000b6c  42b0              CMP      r0,r6
000b6e  d00f              BEQ      |L1.2960|
000b70  42bc              CMP      r4,r7
000b72  d00d              BEQ      |L1.2960|
000b74  4544              CMP      r4,r8
000b76  d00b              BEQ      |L1.2960|
000b78  481b              LDR      r0,|L1.3048|
000b7a  4284              CMP      r4,r0
000b7c  d008              BEQ      |L1.2960|
000b7e  481b              LDR      r0,|L1.3052|
000b80  4284              CMP      r4,r0
000b82  d005              BEQ      |L1.2960|
000b84  f240410a          MOV      r1,#0x40a
000b88  f2af7078          ADR      r0,|L1.1044|
000b8c  f7fffffe          BL       assert_failed
                  |L1.2960|
;;;1035     assert_param(IS_USART_CLEAR_IT(USART_IT));
000b90  f5a561c0          SUB      r1,r5,#0x600
000b94  f640106a          MOV      r0,#0x96a
000b98  3926              SUBS     r1,r1,#0x26
000b9a  d018              BEQ      |L1.3022|
000b9c  f5a561a0          SUB      r1,r5,#0x500
000ba0  3925              SUBS     r1,r1,#0x25
000ba2  d014              BEQ      |L1.3022|
000ba4  f5a56100          SUB      r1,r5,#0x800
000ba8  3946              SUBS     r1,r1,#0x46
000baa  d010              BEQ      |L1.3022|
000bac  4285              CMP      r5,r0
000bae  d002              BEQ      |L1.2998|
000bb0  f240410b          MOV      r1,#0x40b
000bb4  e007              B        |L1.3014|
                  |L1.2998|
;;;1036     /* The CTS interrupt is not available for UART4 and UART5 */
;;;1037     if (USART_IT == USART_IT_CTS)
;;;1038     {
;;;1039       assert_param(IS_USART_123_PERIPH(USARTx));
000bb6  42b4              CMP      r4,r6
000bb8  d009              BEQ      |L1.3022|
000bba  42bc              CMP      r4,r7
000bbc  d007              BEQ      |L1.3022|
000bbe  4544              CMP      r4,r8
000bc0  d005              BEQ      |L1.3022|
000bc2  f240410f          MOV      r1,#0x40f
                  |L1.3014|
000bc6  f2af70b4          ADR      r0,|L1.1044|
000bca  f7fffffe          BL       assert_failed
                  |L1.3022|
;;;1040     }   
;;;1041     
;;;1042     bitpos = USART_IT >> 0x08;
000bce  0a29              LSRS     r1,r5,#8
;;;1043     itmask = ((uint16_t)0x01 << (uint16_t)bitpos);
000bd0  2001              MOVS     r0,#1
000bd2  4088              LSLS     r0,r0,r1
;;;1044     USARTx->SR = (uint16_t)~itmask;
000bd4  43c0              MVNS     r0,r0
000bd6  8020              STRH     r0,[r4,#0]
;;;1045   }
000bd8  e753              B        |L1.2690|
;;;1046   /**
                          ENDP

000bda  0000              DCW      0x0000
                  |L1.3036|
                          DCD      0x40013800
                  |L1.3040|
                          DCD      0x40004400
                  |L1.3044|
                          DCD      0x40004800
                  |L1.3048|
                          DCD      0x40004c00
                  |L1.3052|
                          DCD      0x40005000
