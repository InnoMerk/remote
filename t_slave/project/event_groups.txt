; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o.\event_groups.o --asm_dir=.\ --list_dir=.\ --depend=.\event_groups.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\hooks -I..\lcd -I..\led -I..\load_cpu -I..\main -I..\printf -I..\limit_switch -I..\control_task -I..\mode_task -I..\lcdTask -I..\hit -I..\move_task -I..\project -I..\..\rtos -I..\..\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\STM32F10x_StdPeriph_Driver\inc -I..\..\STM32F10x_StdPeriph_Driver\src -I"C:\Program Files\keil\ARM\RV31\INC" -I"C:\Program Files\keil\ARM\PACK\ARM\CMSIS\3.20.4\CMSIS\Include" -I"C:\Program Files\keil\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include" -DSTM32F10X_MD_VL -DUSE_STDPERIPH_DRIVER --omf_browse=.\event_groups.crf ..\..\rtos\event_groups.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=1

                  xEventGroupCreate PROC
;;;133    
;;;134    EventGroupHandle_t xEventGroupCreate( void )
000000  b510              PUSH     {r4,lr}
;;;135    {
;;;136    EventGroup_t *pxEventBits;
;;;137    
;;;138    	pxEventBits = pvPortMalloc( sizeof( EventGroup_t ) );
000002  2018              MOVS     r0,#0x18
000004  f7fffffe          BL       pvPortMalloc
000008  0004              MOVS     r4,r0
;;;139    	if( pxEventBits != NULL )
00000a  d004              BEQ      |L1.22|
;;;140    	{
;;;141    		pxEventBits->uxEventBits = 0;
00000c  2000              MOVS     r0,#0
;;;142    		vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
00000e  6020              STR      r0,[r4,#0]
000010  1d20              ADDS     r0,r4,#4
000012  f7fffffe          BL       vListInitialise
                  |L1.22|
;;;143    		traceEVENT_GROUP_CREATE( pxEventBits );
;;;144    	}
;;;145    	else
;;;146    	{
;;;147    		traceEVENT_GROUP_CREATE_FAILED();
;;;148    	}
;;;149    
;;;150    	return ( EventGroupHandle_t ) pxEventBits;
000016  4620              MOV      r0,r4
;;;151    }
000018  bd10              POP      {r4,pc}
;;;152    /*-----------------------------------------------------------*/
                          ENDP

                  xEventGroupSetBits PROC
;;;473    
;;;474    EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
00001a  e92d41f0          PUSH     {r4-r8,lr}
;;;475    {
;;;476    ListItem_t *pxListItem, *pxNext;
;;;477    ListItem_t const *pxListEnd;
;;;478    List_t *pxList;
;;;479    EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
00001e  2700              MOVS     r7,#0
;;;480    EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
000020  4604              MOV      r4,r0
000022  4688              MOV      r8,r1                 ;475
;;;481    BaseType_t xMatchFound = pdFALSE;
;;;482    
;;;483    	/* Check the user is not attempting to set the bits used by the kernel
;;;484    	itself. */
;;;485    	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
000024  0e08              LSRS     r0,r1,#24
000026  d002              BEQ      |L1.46|
000028  f7fffffe          BL       ulPortSetInterruptMask
                  |L1.44|
00002c  e7fe              B        |L1.44|
                  |L1.46|
;;;486    
;;;487    	pxList = &( pxEventBits->xTasksWaitingForBits );
00002e  1d26              ADDS     r6,r4,#4
000030  f104050c          ADD      r5,r4,#0xc
;;;488    	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
;;;489    	vTaskSuspendAll();
000034  f7fffffe          BL       vTaskSuspendAll
;;;490    	{
;;;491    		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );
;;;492    
;;;493    		pxListItem = listGET_HEAD_ENTRY( pxList );
;;;494    
;;;495    		/* Set the bits. */
;;;496    		pxEventBits->uxEventBits |= uxBitsToSet;
000038  6821              LDR      r1,[r4,#0]
00003a  68f0              LDR      r0,[r6,#0xc]
00003c  ea410108          ORR      r1,r1,r8
;;;497    
;;;498    		/* See if the new bit value should unblock any tasks. */
;;;499    		while( pxListItem != pxListEnd )
000040  6021              STR      r1,[r4,#0]
000042  e017              B        |L1.116|
                  |L1.68|
000044  e9d01600          LDRD     r1,r6,[r0,#0]
;;;500    		{
;;;501    			pxNext = listGET_NEXT( pxListItem );
;;;502    			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
;;;503    			xMatchFound = pdFALSE;
;;;504    
;;;505    			/* Split the bits waited for from the control bits. */
;;;506    			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
000048  f001427f          AND      r2,r1,#0xff000000
;;;507    			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
;;;508    
;;;509    			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
00004c  0153              LSLS     r3,r2,#5
00004e  6823              LDR      r3,[r4,#0]
000050  f021417f          BIC      r1,r1,#0xff000000     ;507
000054  d402              BMI      |L1.92|
;;;510    			{
;;;511    				/* Just looking for single bit being set. */
;;;512    				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
000056  420b              TST      r3,r1
000058  d103              BNE      |L1.98|
00005a  e00a              B        |L1.114|
                  |L1.92|
;;;513    				{
;;;514    					xMatchFound = pdTRUE;
;;;515    				}
;;;516    				else
;;;517    				{
;;;518    					mtCOVERAGE_TEST_MARKER();
;;;519    				}
;;;520    			}
;;;521    			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
00005c  ea310303          BICS     r3,r1,r3
000060  d107              BNE      |L1.114|
                  |L1.98|
;;;522    			{
;;;523    				/* All bits are set. */
;;;524    				xMatchFound = pdTRUE;
;;;525    			}
;;;526    			else
;;;527    			{
;;;528    				/* Need all bits to be set, but not all the bits were set. */
;;;529    			}
;;;530    
;;;531    			if( xMatchFound != pdFALSE )
;;;532    			{
;;;533    				/* The bits match.  Should the bits be cleared on exit? */
;;;534    				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
000062  01d2              LSLS     r2,r2,#7
000064  d500              BPL      |L1.104|
;;;535    				{
;;;536    					uxBitsToClear |= uxBitsWaitedFor;
000066  430f              ORRS     r7,r7,r1
                  |L1.104|
;;;537    				}
;;;538    				else
;;;539    				{
;;;540    					mtCOVERAGE_TEST_MARKER();
;;;541    				}
;;;542    
;;;543    				/* Store the actual event flag value in the task's event list
;;;544    				item before removing the task from the event list.  The
;;;545    				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
;;;546    				that is was unblocked due to its required bits matching, rather
;;;547    				than because it timed out. */
;;;548    				( void ) xTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
000068  6821              LDR      r1,[r4,#0]
00006a  f0417100          ORR      r1,r1,#0x2000000
00006e  f7fffffe          BL       xTaskRemoveFromUnorderedEventList
                  |L1.114|
;;;549    			}
;;;550    
;;;551    			/* Move onto the next list item.  Note pxListItem->pxNext is not
;;;552    			used here as the list item may have been removed from the event list
;;;553    			and inserted into the ready/pending reading list. */
;;;554    			pxListItem = pxNext;
000072  4630              MOV      r0,r6
                  |L1.116|
000074  42a8              CMP      r0,r5                 ;499
000076  d1e5              BNE      |L1.68|
;;;555    		}
;;;556    
;;;557    		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
;;;558    		bit was set in the control word. */
;;;559    		pxEventBits->uxEventBits &= ~uxBitsToClear;
000078  6820              LDR      r0,[r4,#0]
00007a  43b8              BICS     r0,r0,r7
;;;560    	}
;;;561    	( void ) xTaskResumeAll();
00007c  6020              STR      r0,[r4,#0]
00007e  f7fffffe          BL       xTaskResumeAll
;;;562    
;;;563    	return pxEventBits->uxEventBits;
000082  6820              LDR      r0,[r4,#0]
                  |L1.132|
;;;564    }
000084  e8bd81f0          POP      {r4-r8,pc}
;;;565    /*-----------------------------------------------------------*/
                          ENDP

                  xEventGroupSync PROC
;;;153    
;;;154    EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
000088  e92d41f0          PUSH     {r4-r8,lr}
;;;155    {
00008c  4604              MOV      r4,r0
00008e  461f              MOV      r7,r3
000090  4615              MOV      r5,r2
000092  4688              MOV      r8,r1
;;;156    EventBits_t uxOriginalBitValue, uxReturn;
;;;157    EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
;;;158    BaseType_t xAlreadyYielded;
;;;159    BaseType_t xTimeoutOccurred = pdFALSE;
;;;160    
;;;161    	configASSERT( ( uxBitsToWaitFor & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
000094  0e10              LSRS     r0,r2,#24
000096  d002              BEQ      |L1.158|
000098  f7fffffe          BL       ulPortSetInterruptMask
                  |L1.156|
00009c  e7fe              B        |L1.156|
                  |L1.158|
;;;162    	configASSERT( uxBitsToWaitFor != 0 );
00009e  b11d              CBZ      r5,|L1.168|
;;;163    	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
;;;164    	{
;;;165    		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
0000a0  f7fffffe          BL       xTaskGetSchedulerState
0000a4  b118              CBZ      r0,|L1.174|
0000a6  e006              B        |L1.182|
                  |L1.168|
0000a8  f7fffffe          BL       ulPortSetInterruptMask
                  |L1.172|
0000ac  e7fe              B        |L1.172|
                  |L1.174|
0000ae  b117              CBZ      r7,|L1.182|
0000b0  f7fffffe          BL       ulPortSetInterruptMask
                  |L1.180|
0000b4  e7fe              B        |L1.180|
                  |L1.182|
;;;166    	}
;;;167    	#endif
;;;168    
;;;169    	vTaskSuspendAll();
0000b6  f7fffffe          BL       vTaskSuspendAll
;;;170    	{
;;;171    		uxOriginalBitValue = pxEventBits->uxEventBits;
0000ba  4620              MOV      r0,r4
;;;172    
;;;173    		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
0000bc  4641              MOV      r1,r8
0000be  6826              LDR      r6,[r4,#0]
0000c0  f7fffffe          BL       xEventGroupSetBits
;;;174    
;;;175    		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
0000c4  ea460608          ORR      r6,r6,r8
0000c8  ea350006          BICS     r0,r5,r6
0000cc  d008              BEQ      |L1.224|
;;;176    		{
;;;177    			/* All the rendezvous bits are now set - no need to block. */
;;;178    			uxReturn = ( uxOriginalBitValue | uxBitsToSet );
;;;179    
;;;180    			/* Rendezvous always clear the bits.  They will have been cleared
;;;181    			already unless this is the only task in the rendezvous. */
;;;182    			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
;;;183    
;;;184    			xTicksToWait = 0;
;;;185    		}
;;;186    		else
;;;187    		{
;;;188    			if( xTicksToWait != ( TickType_t ) 0 )
0000ce  b16f              CBZ      r7,|L1.236|
;;;189    			{
;;;190    				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );
;;;191    
;;;192    				/* Store the bits that the calling task is waiting for in the
;;;193    				task's event list item so the kernel knows when a match is
;;;194    				found.  Then enter the blocked state. */
;;;195    				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
0000d0  f04561a0          ORR      r1,r5,#0x5000000
0000d4  463a              MOV      r2,r7
0000d6  1d20              ADDS     r0,r4,#4
0000d8  f7fffffe          BL       vTaskPlaceOnUnorderedEventList
;;;196    
;;;197    				/* This assignment is obsolete as uxReturn will get set after
;;;198    				the task unblocks, but some compilers mistakenly generate a
;;;199    				warning about uxReturn being returned without being set if the
;;;200    				assignment is omitted. */
;;;201    				uxReturn = 0;
0000dc  2600              MOVS     r6,#0
0000de  e006              B        |L1.238|
                  |L1.224|
0000e0  6820              LDR      r0,[r4,#0]            ;182
0000e2  43a8              BICS     r0,r0,r5              ;182
;;;202    			}
;;;203    			else
;;;204    			{
;;;205    				/* The rendezvous bits were not set, but no block time was
;;;206    				specified - just return the current event bit value. */
;;;207    				uxReturn = pxEventBits->uxEventBits;
;;;208    			}
;;;209    		}
;;;210    	}
;;;211    	xAlreadyYielded = xTaskResumeAll();
0000e4  6020              STR      r0,[r4,#0]
0000e6  f7fffffe          BL       xTaskResumeAll
0000ea  e018              B        |L1.286|
                  |L1.236|
0000ec  6826              LDR      r6,[r4,#0]            ;207
                  |L1.238|
0000ee  f7fffffe          BL       xTaskResumeAll
;;;212    
;;;213    	if( xTicksToWait != ( TickType_t ) 0 )
0000f2  b1a7              CBZ      r7,|L1.286|
;;;214    	{
;;;215    		if( xAlreadyYielded == pdFALSE )
0000f4  b908              CBNZ     r0,|L1.250|
;;;216    		{
;;;217    			portYIELD_WITHIN_API();
0000f6  f7fffffe          BL       vPortYield
                  |L1.250|
;;;218    		}
;;;219    		else
;;;220    		{
;;;221    			mtCOVERAGE_TEST_MARKER();
;;;222    		}
;;;223    
;;;224    		/* The task blocked to wait for its required bits to be set - at this
;;;225    		point either the required bits were set or the block time expired.  If
;;;226    		the required bits were set they will have been stored in the task's
;;;227    		event list item, and they should now be retrieved then cleared. */
;;;228    		uxReturn = uxTaskResetEventItemValue();
0000fa  f7fffffe          BL       uxTaskResetEventItemValue
0000fe  4606              MOV      r6,r0
;;;229    
;;;230    		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
000100  0180              LSLS     r0,r0,#6
000102  d40a              BMI      |L1.282|
;;;231    		{
;;;232    			/* The task timed out, just return the current event bit value. */
;;;233    			taskENTER_CRITICAL();
000104  f7fffffe          BL       vPortEnterCritical
;;;234    			{
;;;235    				uxReturn = pxEventBits->uxEventBits;
;;;236    
;;;237    				/* Although the task got here because it timed out before the
;;;238    				bits it was waiting for were set, it is possible that since it
;;;239    				unblocked another task has set the bits.  If this is the case
;;;240    				then it needs to clear the bits before exiting. */
;;;241    				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
000108  6826              LDR      r6,[r4,#0]
00010a  ea350006          BICS     r0,r5,r6
00010e  d102              BNE      |L1.278|
;;;242    				{
;;;243    					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
000110  ea260005          BIC      r0,r6,r5
000114  6020              STR      r0,[r4,#0]
                  |L1.278|
;;;244    				}
;;;245    				else
;;;246    				{
;;;247    					mtCOVERAGE_TEST_MARKER();
;;;248    				}
;;;249    			}
;;;250    			taskEXIT_CRITICAL();
000116  f7fffffe          BL       vPortExitCritical
                  |L1.282|
;;;251    
;;;252    			xTimeoutOccurred = pdTRUE;
;;;253    		}
;;;254    		else
;;;255    		{
;;;256    			/* The task unblocked because the bits were set. */
;;;257    		}
;;;258    
;;;259    		/* Control bits might be set as the task had blocked should not be
;;;260    		returned. */
;;;261    		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
00011a  f026467f          BIC      r6,r6,#0xff000000
                  |L1.286|
;;;262    	}
;;;263    
;;;264    	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );
;;;265    
;;;266    	return uxReturn;
00011e  4630              MOV      r0,r6
;;;267    }
000120  e7b0              B        |L1.132|
;;;268    /*-----------------------------------------------------------*/
                          ENDP

                  xEventGroupWaitBits PROC
;;;269    
;;;270    EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
000122  e92d47f0          PUSH     {r4-r10,lr}
;;;271    {
;;;272    EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
000126  4604              MOV      r4,r0
;;;273    EventBits_t uxReturn, uxControlBits = 0;
000128  2700              MOVS     r7,#0
;;;274    BaseType_t xWaitConditionMet, xAlreadyYielded;
;;;275    BaseType_t xTimeoutOccurred = pdFALSE;
;;;276    
;;;277    	/* Check the user is not attempting to wait on the bits used by the kernel
;;;278    	itself, and that at least one bit is being requested. */
;;;279    	configASSERT( ( uxBitsToWaitFor & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
00012a  f8dd9020          LDR      r9,[sp,#0x20]
00012e  469a              MOV      r10,r3                ;271
000130  4690              MOV      r8,r2                 ;271
000132  460d              MOV      r5,r1                 ;271
000134  0e08              LSRS     r0,r1,#24
000136  d002              BEQ      |L1.318|
000138  f7fffffe          BL       ulPortSetInterruptMask
                  |L1.316|
00013c  e7fe              B        |L1.316|
                  |L1.318|
;;;280    	configASSERT( uxBitsToWaitFor != 0 );
00013e  b11d              CBZ      r5,|L1.328|
;;;281    	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
;;;282    	{
;;;283    		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
000140  f7fffffe          BL       xTaskGetSchedulerState
000144  b118              CBZ      r0,|L1.334|
000146  e008              B        |L1.346|
                  |L1.328|
000148  f7fffffe          BL       ulPortSetInterruptMask
                  |L1.332|
00014c  e7fe              B        |L1.332|
                  |L1.334|
00014e  f1b90f00          CMP      r9,#0
000152  d002              BEQ      |L1.346|
000154  f7fffffe          BL       ulPortSetInterruptMask
                  |L1.344|
000158  e7fe              B        |L1.344|
                  |L1.346|
;;;284    	}
;;;285    	#endif
;;;286    
;;;287    	vTaskSuspendAll();
00015a  f7fffffe          BL       vTaskSuspendAll
;;;288    	{
;;;289    		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
;;;290    
;;;291    		/* Check to see if the wait condition is already met or not. */
;;;292    		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
00015e  6826              LDR      r6,[r4,#0]
000160  4652              MOV      r2,r10
000162  4629              MOV      r1,r5
000164  4630              MOV      r0,r6
000166  f7fffffe          BL       prvTestWaitCondition
;;;293    
;;;294    		if( xWaitConditionMet != pdFALSE )
00016a  b130              CBZ      r0,|L1.378|
;;;295    		{
;;;296    			/* The wait condition has already been met so there is no need to
;;;297    			block. */
;;;298    			uxReturn = uxCurrentEventBits;
;;;299    			xTicksToWait = ( TickType_t ) 0;
;;;300    
;;;301    			/* Clear the wait bits if requested to do so. */
;;;302    			if( xClearOnExit != pdFALSE )
00016c  f1b80f00          CMP      r8,#0
000170  d01a              BEQ      |L1.424|
;;;303    			{
;;;304    				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
000172  6820              LDR      r0,[r4,#0]
000174  43a8              BICS     r0,r0,r5
000176  6020              STR      r0,[r4,#0]
000178  e016              B        |L1.424|
                  |L1.378|
;;;305    			}
;;;306    			else
;;;307    			{
;;;308    				mtCOVERAGE_TEST_MARKER();
;;;309    			}
;;;310    		}
;;;311    		else if( xTicksToWait == ( TickType_t ) 0 )
00017a  f1b90f00          CMP      r9,#0
00017e  d013              BEQ      |L1.424|
;;;312    		{
;;;313    			/* The wait condition has not been met, but no block time was
;;;314    			specified, so just return the current value. */
;;;315    			uxReturn = uxCurrentEventBits;
;;;316    		}
;;;317    		else
;;;318    		{
;;;319    			/* The task is going to block to wait for its required bits to be
;;;320    			set.  uxControlBits are used to remember the specified behaviour of
;;;321    			this call to xEventGroupWaitBits() - for use when the event bits
;;;322    			unblock the task. */
;;;323    			if( xClearOnExit != pdFALSE )
000180  f1b80f00          CMP      r8,#0
000184  d001              BEQ      |L1.394|
;;;324    			{
;;;325    				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
000186  f04f7780          MOV      r7,#0x1000000
                  |L1.394|
;;;326    			}
;;;327    			else
;;;328    			{
;;;329    				mtCOVERAGE_TEST_MARKER();
;;;330    			}
;;;331    
;;;332    			if( xWaitForAllBits != pdFALSE )
00018a  f1ba0f00          CMP      r10,#0
00018e  d001              BEQ      |L1.404|
;;;333    			{
;;;334    				uxControlBits |= eventWAIT_FOR_ALL_BITS;
000190  f0476780          ORR      r7,r7,#0x4000000
                  |L1.404|
;;;335    			}
;;;336    			else
;;;337    			{
;;;338    				mtCOVERAGE_TEST_MARKER();
;;;339    			}
;;;340    
;;;341    			/* Store the bits that the calling task is waiting for in the
;;;342    			task's event list item so the kernel knows when a match is
;;;343    			found.  Then enter the blocked state. */
;;;344    			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
000194  ea450107          ORR      r1,r5,r7
000198  464a              MOV      r2,r9
00019a  1d20              ADDS     r0,r4,#4
00019c  f7fffffe          BL       vTaskPlaceOnUnorderedEventList
;;;345    
;;;346    			/* This is obsolete as it will get set after the task unblocks, but
;;;347    			some compilers mistakenly generate a warning about the variable
;;;348    			being returned without being set if it is not done. */
;;;349    			uxReturn = 0;
;;;350    
;;;351    			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
;;;352    		}
;;;353    	}
;;;354    	xAlreadyYielded = xTaskResumeAll();
0001a0  f7fffffe          BL       xTaskResumeAll
0001a4  b118              CBZ      r0,|L1.430|
0001a6  e004              B        |L1.434|
                  |L1.424|
0001a8  f7fffffe          BL       xTaskResumeAll
0001ac  e019              B        |L1.482|
                  |L1.430|
;;;355    
;;;356    	if( xTicksToWait != ( TickType_t ) 0 )
;;;357    	{
;;;358    		if( xAlreadyYielded == pdFALSE )
;;;359    		{
;;;360    			portYIELD_WITHIN_API();
0001ae  f7fffffe          BL       vPortYield
                  |L1.434|
;;;361    		}
;;;362    		else
;;;363    		{
;;;364    			mtCOVERAGE_TEST_MARKER();
;;;365    		}
;;;366    
;;;367    		/* The task blocked to wait for its required bits to be set - at this
;;;368    		point either the required bits were set or the block time expired.  If
;;;369    		the required bits were set they will have been stored in the task's
;;;370    		event list item, and they should now be retrieved then cleared. */
;;;371    		uxReturn = uxTaskResetEventItemValue();
0001b2  f7fffffe          BL       uxTaskResetEventItemValue
0001b6  4606              MOV      r6,r0
;;;372    
;;;373    		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
0001b8  0180              LSLS     r0,r0,#6
0001ba  d410              BMI      |L1.478|
;;;374    		{
;;;375    			taskENTER_CRITICAL();
0001bc  f7fffffe          BL       vPortEnterCritical
;;;376    			{
;;;377    				/* The task timed out, just return the current event bit value. */
;;;378    				uxReturn = pxEventBits->uxEventBits;
;;;379    
;;;380    				/* It is possible that the event bits were updated between this
;;;381    				task leaving the Blocked state and running again. */
;;;382    				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
0001c0  6826              LDR      r6,[r4,#0]
0001c2  4652              MOV      r2,r10
0001c4  4629              MOV      r1,r5
0001c6  4630              MOV      r0,r6
0001c8  f7fffffe          BL       prvTestWaitCondition
0001cc  b128              CBZ      r0,|L1.474|
;;;383    				{
;;;384    					if( xClearOnExit != pdFALSE )
0001ce  f1b80f00          CMP      r8,#0
0001d2  d002              BEQ      |L1.474|
;;;385    					{
;;;386    						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
0001d4  6820              LDR      r0,[r4,#0]
0001d6  43a8              BICS     r0,r0,r5
0001d8  6020              STR      r0,[r4,#0]
                  |L1.474|
;;;387    					}
;;;388    					else
;;;389    					{
;;;390    						mtCOVERAGE_TEST_MARKER();
;;;391    					}
;;;392    				}
;;;393    				else
;;;394    				{
;;;395    					mtCOVERAGE_TEST_MARKER();
;;;396    				}
;;;397    			}
;;;398    			taskEXIT_CRITICAL();
0001da  f7fffffe          BL       vPortExitCritical
                  |L1.478|
;;;399    
;;;400    			/* Prevent compiler warnings when trace macros are not used. */
;;;401    			xTimeoutOccurred = pdFALSE;
;;;402    		}
;;;403    		else
;;;404    		{
;;;405    			/* The task unblocked because the bits were set. */
;;;406    		}
;;;407    
;;;408    		/* The task blocked so control bits may have been set. */
;;;409    		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
0001de  f026467f          BIC      r6,r6,#0xff000000
                  |L1.482|
;;;410    	}
;;;411    	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );
;;;412    
;;;413    	return uxReturn;
0001e2  4630              MOV      r0,r6
;;;414    }
0001e4  e8bd87f0          POP      {r4-r10,pc}
;;;415    /*-----------------------------------------------------------*/
                          ENDP

                  xEventGroupClearBits PROC
;;;416    
;;;417    EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
0001e8  b570              PUSH     {r4-r6,lr}
;;;418    {
;;;419    EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
0001ea  4604              MOV      r4,r0
0001ec  460e              MOV      r6,r1                 ;418
;;;420    EventBits_t uxReturn;
;;;421    
;;;422    	/* Check the user is not attempting to clear the bits used by the kernel
;;;423    	itself. */
;;;424    	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
0001ee  0e08              LSRS     r0,r1,#24
0001f0  d002              BEQ      |L1.504|
0001f2  f7fffffe          BL       ulPortSetInterruptMask
                  |L1.502|
0001f6  e7fe              B        |L1.502|
                  |L1.504|
;;;425    
;;;426    	taskENTER_CRITICAL();
0001f8  f7fffffe          BL       vPortEnterCritical
;;;427    	{
;;;428    		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );
;;;429    
;;;430    		/* The value returned is the event group value prior to the bits being
;;;431    		cleared. */
;;;432    		uxReturn = pxEventBits->uxEventBits;
;;;433    
;;;434    		/* Clear the bits. */
;;;435    		pxEventBits->uxEventBits &= ~uxBitsToClear;
0001fc  6825              LDR      r5,[r4,#0]
0001fe  ea250006          BIC      r0,r5,r6
;;;436    	}
;;;437    	taskEXIT_CRITICAL();
000202  6020              STR      r0,[r4,#0]
000204  f7fffffe          BL       vPortExitCritical
;;;438    
;;;439    	return uxReturn;
000208  4628              MOV      r0,r5
;;;440    }
00020a  bd70              POP      {r4-r6,pc}
;;;441    /*-----------------------------------------------------------*/
                          ENDP

                  xEventGroupGetBitsFromISR PROC
;;;457    
;;;458    EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
00020c  b510              PUSH     {r4,lr}
;;;459    {
;;;460    UBaseType_t uxSavedInterruptStatus;
;;;461    EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
00020e  4604              MOV      r4,r0
;;;462    EventBits_t uxReturn;
;;;463    
;;;464    	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
000210  f7fffffe          BL       ulPortSetInterruptMask
;;;465    	{
;;;466    		uxReturn = pxEventBits->uxEventBits;
000214  6824              LDR      r4,[r4,#0]
;;;467    	}
;;;468    	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
000216  f7fffffe          BL       vPortClearInterruptMask
;;;469    
;;;470    	return uxReturn;
00021a  4620              MOV      r0,r4
;;;471    }
00021c  bd10              POP      {r4,pc}
;;;472    /*-----------------------------------------------------------*/
                          ENDP

                  vEventGroupDelete PROC
;;;566    
;;;567    void vEventGroupDelete( EventGroupHandle_t xEventGroup )
00021e  e92d41f0          PUSH     {r4-r8,lr}
;;;568    {
;;;569    EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
000222  4605              MOV      r5,r0
;;;570    const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
000224  1d04              ADDS     r4,r0,#4
;;;571    
;;;572    	vTaskSuspendAll();
000226  f7fffffe          BL       vTaskSuspendAll
;;;573    	{
;;;574    		traceEVENT_GROUP_DELETE( xEventGroup );
;;;575    
;;;576    		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
;;;577    		{
;;;578    			/* Unblock the task, returning 0 as the event list is being deleted
;;;579    			and	cannot therefore have any bits set. */
;;;580    			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
00022a  f1040608          ADD      r6,r4,#8
;;;581    			( void ) xTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
00022e  f04f7700          MOV      r7,#0x2000000
000232  e008              B        |L1.582|
                  |L1.564|
000234  68e0              LDR      r0,[r4,#0xc]          ;580
000236  42b0              CMP      r0,r6                 ;580
000238  d102              BNE      |L1.576|
00023a  f7fffffe          BL       ulPortSetInterruptMask
                  |L1.574|
00023e  e7fe              B        |L1.574|
                  |L1.576|
000240  4639              MOV      r1,r7
000242  f7fffffe          BL       xTaskRemoveFromUnorderedEventList
                  |L1.582|
000246  6820              LDR      r0,[r4,#0]            ;576
000248  2800              CMP      r0,#0                 ;576
00024a  d1f3              BNE      |L1.564|
;;;582    		}
;;;583    
;;;584    		vPortFree( pxEventBits );
00024c  4628              MOV      r0,r5
00024e  f7fffffe          BL       vPortFree
;;;585    	}
;;;586    	( void ) xTaskResumeAll();
000252  e8bd41f0          POP      {r4-r8,lr}
000256  f7ffbffe          B.W      xTaskResumeAll
;;;587    }
;;;588    /*-----------------------------------------------------------*/
                          ENDP

                  vEventGroupSetBitsCallback PROC
;;;591    an interrupt. */
;;;592    void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
00025a  e7fe              B        xEventGroupSetBits
;;;593    {
;;;594    	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet );
;;;595    }
;;;596    /*-----------------------------------------------------------*/
                          ENDP

                  vEventGroupClearBitsCallback PROC
;;;599    an interrupt. */
;;;600    void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
00025c  e7fe              B        xEventGroupClearBits
;;;601    {
;;;602    	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear );
;;;603    }
;;;604    /*-----------------------------------------------------------*/
                          ENDP

                  prvTestWaitCondition PROC
;;;605    
;;;606    static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
00025e  4603              MOV      r3,r0
;;;607    {
;;;608    BaseType_t xWaitConditionMet = pdFALSE;
000260  2000              MOVS     r0,#0
000262  b112              CBZ      r2,|L1.618|
;;;609    
;;;610    	if( xWaitForAllBits == pdFALSE )
;;;611    	{
;;;612    		/* Task only has to wait for one bit within uxBitsToWaitFor to be
;;;613    		set.  Is one already set? */
;;;614    		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
;;;615    		{
;;;616    			xWaitConditionMet = pdTRUE;
;;;617    		}
;;;618    		else
;;;619    		{
;;;620    			mtCOVERAGE_TEST_MARKER();
;;;621    		}
;;;622    	}
;;;623    	else
;;;624    	{
;;;625    		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
;;;626    		Are they set already? */
;;;627    		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
000264  4399              BICS     r1,r1,r3
000266  d002              BEQ      |L1.622|
                  |L1.616|
;;;628    		{
;;;629    			xWaitConditionMet = pdTRUE;
;;;630    		}
;;;631    		else
;;;632    		{
;;;633    			mtCOVERAGE_TEST_MARKER();
;;;634    		}
;;;635    	}
;;;636    
;;;637    	return xWaitConditionMet;
;;;638    }
000268  4770              BX       lr
                  |L1.618|
00026a  420b              TST      r3,r1                 ;614
00026c  d0fc              BEQ      |L1.616|
                  |L1.622|
00026e  2001              MOVS     r0,#1                 ;616
000270  4770              BX       lr
;;;639    /*-----------------------------------------------------------*/
                          ENDP

