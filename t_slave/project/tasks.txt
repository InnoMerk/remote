; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o.\tasks.o --asm_dir=.\ --list_dir=.\ --depend=.\tasks.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\hooks -I..\lcd -I..\led -I..\load_cpu -I..\main -I..\printf -I..\limit_switch -I..\control_task -I..\mode_task -I..\lcdTask -I..\hit -I..\move_task -I..\project -I..\..\rtos -I..\..\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\STM32F10x_StdPeriph_Driver\inc -I..\..\STM32F10x_StdPeriph_Driver\src -I"C:\Program Files\keil\ARM\RV31\INC" -I"C:\Program Files\keil\ARM\PACK\ARM\CMSIS\3.20.4\CMSIS\Include" -I"C:\Program Files\keil\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include" -DSTM32F10X_MD_VL -DUSE_STDPERIPH_DRIVER --omf_browse=.\tasks.crf ..\..\rtos\tasks.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  xTaskGenericCreate PROC
;;;515    
;;;516    BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;517    {
000004  4615              MOV      r5,r2
000006  e9dd680e          LDRD     r6,r8,[sp,#0x38]
00000a  9f10              LDR      r7,[sp,#0x40]
00000c  468a              MOV      r10,r1
00000e  ea5f0b00          MOVS     r11,r0
000012  d004              BEQ      |L1.30|
;;;518    BaseType_t xReturn;
;;;519    TCB_t * pxNewTCB;
;;;520    
;;;521    	configASSERT( pxTaskCode );
;;;522    	configASSERT( ( ( uxPriority & ( ~portPRIVILEGE_BIT ) ) < configMAX_PRIORITIES ) );
000014  2e05              CMP      r6,#5
000016  d305              BCC      |L1.36|
000018  f7fffffe          BL       ulPortSetInterruptMask
                  |L1.28|
00001c  e7fe              B        |L1.28|
                  |L1.30|
00001e  f7fffffe          BL       ulPortSetInterruptMask
                  |L1.34|
000022  e7fe              B        |L1.34|
                  |L1.36|
000024  2048              MOVS     r0,#0x48              ;521
000026  f7fffffe          BL       pvPortMalloc
00002a  0004              MOVS     r4,r0                 ;521
00002c  d01c              BEQ      |L1.104|
00002e  00a8              LSLS     r0,r5,#2              ;521
000030  4681              MOV      r9,r0                 ;521
000032  b19f              CBZ      r7,|L1.92|
000034  4638              MOV      r0,r7                 ;521
                  |L1.54|
000036  6320              STR      r0,[r4,#0x30]         ;521
000038  b198              CBZ      r0,|L1.98|
00003a  22a5              MOVS     r2,#0xa5              ;521
00003c  4649              MOV      r1,r9                 ;521
00003e  f7fffffe          BL       __aeabi_memset
;;;523    
;;;524    	/* Allocate the memory required by the TCB and stack for the new task,
;;;525    	checking that the allocation was successful. */
;;;526    	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
;;;527    
;;;528    	if( pxNewTCB != NULL )
;;;529    	{
;;;530    		StackType_t *pxTopOfStack;
;;;531    
;;;532    		#if( portUSING_MPU_WRAPPERS == 1 )
;;;533    			/* Should the task be created in privileged mode? */
;;;534    			BaseType_t xRunPrivileged;
;;;535    			if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
;;;536    			{
;;;537    				xRunPrivileged = pdTRUE;
;;;538    			}
;;;539    			else
;;;540    			{
;;;541    				xRunPrivileged = pdFALSE;
;;;542    			}
;;;543    			uxPriority &= ~portPRIVILEGE_BIT;
;;;544    		#endif /* portUSING_MPU_WRAPPERS == 1 */
;;;545    
;;;546    		/* Calculate the top of stack address.  This depends on whether the
;;;547    		stack grows from high memory to low (as per the 80x86) or vice versa.
;;;548    		portSTACK_GROWTH is used to make the result positive or negative as
;;;549    		required by the port. */
;;;550    		#if( portSTACK_GROWTH < 0 )
;;;551    		{
;;;552    			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
000042  f06f0103          MVN      r1,#3
000046  6b20              LDR      r0,[r4,#0x30]
000048  eb010185          ADD      r1,r1,r5,LSL #2
00004c  4408              ADD      r0,r0,r1
;;;553    			pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK  ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
00004e  f0200707          BIC      r7,r0,#7
;;;554    
;;;555    			/* Check the alignment of the calculated top of stack is correct. */
;;;556    			configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
000052  0778              LSLS     r0,r7,#29
000054  d00b              BEQ      |L1.110|
000056  f7fffffe          BL       ulPortSetInterruptMask
                  |L1.90|
00005a  e7fe              B        |L1.90|
                  |L1.92|
00005c  f7fffffe          BL       pvPortMalloc
000060  e7e9              B        |L1.54|
                  |L1.98|
000062  4620              MOV      r0,r4
000064  f7fffffe          BL       vPortFree
                  |L1.104|
;;;557    		}
;;;558    		#else /* portSTACK_GROWTH */
;;;559    		{
;;;560    			pxTopOfStack = pxNewTCB->pxStack;
;;;561    
;;;562    			/* Check the alignment of the stack buffer is correct. */
;;;563    			configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxNewTCB->pxStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
;;;564    
;;;565    			/* If we want to use stack checking on architectures that use
;;;566    			a positive stack growth direction then we also need to store the
;;;567    			other extreme of the stack space. */
;;;568    			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
;;;569    		}
;;;570    		#endif /* portSTACK_GROWTH */
;;;571    
;;;572    		/* Setup the newly allocated TCB with the initial state of the task. */
;;;573    		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
;;;574    
;;;575    		/* Initialize the TCB stack to look as if the task was already running,
;;;576    		but had been interrupted by the scheduler.  The return address is set
;;;577    		to the start of the task function. Once the stack has been initialised
;;;578    		the	top of stack variable is updated. */
;;;579    		#if( portUSING_MPU_WRAPPERS == 1 )
;;;580    		{
;;;581    			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
;;;582    		}
;;;583    		#else /* portUSING_MPU_WRAPPERS */
;;;584    		{
;;;585    			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
;;;586    		}
;;;587    		#endif /* portUSING_MPU_WRAPPERS */
;;;588    
;;;589    		if( ( void * ) pxCreatedTask != NULL )
;;;590    		{
;;;591    			/* Pass the TCB out - in an anonymous way.  The calling function/
;;;592    			task can use this as a handle to delete the task later if
;;;593    			required.*/
;;;594    			*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
;;;595    		}
;;;596    		else
;;;597    		{
;;;598    			mtCOVERAGE_TEST_MARKER();
;;;599    		}
;;;600    
;;;601    		/* Ensure interrupts don't access the task lists while they are being
;;;602    		updated. */
;;;603    		taskENTER_CRITICAL();
;;;604    		{
;;;605    			uxCurrentNumberOfTasks++;
;;;606    			if( pxCurrentTCB == NULL )
;;;607    			{
;;;608    				/* There are no other tasks, or all the other tasks are in
;;;609    				the suspended state - make this the current task. */
;;;610    				pxCurrentTCB =  pxNewTCB;
;;;611    
;;;612    				if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
;;;613    				{
;;;614    					/* This is the first task to be created so do the preliminary
;;;615    					initialisation required.  We will not recover if this call
;;;616    					fails, but we will report the failure. */
;;;617    					prvInitialiseTaskLists();
;;;618    				}
;;;619    				else
;;;620    				{
;;;621    					mtCOVERAGE_TEST_MARKER();
;;;622    				}
;;;623    			}
;;;624    			else
;;;625    			{
;;;626    				/* If the scheduler is not already running, make this task the
;;;627    				current task if it is the highest priority task to be created
;;;628    				so far. */
;;;629    				if( xSchedulerRunning == pdFALSE )
;;;630    				{
;;;631    					if( pxCurrentTCB->uxPriority <= uxPriority )
;;;632    					{
;;;633    						pxCurrentTCB = pxNewTCB;
;;;634    					}
;;;635    					else
;;;636    					{
;;;637    						mtCOVERAGE_TEST_MARKER();
;;;638    					}
;;;639    				}
;;;640    				else
;;;641    				{
;;;642    					mtCOVERAGE_TEST_MARKER();
;;;643    				}
;;;644    			}
;;;645    
;;;646    			uxTaskNumber++;
;;;647    
;;;648    			#if ( configUSE_TRACE_FACILITY == 1 )
;;;649    			{
;;;650    				/* Add a counter into the TCB for tracing only. */
;;;651    				pxNewTCB->uxTCBNumber = uxTaskNumber;
;;;652    			}
;;;653    			#endif /* configUSE_TRACE_FACILITY */
;;;654    			traceTASK_CREATE( pxNewTCB );
;;;655    
;;;656    			prvAddTaskToReadyList( pxNewTCB );
;;;657    
;;;658    			xReturn = pdPASS;
;;;659    			portSETUP_TCB( pxNewTCB );
;;;660    		}
;;;661    		taskEXIT_CRITICAL();
;;;662    	}
;;;663    	else
;;;664    	{
;;;665    		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
000068  f04f34ff          MOV      r4,#0xffffffff
00006c  e081              B        |L1.370|
                  |L1.110|
00006e  4651              MOV      r1,r10                ;573
000070  4635              MOV      r5,r6                 ;573
000072  2000              MOVS     r0,#0                 ;573
                  |L1.116|
000074  1822              ADDS     r2,r4,r0              ;573
000076  5c0b              LDRB     r3,[r1,r0]            ;573
000078  f8823034          STRB     r3,[r2,#0x34]         ;573
00007c  5c0a              LDRB     r2,[r1,r0]            ;573
00007e  b112              CBZ      r2,|L1.134|
000080  1c40              ADDS     r0,r0,#1              ;573
000082  280a              CMP      r0,#0xa               ;573
000084  d3f6              BCC      |L1.116|
                  |L1.134|
000086  2000              MOVS     r0,#0                 ;573
000088  f884003d          STRB     r0,[r4,#0x3d]         ;573
00008c  2d05              CMP      r5,#5                 ;573
00008e  d300              BCC      |L1.146|
000090  2504              MOVS     r5,#4                 ;573
                  |L1.146|
000092  62e5              STR      r5,[r4,#0x2c]         ;573
000094  e9c45010          STRD     r5,r0,[r4,#0x40]      ;573
000098  1d20              ADDS     r0,r4,#4              ;573
00009a  f7fffffe          BL       vListInitialiseItem
00009e  f1040018          ADD      r0,r4,#0x18           ;573
0000a2  f7fffffe          BL       vListInitialiseItem
0000a6  6124              STR      r4,[r4,#0x10]         ;573
0000a8  f1c50105          RSB      r1,r5,#5              ;573
0000ac  6264              STR      r4,[r4,#0x24]         ;573
0000ae  61a1              STR      r1,[r4,#0x18]         ;573
0000b0  4659              MOV      r1,r11                ;585
0000b2  4638              MOV      r0,r7                 ;585
0000b4  9a03              LDR      r2,[sp,#0xc]          ;585
0000b6  f7fffffe          BL       pxPortInitialiseStack
0000ba  6020              STR      r0,[r4,#0]            ;589
0000bc  f1b80f00          CMP      r8,#0                 ;589
0000c0  d001              BEQ      |L1.198|
0000c2  f8c84000          STR      r4,[r8,#0]            ;594
                  |L1.198|
0000c6  f7fffffe          BL       vPortEnterCritical
0000ca  4dfa              LDR      r5,|L1.1204|
0000cc  68a8              LDR      r0,[r5,#8]            ;605  ; uxCurrentNumberOfTasks
0000ce  1c40              ADDS     r0,r0,#1              ;605
0000d0  60a8              STR      r0,[r5,#8]            ;605  ; uxCurrentNumberOfTasks
0000d2  6828              LDR      r0,[r5,#0]            ;606  ; pxCurrentTCB
0000d4  f8df83e0          LDR      r8,|L1.1208|
0000d8  b110              CBZ      r0,|L1.224|
0000da  6968              LDR      r0,[r5,#0x14]         ;629  ; xSchedulerRunning
0000dc  b348              CBZ      r0,|L1.306|
0000de  e02d              B        |L1.316|
                  |L1.224|
0000e0  602c              STR      r4,[r5,#0]            ;610  ; pxCurrentTCB
0000e2  68a8              LDR      r0,[r5,#8]            ;612  ; uxCurrentNumberOfTasks
0000e4  2801              CMP      r0,#1                 ;612
0000e6  d129              BNE      |L1.316|
0000e8  f05f0700          MOVS.W   r7,#0                 ;612
                  |L1.236|
0000ec  eb070187          ADD      r1,r7,r7,LSL #2       ;612
0000f0  eb080081          ADD      r0,r8,r1,LSL #2       ;612
0000f4  f7fffffe          BL       vListInitialise
0000f8  1c7f              ADDS     r7,r7,#1              ;612
0000fa  2f05              CMP      r7,#5                 ;612
0000fc  d3f6              BCC      |L1.236|
0000fe  48ee              LDR      r0,|L1.1208|
000100  3064              ADDS     r0,r0,#0x64           ;612
000102  f7fffffe          BL       vListInitialise
000106  48ec              LDR      r0,|L1.1208|
000108  3078              ADDS     r0,r0,#0x78           ;612
00010a  f7fffffe          BL       vListInitialise
00010e  48ea              LDR      r0,|L1.1208|
000110  308c              ADDS     r0,r0,#0x8c           ;612
000112  f7fffffe          BL       vListInitialise
000116  48e8              LDR      r0,|L1.1208|
000118  30a0              ADDS     r0,r0,#0xa0           ;612
00011a  f7fffffe          BL       vListInitialise
00011e  48e6              LDR      r0,|L1.1208|
000120  30b4              ADDS     r0,r0,#0xb4           ;612
000122  f7fffffe          BL       vListInitialise
000126  48e4              LDR      r0,|L1.1208|
000128  3064              ADDS     r0,r0,#0x64           ;612
00012a  6328              STR      r0,[r5,#0x30]         ;612  ; pxDelayedTaskList
00012c  3014              ADDS     r0,r0,#0x14           ;612
00012e  6368              STR      r0,[r5,#0x34]         ;612  ; pxOverflowDelayedTaskList
000130  e004              B        |L1.316|
                  |L1.306|
000132  6828              LDR      r0,[r5,#0]            ;631  ; pxCurrentTCB
000134  6ac0              LDR      r0,[r0,#0x2c]         ;631
000136  42b0              CMP      r0,r6                 ;631
000138  d800              BHI      |L1.316|
00013a  602c              STR      r4,[r5,#0]            ;633  ; pxCurrentTCB
                  |L1.316|
00013c  6a68              LDR      r0,[r5,#0x24]         ;646  ; uxTaskNumber
00013e  2101              MOVS     r1,#1                 ;656
000140  1c40              ADDS     r0,r0,#1              ;646
000142  6268              STR      r0,[r5,#0x24]         ;656  ; uxTaskNumber
000144  6ae0              LDR      r0,[r4,#0x2c]         ;656
000146  692a              LDR      r2,[r5,#0x10]         ;656  ; uxTopReadyPriority
000148  4081              LSLS     r1,r1,r0              ;656
00014a  4311              ORRS     r1,r1,r2              ;656
00014c  6129              STR      r1,[r5,#0x10]         ;656  ; uxTopReadyPriority
00014e  eb000180          ADD      r1,r0,r0,LSL #2       ;656
000152  eb080081          ADD      r0,r8,r1,LSL #2       ;656
000156  1d21              ADDS     r1,r4,#4              ;656
000158  f7fffffe          BL       vListInsertEnd
00015c  2401              MOVS     r4,#1                 ;658
00015e  f7fffffe          BL       vPortExitCritical
;;;666    		traceTASK_CREATE_FAILED();
;;;667    	}
;;;668    
;;;669    	if( xReturn == pdPASS )
;;;670    	{
;;;671    		if( xSchedulerRunning != pdFALSE )
000162  6968              LDR      r0,[r5,#0x14]  ; xSchedulerRunning
000164  b128              CBZ      r0,|L1.370|
;;;672    		{
;;;673    			/* If the created task is of a higher priority than the current task
;;;674    			then it should run now. */
;;;675    			if( pxCurrentTCB->uxPriority < uxPriority )
000166  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
000168  6ac0              LDR      r0,[r0,#0x2c]
00016a  42b0              CMP      r0,r6
00016c  d201              BCS      |L1.370|
;;;676    			{
;;;677    				taskYIELD_IF_USING_PREEMPTION();
00016e  f7fffffe          BL       vPortYield
                  |L1.370|
;;;678    			}
;;;679    			else
;;;680    			{
;;;681    				mtCOVERAGE_TEST_MARKER();
;;;682    			}
;;;683    		}
;;;684    		else
;;;685    		{
;;;686    			mtCOVERAGE_TEST_MARKER();
;;;687    		}
;;;688    	}
;;;689    
;;;690    	return xReturn;
;;;691    }
000172  b004              ADD      sp,sp,#0x10
000174  4620              MOV      r0,r4                 ;690
000176  e8bd9ff0          POP      {r4-r12,pc}
;;;692    /*-----------------------------------------------------------*/
                          ENDP

                  vTaskDelete PROC
;;;695    
;;;696    	void vTaskDelete( TaskHandle_t xTaskToDelete )
00017a  b570              PUSH     {r4-r6,lr}
;;;697    	{
00017c  4604              MOV      r4,r0
;;;698    	TCB_t *pxTCB;
;;;699    
;;;700    		taskENTER_CRITICAL();
00017e  f7fffffe          BL       vPortEnterCritical
;;;701    		{
;;;702    			/* If null is passed in here then it is the calling task that is
;;;703    			being deleted. */
;;;704    			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
000182  4dcc              LDR      r5,|L1.1204|
000184  b904              CBNZ     r4,|L1.392|
000186  682c              LDR      r4,[r5,#0]  ; pxCurrentTCB
                  |L1.392|
;;;705    
;;;706    			/* Remove task from the ready list and place in the	termination list.
;;;707    			This will stop the task from be scheduled.  The idle task will check
;;;708    			the termination list and free up any memory allocated by the
;;;709    			scheduler for the TCB and stack. */
;;;710    			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
000188  1d20              ADDS     r0,r4,#4
00018a  f7fffffe          BL       uxListRemove
00018e  b958              CBNZ     r0,|L1.424|
;;;711    			{
;;;712    				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
000190  6ae0              LDR      r0,[r4,#0x2c]
000192  4ac9              LDR      r2,|L1.1208|
000194  eb000180          ADD      r1,r0,r0,LSL #2
000198  f8521021          LDR      r1,[r2,r1,LSL #2]
00019c  b921              CBNZ     r1,|L1.424|
00019e  2101              MOVS     r1,#1
0001a0  4081              LSLS     r1,r1,r0
0001a2  6928              LDR      r0,[r5,#0x10]  ; uxTopReadyPriority
0001a4  4388              BICS     r0,r0,r1
0001a6  6128              STR      r0,[r5,#0x10]  ; uxTopReadyPriority
                  |L1.424|
;;;713    			}
;;;714    			else
;;;715    			{
;;;716    				mtCOVERAGE_TEST_MARKER();
;;;717    			}
;;;718    
;;;719    			/* Is the task waiting on an event also? */
;;;720    			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
0001a8  6aa0              LDR      r0,[r4,#0x28]
0001aa  b118              CBZ      r0,|L1.436|
;;;721    			{
;;;722    				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
0001ac  f1040018          ADD      r0,r4,#0x18
0001b0  f7fffffe          BL       uxListRemove
                  |L1.436|
;;;723    			}
;;;724    			else
;;;725    			{
;;;726    				mtCOVERAGE_TEST_MARKER();
;;;727    			}
;;;728    
;;;729    			vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
0001b4  48c0              LDR      r0,|L1.1208|
0001b6  1d21              ADDS     r1,r4,#4
0001b8  30a0              ADDS     r0,r0,#0xa0
0001ba  f7fffffe          BL       vListInsertEnd
;;;730    
;;;731    			/* Increment the ucTasksDeleted variable so the idle task knows
;;;732    			there is a task that has been deleted and that it should therefore
;;;733    			check the xTasksWaitingTermination list. */
;;;734    			++uxTasksDeleted;
0001be  6868              LDR      r0,[r5,#4]  ; uxTasksDeleted
0001c0  1c40              ADDS     r0,r0,#1
0001c2  6068              STR      r0,[r5,#4]  ; uxTasksDeleted
;;;735    
;;;736    			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
;;;737    			can detect that the task lists need re-generating. */
;;;738    			uxTaskNumber++;
0001c4  6a68              LDR      r0,[r5,#0x24]  ; uxTaskNumber
0001c6  1c40              ADDS     r0,r0,#1
;;;739    
;;;740    			traceTASK_DELETE( pxTCB );
;;;741    		}
;;;742    		taskEXIT_CRITICAL();
0001c8  6268              STR      r0,[r5,#0x24]  ; uxTaskNumber
0001ca  f7fffffe          BL       vPortExitCritical
;;;743    
;;;744    		/* Force a reschedule if it is the currently running task that has just
;;;745    		been deleted. */
;;;746    		if( xSchedulerRunning != pdFALSE )
0001ce  6968              LDR      r0,[r5,#0x14]  ; xSchedulerRunning
0001d0  2800              CMP      r0,#0
0001d2  d013              BEQ      |L1.508|
;;;747    		{
;;;748    			if( pxTCB == pxCurrentTCB )
0001d4  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
0001d6  4284              CMP      r4,r0
0001d8  d108              BNE      |L1.492|
;;;749    			{
;;;750    				configASSERT( uxSchedulerSuspended == 0 );
0001da  6ae8              LDR      r0,[r5,#0x2c]  ; uxSchedulerSuspended
0001dc  b110              CBZ      r0,|L1.484|
0001de  f7fffffe          BL       ulPortSetInterruptMask
                  |L1.482|
0001e2  e7fe              B        |L1.482|
                  |L1.484|
;;;751    
;;;752    				/* The pre-delete hook is primarily for the Windows simulator,
;;;753    				in which Windows specific clean up operations are performed,
;;;754    				after which it is not possible to yield away from this task -
;;;755    				hence xYieldPending is used to latch that a context switch is
;;;756    				required. */
;;;757    				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
;;;758    				portYIELD_WITHIN_API();
0001e4  e8bd4070          POP      {r4-r6,lr}
0001e8  f7ffbffe          B.W      vPortYield
                  |L1.492|
;;;759    			}
;;;760    			else
;;;761    			{
;;;762    				/* Reset the next expected unblock time in case it referred to
;;;763    				the task that has just been deleted. */
;;;764    				taskENTER_CRITICAL();
0001ec  f7fffffe          BL       vPortEnterCritical
;;;765    				{
;;;766    					prvResetNextTaskUnblockTime();
0001f0  f7fffffe          BL       prvResetNextTaskUnblockTime
;;;767    				}
;;;768    				taskEXIT_CRITICAL();
0001f4  e8bd4070          POP      {r4-r6,lr}
0001f8  f7ffbffe          B.W      vPortExitCritical
                  |L1.508|
;;;769    			}
;;;770    		}
;;;771    	}
0001fc  bd70              POP      {r4-r6,pc}
;;;772    
                          ENDP

                  xTaskIncrementTick PROC
;;;1849   
;;;1850   BaseType_t xTaskIncrementTick( void )
0001fe  e92d41f0          PUSH     {r4-r8,lr}
;;;1851   {
;;;1852   TCB_t * pxTCB;
;;;1853   TickType_t xItemValue;
;;;1854   BaseType_t xSwitchRequired = pdFALSE;
;;;1855   
;;;1856   	/* Called by the portable layer each time a tick interrupt occurs.
;;;1857   	Increments the tick then checks to see if the new tick value will cause any
;;;1858   	tasks to be unblocked. */
;;;1859   	traceTASK_INCREMENT_TICK( xTickCount );
;;;1860   	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
000202  4cac              LDR      r4,|L1.1204|
000204  2600              MOVS     r6,#0                 ;1854
000206  6ae0              LDR      r0,[r4,#0x2c]  ; uxSchedulerSuspended
000208  b118              CBZ      r0,|L1.530|
;;;1861   	{
;;;1862   		/* Increment the RTOS tick, switching the delayed and overflowed
;;;1863   		delayed lists if it wraps to 0. */
;;;1864   		++xTickCount;
;;;1865   
;;;1866   		{
;;;1867   			/* Minor optimisation.  The tick count cannot change in this
;;;1868   			block. */
;;;1869   			const TickType_t xConstTickCount = xTickCount;
;;;1870   
;;;1871   			if( xConstTickCount == ( TickType_t ) 0U )
;;;1872   			{
;;;1873   				taskSWITCH_DELAYED_LISTS();
;;;1874   			}
;;;1875   			else
;;;1876   			{
;;;1877   				mtCOVERAGE_TEST_MARKER();
;;;1878   			}
;;;1879   
;;;1880   			/* See if this tick has made a timeout expire.  Tasks are stored in
;;;1881   			the	queue in the order of their wake time - meaning once one task
;;;1882   			has been found whose block time has not expired there is no need to
;;;1883   			look any further	down the list. */
;;;1884   			if( xConstTickCount >= xNextTaskUnblockTime )
;;;1885   			{
;;;1886   				for( ;; )
;;;1887   				{
;;;1888   					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
;;;1889   					{
;;;1890   						/* The delayed list is empty.  Set xNextTaskUnblockTime
;;;1891   						to the maximum possible value so it is extremely
;;;1892   						unlikely that the
;;;1893   						if( xTickCount >= xNextTaskUnblockTime ) test will pass
;;;1894   						next time through. */
;;;1895   						xNextTaskUnblockTime = portMAX_DELAY;
;;;1896   						break;
;;;1897   					}
;;;1898   					else
;;;1899   					{
;;;1900   						/* The delayed list is not empty, get the value of the
;;;1901   						item at the head of the delayed list.  This is the time
;;;1902   						at which the task at the head of the delayed list must
;;;1903   						be removed from the Blocked state. */
;;;1904   						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
;;;1905   						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
;;;1906   
;;;1907   						if( xConstTickCount < xItemValue )
;;;1908   						{
;;;1909   							/* It is not time to unblock this item yet, but the
;;;1910   							item value is the time at which the task at the head
;;;1911   							of the blocked list must be removed from the Blocked
;;;1912   							state -	so record the item value in
;;;1913   							xNextTaskUnblockTime. */
;;;1914   							xNextTaskUnblockTime = xItemValue;
;;;1915   							break;
;;;1916   						}
;;;1917   						else
;;;1918   						{
;;;1919   							mtCOVERAGE_TEST_MARKER();
;;;1920   						}
;;;1921   
;;;1922   						/* It is time to remove the item from the Blocked state. */
;;;1923   						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
;;;1924   
;;;1925   						/* Is the task waiting on an event also?  If so remove
;;;1926   						it from the event list. */
;;;1927   						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
;;;1928   						{
;;;1929   							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
;;;1930   						}
;;;1931   						else
;;;1932   						{
;;;1933   							mtCOVERAGE_TEST_MARKER();
;;;1934   						}
;;;1935   
;;;1936   						/* Place the unblocked task into the appropriate ready
;;;1937   						list. */
;;;1938   						prvAddTaskToReadyList( pxTCB );
;;;1939   
;;;1940   						/* A task being unblocked cannot cause an immediate
;;;1941   						context switch if preemption is turned off. */
;;;1942   						#if (  configUSE_PREEMPTION == 1 )
;;;1943   						{
;;;1944   							/* Preemption is on, but a context switch should
;;;1945   							only be performed if the unblocked task has a
;;;1946   							priority that is equal to or higher than the
;;;1947   							currently executing task. */
;;;1948   							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
;;;1949   							{
;;;1950   								xSwitchRequired = pdTRUE;
;;;1951   							}
;;;1952   							else
;;;1953   							{
;;;1954   								mtCOVERAGE_TEST_MARKER();
;;;1955   							}
;;;1956   						}
;;;1957   						#endif /* configUSE_PREEMPTION */
;;;1958   					}
;;;1959   				}
;;;1960   			}
;;;1961   		}
;;;1962   
;;;1963   		/* Tasks of equal priority to the currently running task will share
;;;1964   		processing time (time slice) if preemption is on, and the application
;;;1965   		writer has not explicitly turned time slicing off. */
;;;1966   		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
;;;1967   		{
;;;1968   			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
;;;1969   			{
;;;1970   				xSwitchRequired = pdTRUE;
;;;1971   			}
;;;1972   			else
;;;1973   			{
;;;1974   				mtCOVERAGE_TEST_MARKER();
;;;1975   			}
;;;1976   		}
;;;1977   		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) ) */
;;;1978   
;;;1979   		#if ( configUSE_TICK_HOOK == 1 )
;;;1980   		{
;;;1981   			/* Guard against the tick hook being called when the pended tick
;;;1982   			count is being unwound (when the scheduler is being unlocked). */
;;;1983   			if( uxPendedTicks == ( UBaseType_t ) 0U )
;;;1984   			{
;;;1985   				vApplicationTickHook();
;;;1986   			}
;;;1987   			else
;;;1988   			{
;;;1989   				mtCOVERAGE_TEST_MARKER();
;;;1990   			}
;;;1991   		}
;;;1992   		#endif /* configUSE_TICK_HOOK */
;;;1993   	}
;;;1994   	else
;;;1995   	{
;;;1996   		++uxPendedTicks;
00020a  69a0              LDR      r0,[r4,#0x18]  ; uxPendedTicks
00020c  1c40              ADDS     r0,r0,#1
00020e  61a0              STR      r0,[r4,#0x18]  ; uxPendedTicks
;;;1997   
;;;1998   		/* The tick hook gets called at regular intervals, even if the
;;;1999   		scheduler is locked. */
;;;2000   		#if ( configUSE_TICK_HOOK == 1 )
;;;2001   		{
;;;2002   			vApplicationTickHook();
000210  e04e              B        |L1.688|
                  |L1.530|
000212  68e0              LDR      r0,[r4,#0xc]          ;1864  ; xTickCount
000214  1c40              ADDS     r0,r0,#1              ;1864
000216  60e0              STR      r0,[r4,#0xc]          ;1864  ; xTickCount
000218  68e7              LDR      r7,[r4,#0xc]          ;1869  ; xTickCount
00021a  b977              CBNZ     r7,|L1.570|
00021c  6b20              LDR      r0,[r4,#0x30]         ;1873  ; pxDelayedTaskList
00021e  6800              LDR      r0,[r0,#0]            ;1873
000220  b110              CBZ      r0,|L1.552|
000222  f7fffffe          BL       ulPortSetInterruptMask
                  |L1.550|
000226  e7fe              B        |L1.550|
                  |L1.552|
000228  6b20              LDR      r0,[r4,#0x30]         ;1873  ; pxDelayedTaskList
00022a  6b61              LDR      r1,[r4,#0x34]         ;1873  ; pxOverflowDelayedTaskList
00022c  6321              STR      r1,[r4,#0x30]         ;1873  ; pxDelayedTaskList
00022e  6360              STR      r0,[r4,#0x34]         ;1873  ; pxOverflowDelayedTaskList
000230  6a20              LDR      r0,[r4,#0x20]         ;1873  ; xNumOfOverflows
000232  1c40              ADDS     r0,r0,#1              ;1873
000234  6220              STR      r0,[r4,#0x20]         ;1873  ; xNumOfOverflows
000236  f7fffffe          BL       prvResetNextTaskUnblockTime
                  |L1.570|
00023a  6aa0              LDR      r0,[r4,#0x28]         ;1884  ; xNextTaskUnblockTime
00023c  f8df8278          LDR      r8,|L1.1208|
000240  4287              CMP      r7,r0                 ;1884
000242  d309              BCC      |L1.600|
                  |L1.580|
000244  6b20              LDR      r0,[r4,#0x30]         ;1888  ; pxDelayedTaskList
000246  6800              LDR      r0,[r0,#0]            ;1888
000248  b190              CBZ      r0,|L1.624|
00024a  6b20              LDR      r0,[r4,#0x30]         ;1904  ; pxDelayedTaskList
00024c  68c0              LDR      r0,[r0,#0xc]          ;1904
00024e  68c5              LDR      r5,[r0,#0xc]          ;1905
000250  6868              LDR      r0,[r5,#4]            ;1907
000252  4287              CMP      r7,r0                 ;1907
000254  d20f              BCS      |L1.630|
                  |L1.598|
000256  62a0              STR      r0,[r4,#0x28]         ;1914  ; xNextTaskUnblockTime
                  |L1.600|
000258  6820              LDR      r0,[r4,#0]            ;1968  ; pxCurrentTCB
00025a  6ac0              LDR      r0,[r0,#0x2c]         ;1968
00025c  eb000180          ADD      r1,r0,r0,LSL #2       ;1968
000260  f8580021          LDR      r0,[r8,r1,LSL #2]     ;1968
000264  2801              CMP      r0,#1                 ;1968
000266  d900              BLS      |L1.618|
000268  2601              MOVS     r6,#1                 ;1970
                  |L1.618|
00026a  69a0              LDR      r0,[r4,#0x18]         ;1983  ; uxPendedTicks
00026c  b300              CBZ      r0,|L1.688|
00026e  e021              B        |L1.692|
                  |L1.624|
000270  f04f30ff          MOV      r0,#0xffffffff        ;1895
000274  e7ef              B        |L1.598|
                  |L1.630|
000276  1d28              ADDS     r0,r5,#4              ;1923
000278  f7fffffe          BL       uxListRemove
00027c  6aa8              LDR      r0,[r5,#0x28]         ;1927
00027e  b118              CBZ      r0,|L1.648|
000280  f1050018          ADD      r0,r5,#0x18           ;1929
000284  f7fffffe          BL       uxListRemove
                  |L1.648|
000288  6ae8              LDR      r0,[r5,#0x2c]         ;1938
00028a  2101              MOVS     r1,#1                 ;1938
00028c  6922              LDR      r2,[r4,#0x10]         ;1938  ; uxTopReadyPriority
00028e  4081              LSLS     r1,r1,r0              ;1938
000290  4311              ORRS     r1,r1,r2              ;1938
000292  6121              STR      r1,[r4,#0x10]         ;1938  ; uxTopReadyPriority
000294  eb000180          ADD      r1,r0,r0,LSL #2       ;1938
000298  eb080081          ADD      r0,r8,r1,LSL #2       ;1938
00029c  1d29              ADDS     r1,r5,#4              ;1938
00029e  f7fffffe          BL       vListInsertEnd
0002a2  6ae8              LDR      r0,[r5,#0x2c]         ;1948
0002a4  6821              LDR      r1,[r4,#0]            ;1948  ; pxCurrentTCB
0002a6  6ac9              LDR      r1,[r1,#0x2c]         ;1948
0002a8  4288              CMP      r0,r1                 ;1948
0002aa  d3cb              BCC      |L1.580|
0002ac  2601              MOVS     r6,#1                 ;1950
0002ae  e7c9              B        |L1.580|
                  |L1.688|
0002b0  f7fffffe          BL       vApplicationTickHook
                  |L1.692|
;;;2003   		}
;;;2004   		#endif
;;;2005   	}
;;;2006   
;;;2007   	#if ( configUSE_PREEMPTION == 1 )
;;;2008   	{
;;;2009   		if( xYieldPending != pdFALSE )
0002b4  69e0              LDR      r0,[r4,#0x1c]  ; xYieldPending
0002b6  b100              CBZ      r0,|L1.698|
;;;2010   		{
;;;2011   			xSwitchRequired = pdTRUE;
0002b8  2601              MOVS     r6,#1
                  |L1.698|
;;;2012   		}
;;;2013   		else
;;;2014   		{
;;;2015   			mtCOVERAGE_TEST_MARKER();
;;;2016   		}
;;;2017   	}
;;;2018   	#endif /* configUSE_PREEMPTION */
;;;2019   
;;;2020   	return xSwitchRequired;
0002ba  4630              MOV      r0,r6
                  |L1.700|
;;;2021   }
0002bc  e8bd81f0          POP      {r4-r8,pc}
;;;2022   /*-----------------------------------------------------------*/
                          ENDP

                  xTaskResumeAll PROC
;;;1581   
;;;1582   BaseType_t xTaskResumeAll( void )
0002c0  e92d47f0          PUSH     {r4-r10,lr}
;;;1583   {
;;;1584   TCB_t *pxTCB;
;;;1585   BaseType_t xAlreadyYielded = pdFALSE;
;;;1586   
;;;1587   	/* If uxSchedulerSuspended is zero then this function does not match a
;;;1588   	previous call to vTaskSuspendAll(). */
;;;1589   	configASSERT( uxSchedulerSuspended );
0002c4  4c7b              LDR      r4,|L1.1204|
0002c6  2600              MOVS     r6,#0                 ;1585
0002c8  6ae0              LDR      r0,[r4,#0x2c]  ; uxSchedulerSuspended
0002ca  b138              CBZ      r0,|L1.732|
;;;1590   
;;;1591   	/* It is possible that an ISR caused a task to be removed from an event
;;;1592   	list while the scheduler was suspended.  If this was the case then the
;;;1593   	removed task will have been added to the xPendingReadyList.  Once the
;;;1594   	scheduler has been resumed it is safe to move all the pending ready
;;;1595   	tasks from this list into their appropriate ready list. */
;;;1596   	taskENTER_CRITICAL();
0002cc  f7fffffe          BL       vPortEnterCritical
;;;1597   	{
;;;1598   		--uxSchedulerSuspended;
0002d0  6ae0              LDR      r0,[r4,#0x2c]  ; uxSchedulerSuspended
0002d2  1e40              SUBS     r0,r0,#1
0002d4  62e0              STR      r0,[r4,#0x2c]  ; uxSchedulerSuspended
;;;1599   
;;;1600   		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
0002d6  6ae0              LDR      r0,[r4,#0x2c]  ; uxSchedulerSuspended
0002d8  b118              CBZ      r0,|L1.738|
0002da  e03e              B        |L1.858|
                  |L1.732|
0002dc  f7fffffe          BL       ulPortSetInterruptMask
                  |L1.736|
0002e0  e7fe              B        |L1.736|
                  |L1.738|
;;;1601   		{
;;;1602   			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
0002e2  68a1              LDR      r1,[r4,#8]  ; uxCurrentNumberOfTasks
;;;1603   			{
;;;1604   				/* Move any readied tasks from the pending list into the
;;;1605   				appropriate ready list. */
;;;1606   				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
;;;1607   				{
;;;1608   					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
0002e4  4d74              LDR      r5,|L1.1208|
0002e6  358c              ADDS     r5,r5,#0x8c
;;;1609   					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
;;;1610   					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
;;;1611   					prvAddTaskToReadyList( pxTCB );
0002e8  2001              MOVS     r0,#1
0002ea  b379              CBZ      r1,|L1.844|
0002ec  f8df91c8          LDR      r9,|L1.1208|
0002f0  4680              MOV      r8,r0
                  |L1.754|
0002f2  6828              LDR      r0,[r5,#0]            ;1606  ; xPendingReadyList
0002f4  b1e8              CBZ      r0,|L1.818|
0002f6  68e8              LDR      r0,[r5,#0xc]          ;1608  ; xPendingReadyList
0002f8  68c7              LDR      r7,[r0,#0xc]          ;1609
0002fa  f1070018          ADD      r0,r7,#0x18           ;1609
0002fe  f7fffffe          BL       uxListRemove
000302  1d38              ADDS     r0,r7,#4              ;1610
000304  f7fffffe          BL       uxListRemove
000308  6af9              LDR      r1,[r7,#0x2c]
00030a  6922              LDR      r2,[r4,#0x10]  ; uxTopReadyPriority
00030c  fa08f001          LSL      r0,r8,r1
000310  4310              ORRS     r0,r0,r2
000312  6120              STR      r0,[r4,#0x10]  ; uxTopReadyPriority
000314  eb010181          ADD      r1,r1,r1,LSL #2
000318  eb090081          ADD      r0,r9,r1,LSL #2
00031c  1d39              ADDS     r1,r7,#4
00031e  f7fffffe          BL       vListInsertEnd
;;;1612   
;;;1613   					/* If we have moved a task that has a priority higher than
;;;1614   					the current task then we should yield. */
;;;1615   					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
000322  6af8              LDR      r0,[r7,#0x2c]
000324  6821              LDR      r1,[r4,#0]  ; pxCurrentTCB
000326  6ac9              LDR      r1,[r1,#0x2c]
000328  4288              CMP      r0,r1
00032a  d3e2              BCC      |L1.754|
;;;1616   					{
;;;1617   						xYieldPending = pdTRUE;
00032c  f8c4801c          STR      r8,[r4,#0x1c]  ; xYieldPending
000330  e7df              B        |L1.754|
                  |L1.818|
;;;1618   					}
;;;1619   					else
;;;1620   					{
;;;1621   						mtCOVERAGE_TEST_MARKER();
;;;1622   					}
;;;1623   				}
;;;1624   
;;;1625   				/* If any ticks occurred while the scheduler was suspended then
;;;1626   				they should be processed now.  This ensures the tick count does
;;;1627   				not	slip, and that any delayed tasks are resumed at the correct
;;;1628   				time. */
;;;1629   				if( uxPendedTicks > ( UBaseType_t ) 0U )
000332  69a0              LDR      r0,[r4,#0x18]  ; uxPendedTicks
000334  b158              CBZ      r0,|L1.846|
000336  4645              MOV      r5,r8                 ;1611
                  |L1.824|
;;;1630   				{
;;;1631   					while( uxPendedTicks > ( UBaseType_t ) 0U )
000338  69a0              LDR      r0,[r4,#0x18]  ; uxPendedTicks
00033a  b140              CBZ      r0,|L1.846|
;;;1632   					{
;;;1633   						if( xTaskIncrementTick() != pdFALSE )
00033c  f7fffffe          BL       xTaskIncrementTick
000340  b100              CBZ      r0,|L1.836|
;;;1634   						{
;;;1635   							xYieldPending = pdTRUE;
000342  61e5              STR      r5,[r4,#0x1c]  ; xYieldPending
                  |L1.836|
;;;1636   						}
;;;1637   						else
;;;1638   						{
;;;1639   							mtCOVERAGE_TEST_MARKER();
;;;1640   						}
;;;1641   						--uxPendedTicks;
000344  69a0              LDR      r0,[r4,#0x18]  ; uxPendedTicks
000346  1e40              SUBS     r0,r0,#1
000348  61a0              STR      r0,[r4,#0x18]  ; uxPendedTicks
00034a  e7f5              B        |L1.824|
                  |L1.844|
00034c  e005              B        |L1.858|
                  |L1.846|
;;;1642   					}
;;;1643   				}
;;;1644   				else
;;;1645   				{
;;;1646   					mtCOVERAGE_TEST_MARKER();
;;;1647   				}
;;;1648   
;;;1649   				if( xYieldPending == pdTRUE )
00034e  69e0              LDR      r0,[r4,#0x1c]  ; xYieldPending
000350  2801              CMP      r0,#1
000352  d102              BNE      |L1.858|
;;;1650   				{
;;;1651   					#if( configUSE_PREEMPTION != 0 )
;;;1652   					{
;;;1653   						xAlreadyYielded = pdTRUE;
000354  2601              MOVS     r6,#1
;;;1654   					}
;;;1655   					#endif
;;;1656   					taskYIELD_IF_USING_PREEMPTION();
000356  f7fffffe          BL       vPortYield
                  |L1.858|
;;;1657   				}
;;;1658   				else
;;;1659   				{
;;;1660   					mtCOVERAGE_TEST_MARKER();
;;;1661   				}
;;;1662   			}
;;;1663   		}
;;;1664   		else
;;;1665   		{
;;;1666   			mtCOVERAGE_TEST_MARKER();
;;;1667   		}
;;;1668   	}
;;;1669   	taskEXIT_CRITICAL();
00035a  f7fffffe          BL       vPortExitCritical
;;;1670   
;;;1671   	return xAlreadyYielded;
00035e  4630              MOV      r0,r6
;;;1672   }
000360  e8bd87f0          POP      {r4-r10,pc}
;;;1673   /*-----------------------------------------------------------*/
                          ENDP

                  prvAddCurrentTaskToDelayedList PROC
;;;2883   
;;;2884   static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
000364  b570              PUSH     {r4-r6,lr}
;;;2885   {
;;;2886   	/* The list item will be inserted in wake time order. */
;;;2887   	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
000366  4c53              LDR      r4,|L1.1204|
000368  4605              MOV      r5,r0                 ;2885
00036a  6820              LDR      r0,[r4,#0]  ; pxCurrentTCB
;;;2888   
;;;2889   	if( xTimeToWake < xTickCount )
00036c  6045              STR      r5,[r0,#4]
00036e  68e0              LDR      r0,[r4,#0xc]  ; xTickCount
;;;2890   	{
;;;2891   		/* Wake time has overflowed.  Place this item in the overflow list. */
;;;2892   		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
;;;2893   	}
;;;2894   	else
;;;2895   	{
;;;2896   		/* The wake time has not overflowed, so the current block list is used. */
;;;2897   		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
000370  6821              LDR      r1,[r4,#0]  ; pxCurrentTCB
000372  4285              CMP      r5,r0                 ;2889
000374  d205              BCS      |L1.898|
000376  6b60              LDR      r0,[r4,#0x34]         ;2892  ; pxOverflowDelayedTaskList
000378  e8bd4070          POP      {r4-r6,lr}            ;2892
00037c  1d09              ADDS     r1,r1,#4              ;2892
00037e  f7ffbffe          B.W      vListInsert
                  |L1.898|
000382  6b20              LDR      r0,[r4,#0x30]  ; pxDelayedTaskList
000384  1d09              ADDS     r1,r1,#4
000386  f7fffffe          BL       vListInsert
;;;2898   
;;;2899   		/* If the task entering the blocked state was placed at the head of the
;;;2900   		list of blocked tasks then xNextTaskUnblockTime needs to be updated
;;;2901   		too. */
;;;2902   		if( xTimeToWake < xNextTaskUnblockTime )
00038a  6aa0              LDR      r0,[r4,#0x28]  ; xNextTaskUnblockTime
00038c  4285              CMP      r5,r0
00038e  d200              BCS      |L1.914|
;;;2903   		{
;;;2904   			xNextTaskUnblockTime = xTimeToWake;
000390  62a5              STR      r5,[r4,#0x28]  ; xNextTaskUnblockTime
                  |L1.914|
;;;2905   		}
;;;2906   		else
;;;2907   		{
;;;2908   			mtCOVERAGE_TEST_MARKER();
;;;2909   		}
;;;2910   	}
;;;2911   }
000392  bd70              POP      {r4-r6,pc}
;;;2912   /*-----------------------------------------------------------*/
                          ENDP

                  vTaskSuspendAll PROC
;;;1543   
;;;1544   void vTaskSuspendAll( void )
000394  4847              LDR      r0,|L1.1204|
;;;1545   {
;;;1546   	/* A critical section is not required as the variable is of type
;;;1547   	BaseType_t.  Please read Richard Barry's reply in the following link to a
;;;1548   	post in the FreeRTOS support forum before reporting this as a bug! -
;;;1549   	http://goo.gl/wu4acr */
;;;1550   	++uxSchedulerSuspended;
000396  6ac1              LDR      r1,[r0,#0x2c]  ; uxSchedulerSuspended
000398  1c49              ADDS     r1,r1,#1
00039a  62c1              STR      r1,[r0,#0x2c]  ; uxSchedulerSuspended
;;;1551   }
00039c  4770              BX       lr
;;;1552   /*----------------------------------------------------------*/
                          ENDP

                  vTaskDelayUntil PROC
;;;777    
;;;778    	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
00039e  b570              PUSH     {r4-r6,lr}
;;;779    	{
0003a0  460c              MOV      r4,r1
0003a2  0002              MOVS     r2,r0
0003a4  d006              BEQ      |L1.948|
;;;780    	TickType_t xTimeToWake;
;;;781    	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
;;;782    
;;;783    		configASSERT( pxPreviousWakeTime );
;;;784    		configASSERT( ( xTimeIncrement > 0U ) );
0003a6  b144              CBZ      r4,|L1.954|
;;;785    		configASSERT( uxSchedulerSuspended == 0 );
0003a8  4d42              LDR      r5,|L1.1204|
0003aa  6ae8              LDR      r0,[r5,#0x2c]  ; uxSchedulerSuspended
0003ac  b140              CBZ      r0,|L1.960|
0003ae  f7fffffe          BL       ulPortSetInterruptMask
                  |L1.946|
0003b2  e7fe              B        |L1.946|
                  |L1.948|
0003b4  f7fffffe          BL       ulPortSetInterruptMask
                  |L1.952|
0003b8  e7fe              B        |L1.952|
                  |L1.954|
0003ba  f7fffffe          BL       ulPortSetInterruptMask
                  |L1.958|
0003be  e7fe              B        |L1.958|
                  |L1.960|
;;;786    
;;;787    		vTaskSuspendAll();
0003c0  f7fffffe          BL       vTaskSuspendAll
;;;788    		{
;;;789    			/* Minor optimisation.  The tick count cannot change in this
;;;790    			block. */
;;;791    			const TickType_t xConstTickCount = xTickCount;
0003c4  68eb              LDR      r3,[r5,#0xc]  ; xTickCount
;;;792    
;;;793    			/* Generate the tick time at which the task wants to wake. */
;;;794    			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
0003c6  6810              LDR      r0,[r2,#0]
0003c8  4404              ADD      r4,r4,r0
;;;795    
;;;796    			if( xConstTickCount < *pxPreviousWakeTime )
0003ca  4298              CMP      r0,r3
0003cc  d904              BLS      |L1.984|
;;;797    			{
;;;798    				/* The tick count has overflowed since this function was
;;;799    				lasted called.  In this case the only time we should ever
;;;800    				actually delay is if the wake time has also	overflowed,
;;;801    				and the wake time is greater than the tick time.  When this
;;;802    				is the case it is as if neither time had overflowed. */
;;;803    				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
0003ce  42a0              CMP      r0,r4
0003d0  d90b              BLS      |L1.1002|
                  |L1.978|
0003d2  429c              CMP      r4,r3
0003d4  d802              BHI      |L1.988|
0003d6  e008              B        |L1.1002|
                  |L1.984|
;;;804    				{
;;;805    					xShouldDelay = pdTRUE;
;;;806    				}
;;;807    				else
;;;808    				{
;;;809    					mtCOVERAGE_TEST_MARKER();
;;;810    				}
;;;811    			}
;;;812    			else
;;;813    			{
;;;814    				/* The tick time has not overflowed.  In this case we will
;;;815    				delay if either the wake time has overflowed, and/or the
;;;816    				tick time is less than the wake time. */
;;;817    				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
0003d8  42a0              CMP      r0,r4
0003da  d9fa              BLS      |L1.978|
                  |L1.988|
;;;818    				{
;;;819    					xShouldDelay = pdTRUE;
;;;820    				}
;;;821    				else
;;;822    				{
;;;823    					mtCOVERAGE_TEST_MARKER();
;;;824    				}
;;;825    			}
;;;826    
;;;827    			/* Update the wake time ready for the next call. */
;;;828    			*pxPreviousWakeTime = xTimeToWake;
;;;829    
;;;830    			if( xShouldDelay != pdFALSE )
;;;831    			{
;;;832    				traceTASK_DELAY_UNTIL();
;;;833    
;;;834    				/* Remove the task from the ready list before adding it to the
;;;835    				blocked list as the same list item is used for both lists. */
;;;836    				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
0003dc  6014              STR      r4,[r2,#0]
0003de  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
0003e0  1d00              ADDS     r0,r0,#4
0003e2  f7fffffe          BL       uxListRemove
0003e6  b110              CBZ      r0,|L1.1006|
0003e8  e009              B        |L1.1022|
                  |L1.1002|
0003ea  6014              STR      r4,[r2,#0]            ;830
0003ec  e00a              B        |L1.1028|
                  |L1.1006|
;;;837    				{
;;;838    					/* The current task must be in a ready list, so there is
;;;839    					no need to check, and the port reset macro can be called
;;;840    					directly. */
;;;841    					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
0003ee  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
0003f0  f890102c          LDRB     r1,[r0,#0x2c]
0003f4  2001              MOVS     r0,#1
0003f6  4088              LSLS     r0,r0,r1
0003f8  6929              LDR      r1,[r5,#0x10]  ; uxTopReadyPriority
0003fa  4381              BICS     r1,r1,r0
0003fc  6129              STR      r1,[r5,#0x10]  ; uxTopReadyPriority
                  |L1.1022|
;;;842    				}
;;;843    				else
;;;844    				{
;;;845    					mtCOVERAGE_TEST_MARKER();
;;;846    				}
;;;847    
;;;848    				prvAddCurrentTaskToDelayedList( xTimeToWake );
0003fe  4620              MOV      r0,r4
000400  f7fffffe          BL       prvAddCurrentTaskToDelayedList
                  |L1.1028|
;;;849    			}
;;;850    			else
;;;851    			{
;;;852    				mtCOVERAGE_TEST_MARKER();
;;;853    			}
;;;854    		}
;;;855    		xAlreadyYielded = xTaskResumeAll();
000404  f7fffffe          BL       xTaskResumeAll
;;;856    
;;;857    		/* Force a reschedule if xTaskResumeAll has not already done so, we may
;;;858    		have put ourselves to sleep. */
;;;859    		if( xAlreadyYielded == pdFALSE )
000408  2800              CMP      r0,#0
00040a  d103              BNE      |L1.1044|
;;;860    		{
;;;861    			portYIELD_WITHIN_API();
00040c  e8bd4070          POP      {r4-r6,lr}
000410  f7ffbffe          B.W      vPortYield
                  |L1.1044|
;;;862    		}
;;;863    		else
;;;864    		{
;;;865    			mtCOVERAGE_TEST_MARKER();
;;;866    		}
;;;867    	}
000414  bd70              POP      {r4-r6,pc}
;;;868    
                          ENDP

                  vTaskDelay PROC
;;;873    
;;;874    	void vTaskDelay( const TickType_t xTicksToDelay )
000416  b570              PUSH     {r4-r6,lr}
;;;875    	{
000418  0002              MOVS     r2,r0
00041a  d01d              BEQ      |L1.1112|
;;;876    	TickType_t xTimeToWake;
;;;877    	BaseType_t xAlreadyYielded = pdFALSE;
;;;878    
;;;879    
;;;880    		/* A delay time of zero just forces a reschedule. */
;;;881    		if( xTicksToDelay > ( TickType_t ) 0U )
;;;882    		{
;;;883    			configASSERT( uxSchedulerSuspended == 0 );
00041c  4c25              LDR      r4,|L1.1204|
00041e  6ae0              LDR      r0,[r4,#0x2c]  ; uxSchedulerSuspended
000420  b110              CBZ      r0,|L1.1064|
000422  f7fffffe          BL       ulPortSetInterruptMask
                  |L1.1062|
000426  e7fe              B        |L1.1062|
                  |L1.1064|
;;;884    			vTaskSuspendAll();
000428  f7fffffe          BL       vTaskSuspendAll
;;;885    			{
;;;886    				traceTASK_DELAY();
;;;887    
;;;888    				/* A task that is removed from the event list while the
;;;889    				scheduler is suspended will not get placed in the ready
;;;890    				list or removed from the blocked list until the scheduler
;;;891    				is resumed.
;;;892    
;;;893    				This task cannot be in an event list as it is the currently
;;;894    				executing task. */
;;;895    
;;;896    				/* Calculate the time to wake - this may overflow but this is
;;;897    				not a problem. */
;;;898    				xTimeToWake = xTickCount + xTicksToDelay;
00042c  68e0              LDR      r0,[r4,#0xc]  ; xTickCount
00042e  1885              ADDS     r5,r0,r2
;;;899    
;;;900    				/* We must remove ourselves from the ready list before adding
;;;901    				ourselves to the blocked list as the same list item is used for
;;;902    				both lists. */
;;;903    				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
000430  6820              LDR      r0,[r4,#0]  ; pxCurrentTCB
000432  1d00              ADDS     r0,r0,#4
000434  f7fffffe          BL       uxListRemove
000438  b938              CBNZ     r0,|L1.1098|
;;;904    				{
;;;905    					/* The current task must be in a ready list, so there is
;;;906    					no need to check, and the port reset macro can be called
;;;907    					directly. */
;;;908    					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
00043a  6820              LDR      r0,[r4,#0]  ; pxCurrentTCB
00043c  f890102c          LDRB     r1,[r0,#0x2c]
000440  2001              MOVS     r0,#1
000442  4088              LSLS     r0,r0,r1
000444  6921              LDR      r1,[r4,#0x10]  ; uxTopReadyPriority
000446  4381              BICS     r1,r1,r0
000448  6121              STR      r1,[r4,#0x10]  ; uxTopReadyPriority
                  |L1.1098|
;;;909    				}
;;;910    				else
;;;911    				{
;;;912    					mtCOVERAGE_TEST_MARKER();
;;;913    				}
;;;914    				prvAddCurrentTaskToDelayedList( xTimeToWake );
00044a  4628              MOV      r0,r5
00044c  f7fffffe          BL       prvAddCurrentTaskToDelayedList
;;;915    			}
;;;916    			xAlreadyYielded = xTaskResumeAll();
000450  f7fffffe          BL       xTaskResumeAll
000454  2800              CMP      r0,#0
000456  d103              BNE      |L1.1120|
                  |L1.1112|
;;;917    		}
;;;918    		else
;;;919    		{
;;;920    			mtCOVERAGE_TEST_MARKER();
;;;921    		}
;;;922    
;;;923    		/* Force a reschedule if xTaskResumeAll has not already done so, we may
;;;924    		have put ourselves to sleep. */
;;;925    		if( xAlreadyYielded == pdFALSE )
;;;926    		{
;;;927    			portYIELD_WITHIN_API();
000458  e8bd4070          POP      {r4-r6,lr}
00045c  f7ffbffe          B.W      vPortYield
                  |L1.1120|
;;;928    		}
;;;929    		else
;;;930    		{
;;;931    			mtCOVERAGE_TEST_MARKER();
;;;932    		}
;;;933    	}
000460  bd70              POP      {r4-r6,pc}
;;;934    
                          ENDP

                  uxTaskPriorityGet PROC
;;;1009   
;;;1010   	UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask )
000462  b510              PUSH     {r4,lr}
;;;1011   	{
000464  4604              MOV      r4,r0
;;;1012   	TCB_t *pxTCB;
;;;1013   	UBaseType_t uxReturn;
;;;1014   
;;;1015   		taskENTER_CRITICAL();
000466  f7fffffe          BL       vPortEnterCritical
;;;1016   		{
;;;1017   			/* If null is passed in here then we are changing the
;;;1018   			priority of the calling function. */
;;;1019   			pxTCB = prvGetTCBFromHandle( xTask );
00046a  b90c              CBNZ     r4,|L1.1136|
00046c  4811              LDR      r0,|L1.1204|
00046e  6804              LDR      r4,[r0,#0]  ; pxCurrentTCB
                  |L1.1136|
;;;1020   			uxReturn = pxTCB->uxPriority;
000470  6ae4              LDR      r4,[r4,#0x2c]
;;;1021   		}
;;;1022   		taskEXIT_CRITICAL();
000472  f7fffffe          BL       vPortExitCritical
;;;1023   
;;;1024   		return uxReturn;
000476  4620              MOV      r0,r4
;;;1025   	}
000478  bd10              POP      {r4,pc}
;;;1026   
                          ENDP

                  vTaskPrioritySet PROC
;;;1031   
;;;1032   	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
00047a  e92d41f0          PUSH     {r4-r8,lr}
;;;1033   	{
;;;1034   	TCB_t *pxTCB;
;;;1035   	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
;;;1036   	BaseType_t xYieldRequired = pdFALSE;
00047e  2700              MOVS     r7,#0
000480  460e              MOV      r6,r1                 ;1033
000482  4604              MOV      r4,r0                 ;1033
;;;1037   
;;;1038   		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
000484  2905              CMP      r1,#5
000486  d302              BCC      |L1.1166|
000488  f7fffffe          BL       ulPortSetInterruptMask
                  |L1.1164|
00048c  e7fe              B        |L1.1164|
                  |L1.1166|
;;;1039   
;;;1040   		/* Ensure the new priority is valid. */
;;;1041   		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
;;;1042   		{
;;;1043   			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
;;;1044   		}
;;;1045   		else
;;;1046   		{
;;;1047   			mtCOVERAGE_TEST_MARKER();
;;;1048   		}
;;;1049   
;;;1050   		taskENTER_CRITICAL();
00048e  f7fffffe          BL       vPortEnterCritical
;;;1051   		{
;;;1052   			/* If null is passed in here then it is the priority of the calling
;;;1053   			task that is being changed. */
;;;1054   			pxTCB = prvGetTCBFromHandle( xTask );
000492  4d08              LDR      r5,|L1.1204|
000494  b904              CBNZ     r4,|L1.1176|
000496  682c              LDR      r4,[r5,#0]  ; pxCurrentTCB
                  |L1.1176|
;;;1055   
;;;1056   			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
;;;1057   
;;;1058   			#if ( configUSE_MUTEXES == 1 )
;;;1059   			{
;;;1060   				uxCurrentBasePriority = pxTCB->uxBasePriority;
;;;1061   			}
;;;1062   			#else
;;;1063   			{
;;;1064   				uxCurrentBasePriority = pxTCB->uxPriority;
;;;1065   			}
;;;1066   			#endif
;;;1067   
;;;1068   			if( uxCurrentBasePriority != uxNewPriority )
000498  6c20              LDR      r0,[r4,#0x40]
00049a  42b0              CMP      r0,r6
00049c  d03e              BEQ      |L1.1308|
;;;1069   			{
;;;1070   				/* The priority change may have readied a task of higher
;;;1071   				priority than the calling task. */
;;;1072   				if( uxNewPriority > uxCurrentBasePriority )
;;;1073   				{
;;;1074   					if( pxTCB != pxCurrentTCB )
;;;1075   					{
;;;1076   						/* The priority of a task other than the currently
;;;1077   						running task is being raised.  Is the priority being
;;;1078   						raised above that of the running task? */
;;;1079   						if( uxNewPriority >= pxCurrentTCB->uxPriority )
;;;1080   						{
;;;1081   							xYieldRequired = pdTRUE;
;;;1082   						}
;;;1083   						else
;;;1084   						{
;;;1085   							mtCOVERAGE_TEST_MARKER();
;;;1086   						}
;;;1087   					}
;;;1088   					else
;;;1089   					{
;;;1090   						/* The priority of the running task is being raised,
;;;1091   						but the running task must already be the highest
;;;1092   						priority task able to run so no yield is required. */
;;;1093   					}
;;;1094   				}
;;;1095   				else if( pxTCB == pxCurrentTCB )
00049e  6829              LDR      r1,[r5,#0]  ; pxCurrentTCB
0004a0  4286              CMP      r6,r0                 ;1072
0004a2  d90b              BLS      |L1.1212|
0004a4  428c              CMP      r4,r1                 ;1074
0004a6  d00c              BEQ      |L1.1218|
0004a8  6829              LDR      r1,[r5,#0]            ;1079  ; pxCurrentTCB
0004aa  6ac9              LDR      r1,[r1,#0x2c]         ;1079
0004ac  42b1              CMP      r1,r6                 ;1079
0004ae  d907              BLS      |L1.1216|
0004b0  e007              B        |L1.1218|
0004b2  0000              DCW      0x0000
                  |L1.1204|
                          DCD      ||.data||
                  |L1.1208|
                          DCD      ||.bss||
                  |L1.1212|
0004bc  428c              CMP      r4,r1
0004be  d100              BNE      |L1.1218|
                  |L1.1216|
;;;1096   				{
;;;1097   					/* Setting the priority of the running task down means
;;;1098   					there may now be another task of higher priority that
;;;1099   					is ready to execute. */
;;;1100   					xYieldRequired = pdTRUE;
0004c0  2701              MOVS     r7,#1
                  |L1.1218|
;;;1101   				}
;;;1102   				else
;;;1103   				{
;;;1104   					/* Setting the priority of any other task down does not
;;;1105   					require a yield as the running task must be above the
;;;1106   					new priority of the task being modified. */
;;;1107   				}
;;;1108   
;;;1109   				/* Remember the ready list the task might be referenced from
;;;1110   				before its uxPriority member is changed so the
;;;1111   				taskRESET_READY_PRIORITY() macro can function correctly. */
;;;1112   				uxPriorityUsedOnEntry = pxTCB->uxPriority;
0004c2  6ae1              LDR      r1,[r4,#0x2c]
0004c4  4688              MOV      r8,r1
;;;1113   
;;;1114   				#if ( configUSE_MUTEXES == 1 )
;;;1115   				{
;;;1116   					/* Only change the priority being used if the task is not
;;;1117   					currently using an inherited priority. */
;;;1118   					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
0004c6  4288              CMP      r0,r1
0004c8  d100              BNE      |L1.1228|
;;;1119   					{
;;;1120   						pxTCB->uxPriority = uxNewPriority;
0004ca  62e6              STR      r6,[r4,#0x2c]
                  |L1.1228|
;;;1121   					}
;;;1122   					else
;;;1123   					{
;;;1124   						mtCOVERAGE_TEST_MARKER();
;;;1125   					}
;;;1126   
;;;1127   					/* The base priority gets set whatever. */
;;;1128   					pxTCB->uxBasePriority = uxNewPriority;
;;;1129   				}
;;;1130   				#else
;;;1131   				{
;;;1132   					pxTCB->uxPriority = uxNewPriority;
;;;1133   				}
;;;1134   				#endif
;;;1135   
;;;1136   				/* Only reset the event list item value if the value is not
;;;1137   				being used for anything else. */
;;;1138   				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
0004cc  6426              STR      r6,[r4,#0x40]
0004ce  69a0              LDR      r0,[r4,#0x18]
0004d0  2800              CMP      r0,#0
0004d2  db02              BLT      |L1.1242|
;;;1139   				{
;;;1140   					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
0004d4  f1c60005          RSB      r0,r6,#5
0004d8  61a0              STR      r0,[r4,#0x18]
                  |L1.1242|
;;;1141   				}
;;;1142   				else
;;;1143   				{
;;;1144   					mtCOVERAGE_TEST_MARKER();
;;;1145   				}
;;;1146   
;;;1147   				/* If the task is in the blocked or suspended list we need do
;;;1148   				nothing more than change it's priority variable. However, if
;;;1149   				the task is in a ready list it needs to be removed and placed
;;;1150   				in the list appropriate to its new priority. */
;;;1151   				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
0004da  4ef8              LDR      r6,|L1.2236|
0004dc  eb080088          ADD      r0,r8,r8,LSL #2
0004e0  6961              LDR      r1,[r4,#0x14]
0004e2  eb060080          ADD      r0,r6,r0,LSL #2
0004e6  4281              CMP      r1,r0
0004e8  d115              BNE      |L1.1302|
;;;1152   				{
;;;1153   					/* The task is currently in its ready list - remove before adding
;;;1154   					it to it's new ready list.  As we are in a critical section we
;;;1155   					can do this even if the scheduler is suspended. */
;;;1156   					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
0004ea  1d20              ADDS     r0,r4,#4
0004ec  f7fffffe          BL       uxListRemove
0004f0  2101              MOVS     r1,#1                 ;1081
0004f2  b920              CBNZ     r0,|L1.1278|
;;;1157   					{
;;;1158   						/* It is known that the task is in its ready list so
;;;1159   						there is no need to check again and the port level
;;;1160   						reset macro can be called directly. */
;;;1161   						portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
0004f4  692a              LDR      r2,[r5,#0x10]  ; uxTopReadyPriority
0004f6  fa01f008          LSL      r0,r1,r8
0004fa  4382              BICS     r2,r2,r0
0004fc  612a              STR      r2,[r5,#0x10]  ; uxTopReadyPriority
                  |L1.1278|
;;;1162   					}
;;;1163   					else
;;;1164   					{
;;;1165   						mtCOVERAGE_TEST_MARKER();
;;;1166   					}
;;;1167   					prvAddTaskToReadyList( pxTCB );
0004fe  6ae0              LDR      r0,[r4,#0x2c]
000500  692a              LDR      r2,[r5,#0x10]  ; uxTopReadyPriority
000502  4081              LSLS     r1,r1,r0
000504  4311              ORRS     r1,r1,r2
000506  6129              STR      r1,[r5,#0x10]  ; uxTopReadyPriority
000508  eb000080          ADD      r0,r0,r0,LSL #2
00050c  eb060080          ADD      r0,r6,r0,LSL #2
000510  1d21              ADDS     r1,r4,#4
000512  f7fffffe          BL       vListInsertEnd
                  |L1.1302|
;;;1168   				}
;;;1169   				else
;;;1170   				{
;;;1171   					mtCOVERAGE_TEST_MARKER();
;;;1172   				}
;;;1173   
;;;1174   				if( xYieldRequired == pdTRUE )
000516  b10f              CBZ      r7,|L1.1308|
;;;1175   				{
;;;1176   					taskYIELD_IF_USING_PREEMPTION();
000518  f7fffffe          BL       vPortYield
                  |L1.1308|
;;;1177   				}
;;;1178   				else
;;;1179   				{
;;;1180   					mtCOVERAGE_TEST_MARKER();
;;;1181   				}
;;;1182   
;;;1183   				/* Remove compiler warning about unused variables when the port
;;;1184   				optimised task selection is not being used. */
;;;1185   				( void ) uxPriorityUsedOnEntry;
;;;1186   			}
;;;1187   		}
;;;1188   		taskEXIT_CRITICAL();
00051c  e8bd41f0          POP      {r4-r8,lr}
000520  f7ffbffe          B.W      vPortExitCritical
;;;1189   	}
;;;1190   
                          ENDP

                  vTaskSwitchContext PROC
;;;2113   
;;;2114   void vTaskSwitchContext( void )
000524  b510              PUSH     {r4,lr}
;;;2115   {
;;;2116   	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
000526  4ce6              LDR      r4,|L1.2240|
000528  6ae0              LDR      r0,[r4,#0x2c]  ; uxSchedulerSuspended
00052a  b110              CBZ      r0,|L1.1330|
;;;2117   	{
;;;2118   		/* The scheduler is currently suspended - do not allow a context
;;;2119   		switch. */
;;;2120   		xYieldPending = pdTRUE;
00052c  2001              MOVS     r0,#1
00052e  61e0              STR      r0,[r4,#0x1c]  ; xYieldPending
;;;2121   	}
;;;2122   	else
;;;2123   	{
;;;2124   		xYieldPending = pdFALSE;
;;;2125   		traceTASK_SWITCHED_OUT();
;;;2126   
;;;2127   		#if ( configGENERATE_RUN_TIME_STATS == 1 )
;;;2128   		{
;;;2129   				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
;;;2130   					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
;;;2131   				#else
;;;2132   					ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
;;;2133   				#endif
;;;2134   
;;;2135   				/* Add the amount of time the task has been running to the
;;;2136   				accumulated	time so far.  The time the task started running was
;;;2137   				stored in ulTaskSwitchedInTime.  Note that there is no overflow
;;;2138   				protection here	so count values are only valid until the timer
;;;2139   				overflows.  The guard against negative values is to protect
;;;2140   				against suspect run time stat counter implementations - which
;;;2141   				are provided by the application, not the kernel. */
;;;2142   				if( ulTotalRunTime > ulTaskSwitchedInTime )
;;;2143   				{
;;;2144   					pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
;;;2145   				}
;;;2146   				else
;;;2147   				{
;;;2148   					mtCOVERAGE_TEST_MARKER();
;;;2149   				}
;;;2150   				ulTaskSwitchedInTime = ulTotalRunTime;
;;;2151   		}
;;;2152   		#endif /* configGENERATE_RUN_TIME_STATS */
;;;2153   
;;;2154   		/* Check for stack overflow, if configured. */
;;;2155   		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
;;;2156   		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
;;;2157   
;;;2158   		/* Select a new task to run using either the generic C or port
;;;2159   		optimised asm code. */
;;;2160   		taskSELECT_HIGHEST_PRIORITY_TASK();
;;;2161   		traceTASK_SWITCHED_IN();
;;;2162   
;;;2163   		#if ( configUSE_NEWLIB_REENTRANT == 1 )
;;;2164   		{
;;;2165   			/* Switch Newlib's _impure_ptr variable to point to the _reent
;;;2166   			structure specific to this task. */
;;;2167   			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
;;;2168   		}
;;;2169   		#endif /* configUSE_NEWLIB_REENTRANT */
;;;2170   	}
;;;2171   }
000530  bd10              POP      {r4,pc}
                  |L1.1330|
000532  2000              MOVS     r0,#0                 ;2124
000534  61e0              STR      r0,[r4,#0x1c]         ;2124  ; xYieldPending
000536  6820              LDR      r0,[r4,#0]            ;2155  ; pxCurrentTCB
000538  6821              LDR      r1,[r4,#0]            ;2155  ; pxCurrentTCB
00053a  6800              LDR      r0,[r0,#0]            ;2155
00053c  6b09              LDR      r1,[r1,#0x30]         ;2155
00053e  4288              CMP      r0,r1                 ;2155
000540  d804              BHI      |L1.1356|
000542  6821              LDR      r1,[r4,#0]            ;2155  ; pxCurrentTCB
000544  6820              LDR      r0,[r4,#0]            ;2155  ; pxCurrentTCB
000546  3134              ADDS     r1,r1,#0x34           ;2155
000548  f7fffffe          BL       vApplicationStackOverflowHook
                  |L1.1356|
00054c  6820              LDR      r0,[r4,#0]            ;2156  ; pxCurrentTCB
00054e  2214              MOVS     r2,#0x14              ;2156
000550  49dc              LDR      r1,|L1.2244|
000552  6b00              LDR      r0,[r0,#0x30]         ;2156
000554  f7fffffe          BL       memcmp
000558  b120              CBZ      r0,|L1.1380|
00055a  6821              LDR      r1,[r4,#0]            ;2156  ; pxCurrentTCB
00055c  6820              LDR      r0,[r4,#0]            ;2156  ; pxCurrentTCB
00055e  3134              ADDS     r1,r1,#0x34           ;2156
000560  f7fffffe          BL       vApplicationStackOverflowHook
                  |L1.1380|
000564  6920              LDR      r0,[r4,#0x10]         ;2160  ; uxTopReadyPriority
000566  49d5              LDR      r1,|L1.2236|
000568  fab0f080          CLZ      r0,r0                 ;2160
00056c  f1c0001f          RSB      r0,r0,#0x1f           ;2160
000570  eb000080          ADD      r0,r0,r0,LSL #2       ;2160
000574  f8512020          LDR      r2,[r1,r0,LSL #2]     ;2160
000578  b16a              CBZ      r2,|L1.1430|
00057a  eb010080          ADD      r0,r1,r0,LSL #2       ;2160
00057e  f1000208          ADD      r2,r0,#8              ;2160
000582  6841              LDR      r1,[r0,#4]            ;2160
000584  6849              LDR      r1,[r1,#4]            ;2160
000586  6041              STR      r1,[r0,#4]            ;2160
000588  4291              CMP      r1,r2                 ;2160
00058a  d101              BNE      |L1.1424|
00058c  6849              LDR      r1,[r1,#4]            ;2160
00058e  6041              STR      r1,[r0,#4]            ;2160
                  |L1.1424|
000590  68c8              LDR      r0,[r1,#0xc]          ;2160
000592  6020              STR      r0,[r4,#0]            ;2160  ; pxCurrentTCB
000594  bd10              POP      {r4,pc}
                  |L1.1430|
000596  f7fffffe          BL       ulPortSetInterruptMask
                  |L1.1434|
00059a  e7fe              B        |L1.1434|
;;;2172   /*-----------------------------------------------------------*/
                          ENDP

                  vTaskSuspend PROC
;;;1195   
;;;1196   	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
00059c  b570              PUSH     {r4-r6,lr}
;;;1197   	{
00059e  4604              MOV      r4,r0
;;;1198   	TCB_t *pxTCB;
;;;1199   
;;;1200   		taskENTER_CRITICAL();
0005a0  f7fffffe          BL       vPortEnterCritical
;;;1201   		{
;;;1202   			/* If null is passed in here then it is the running task that is
;;;1203   			being suspended. */
;;;1204   			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
0005a4  4dc6              LDR      r5,|L1.2240|
0005a6  b904              CBNZ     r4,|L1.1450|
0005a8  682c              LDR      r4,[r5,#0]  ; pxCurrentTCB
                  |L1.1450|
;;;1205   
;;;1206   			traceTASK_SUSPEND( pxTCB );
;;;1207   
;;;1208   			/* Remove task from the ready/delayed list and place in the
;;;1209   			suspended list. */
;;;1210   			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
0005aa  1d20              ADDS     r0,r4,#4
0005ac  f7fffffe          BL       uxListRemove
0005b0  b958              CBNZ     r0,|L1.1482|
;;;1211   			{
;;;1212   				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
0005b2  6ae0              LDR      r0,[r4,#0x2c]
0005b4  4ac1              LDR      r2,|L1.2236|
0005b6  eb000180          ADD      r1,r0,r0,LSL #2
0005ba  f8521021          LDR      r1,[r2,r1,LSL #2]
0005be  b921              CBNZ     r1,|L1.1482|
0005c0  2101              MOVS     r1,#1
0005c2  4081              LSLS     r1,r1,r0
0005c4  6928              LDR      r0,[r5,#0x10]  ; uxTopReadyPriority
0005c6  4388              BICS     r0,r0,r1
0005c8  6128              STR      r0,[r5,#0x10]  ; uxTopReadyPriority
                  |L1.1482|
;;;1213   			}
;;;1214   			else
;;;1215   			{
;;;1216   				mtCOVERAGE_TEST_MARKER();
;;;1217   			}
;;;1218   
;;;1219   			/* Is the task waiting on an event also? */
;;;1220   			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
0005ca  6aa0              LDR      r0,[r4,#0x28]
0005cc  b118              CBZ      r0,|L1.1494|
;;;1221   			{
;;;1222   				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
0005ce  f1040018          ADD      r0,r4,#0x18
0005d2  f7fffffe          BL       uxListRemove
                  |L1.1494|
;;;1223   			}
;;;1224   			else
;;;1225   			{
;;;1226   				mtCOVERAGE_TEST_MARKER();
;;;1227   			}
;;;1228   
;;;1229   			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
0005d6  48b9              LDR      r0,|L1.2236|
0005d8  1d21              ADDS     r1,r4,#4
0005da  30b4              ADDS     r0,r0,#0xb4
0005dc  f7fffffe          BL       vListInsertEnd
;;;1230   		}
;;;1231   		taskEXIT_CRITICAL();
0005e0  f7fffffe          BL       vPortExitCritical
;;;1232   
;;;1233   		if( pxTCB == pxCurrentTCB )
0005e4  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
0005e6  4284              CMP      r4,r0
;;;1234   		{
;;;1235   			if( xSchedulerRunning != pdFALSE )
;;;1236   			{
;;;1237   				/* The current task has just been suspended. */
;;;1238   				configASSERT( uxSchedulerSuspended == 0 );
;;;1239   				portYIELD_WITHIN_API();
;;;1240   			}
;;;1241   			else
;;;1242   			{
;;;1243   				/* The scheduler is not running, but the task that was pointed
;;;1244   				to by pxCurrentTCB has just been suspended and pxCurrentTCB
;;;1245   				must be adjusted to point to a different task. */
;;;1246   				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
;;;1247   				{
;;;1248   					/* No other tasks are ready, so set pxCurrentTCB back to
;;;1249   					NULL so when the next task is created pxCurrentTCB will
;;;1250   					be set to point to it no matter what its relative priority
;;;1251   					is. */
;;;1252   					pxCurrentTCB = NULL;
;;;1253   				}
;;;1254   				else
;;;1255   				{
;;;1256   					vTaskSwitchContext();
;;;1257   				}
;;;1258   			}
;;;1259   		}
;;;1260   		else
;;;1261   		{
;;;1262   			if( xSchedulerRunning != pdFALSE )
0005e8  6968              LDR      r0,[r5,#0x14]  ; xSchedulerRunning
0005ea  d115              BNE      |L1.1560|
0005ec  b140              CBZ      r0,|L1.1536|
0005ee  6ae8              LDR      r0,[r5,#0x2c]         ;1238  ; uxSchedulerSuspended
0005f0  b110              CBZ      r0,|L1.1528|
0005f2  f7fffffe          BL       ulPortSetInterruptMask
                  |L1.1526|
0005f6  e7fe              B        |L1.1526|
                  |L1.1528|
0005f8  e8bd4070          POP      {r4-r6,lr}            ;1239
0005fc  f7ffbffe          B.W      vPortYield
                  |L1.1536|
000600  48ae              LDR      r0,|L1.2236|
000602  68a9              LDR      r1,[r5,#8]            ;1246  ; uxCurrentNumberOfTasks
000604  30b4              ADDS     r0,r0,#0xb4           ;1246
000606  6800              LDR      r0,[r0,#0]            ;1246  ; xSuspendedTaskList
000608  4288              CMP      r0,r1                 ;1246
00060a  d102              BNE      |L1.1554|
00060c  2000              MOVS     r0,#0                 ;1252
00060e  6028              STR      r0,[r5,#0]            ;1252  ; pxCurrentTCB
                  |L1.1552|
;;;1263   			{
;;;1264   				/* A task other than the currently running task was suspended,
;;;1265   				reset the next expected unblock time in case it referred to the
;;;1266   				task that is now in the Suspended state. */
;;;1267   				taskENTER_CRITICAL();
;;;1268   				{
;;;1269   					prvResetNextTaskUnblockTime();
;;;1270   				}
;;;1271   				taskEXIT_CRITICAL();
;;;1272   			}
;;;1273   			else
;;;1274   			{
;;;1275   				mtCOVERAGE_TEST_MARKER();
;;;1276   			}
;;;1277   		}
;;;1278   	}
000610  bd70              POP      {r4-r6,pc}
                  |L1.1554|
000612  e8bd4070          POP      {r4-r6,lr}            ;1256
000616  e7fe              B        vTaskSwitchContext
                  |L1.1560|
000618  2800              CMP      r0,#0                 ;1262
00061a  d0f9              BEQ      |L1.1552|
00061c  f7fffffe          BL       vPortEnterCritical
000620  f7fffffe          BL       prvResetNextTaskUnblockTime
000624  e8bd4070          POP      {r4-r6,lr}            ;1271
000628  f7ffbffe          B.W      vPortExitCritical
;;;1279   
                          ENDP

                  vTaskResume PROC
;;;1330   
;;;1331   	void vTaskResume( TaskHandle_t xTaskToResume )
00062c  b570              PUSH     {r4-r6,lr}
;;;1332   	{
;;;1333   	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
00062e  0004              MOVS     r4,r0
000630  d00b              BEQ      |L1.1610|
;;;1334   
;;;1335   		/* It does not make sense to resume the calling task. */
;;;1336   		configASSERT( xTaskToResume );
;;;1337   
;;;1338   		/* The parameter cannot be NULL as it is impossible to resume the
;;;1339   		currently executing task. */
;;;1340   		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
000632  4da3              LDR      r5,|L1.2240|
000634  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
000636  4284              CMP      r4,r0
000638  d026              BEQ      |L1.1672|
;;;1341   		{
;;;1342   			taskENTER_CRITICAL();
00063a  f7fffffe          BL       vPortEnterCritical
;;;1343   			{
;;;1344   				if( prvTaskIsTaskSuspended( pxTCB ) == pdTRUE )
00063e  4620              MOV      r0,r4
000640  f7fffffe          BL       prvTaskIsTaskSuspended
000644  2801              CMP      r0,#1
000646  d003              BEQ      |L1.1616|
000648  e01a              B        |L1.1664|
                  |L1.1610|
00064a  f7fffffe          BL       ulPortSetInterruptMask
                  |L1.1614|
00064e  e7fe              B        |L1.1614|
                  |L1.1616|
;;;1345   				{
;;;1346   					traceTASK_RESUME( pxTCB );
;;;1347   
;;;1348   					/* As we are in a critical section we can access the ready
;;;1349   					lists even if the scheduler is suspended. */
;;;1350   					( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
000650  1d20              ADDS     r0,r4,#4
000652  f7fffffe          BL       uxListRemove
;;;1351   					prvAddTaskToReadyList( pxTCB );
000656  6ae0              LDR      r0,[r4,#0x2c]
000658  2101              MOVS     r1,#1
00065a  692a              LDR      r2,[r5,#0x10]  ; uxTopReadyPriority
00065c  4081              LSLS     r1,r1,r0
00065e  4311              ORRS     r1,r1,r2
000660  6129              STR      r1,[r5,#0x10]  ; uxTopReadyPriority
000662  4996              LDR      r1,|L1.2236|
000664  eb000080          ADD      r0,r0,r0,LSL #2
000668  eb010080          ADD      r0,r1,r0,LSL #2
00066c  1d21              ADDS     r1,r4,#4
00066e  f7fffffe          BL       vListInsertEnd
;;;1352   
;;;1353   					/* We may have just resumed a higher priority task. */
;;;1354   					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
000672  6ae0              LDR      r0,[r4,#0x2c]
000674  6829              LDR      r1,[r5,#0]  ; pxCurrentTCB
000676  6ac9              LDR      r1,[r1,#0x2c]
000678  4288              CMP      r0,r1
00067a  d301              BCC      |L1.1664|
;;;1355   					{
;;;1356   						/* This yield may not cause the task just resumed to run,
;;;1357   						but will leave the lists in the correct state for the
;;;1358   						next yield. */
;;;1359   						taskYIELD_IF_USING_PREEMPTION();
00067c  f7fffffe          BL       vPortYield
                  |L1.1664|
;;;1360   					}
;;;1361   					else
;;;1362   					{
;;;1363   						mtCOVERAGE_TEST_MARKER();
;;;1364   					}
;;;1365   				}
;;;1366   				else
;;;1367   				{
;;;1368   					mtCOVERAGE_TEST_MARKER();
;;;1369   				}
;;;1370   			}
;;;1371   			taskEXIT_CRITICAL();
000680  e8bd4070          POP      {r4-r6,lr}
000684  f7ffbffe          B.W      vPortExitCritical
                  |L1.1672|
;;;1372   		}
;;;1373   		else
;;;1374   		{
;;;1375   			mtCOVERAGE_TEST_MARKER();
;;;1376   		}
;;;1377   	}
000688  bd70              POP      {r4-r6,pc}
;;;1378   
                          ENDP

                  xTaskResumeFromISR PROC
;;;1384   
;;;1385   	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
00068a  e92d41f0          PUSH     {r4-r8,lr}
;;;1386   	{
;;;1387   	BaseType_t xYieldRequired = pdFALSE;
00068e  2600              MOVS     r6,#0
;;;1388   	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
000690  0004              MOVS     r4,r0
000692  d00a              BEQ      |L1.1706|
;;;1389   	UBaseType_t uxSavedInterruptStatus;
;;;1390   
;;;1391   		configASSERT( xTaskToResume );
;;;1392   
;;;1393   		/* RTOS ports that support interrupt nesting have the concept of a
;;;1394   		maximum	system call (or maximum API call) interrupt priority.
;;;1395   		Interrupts that are	above the maximum system call priority are keep
;;;1396   		permanently enabled, even when the RTOS kernel is in a critical section,
;;;1397   		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
;;;1398   		is defined in FreeRTOSConfig.h then
;;;1399   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1400   		failure if a FreeRTOS API function is called from an interrupt that has
;;;1401   		been assigned a priority above the configured maximum system call
;;;1402   		priority.  Only FreeRTOS functions that end in FromISR can be called
;;;1403   		from interrupts	that have been assigned a priority at or (logically)
;;;1404   		below the maximum system call interrupt priority.  FreeRTOS maintains a
;;;1405   		separate interrupt safe API to ensure interrupt entry is as fast and as
;;;1406   		simple as possible.  More information (albeit Cortex-M specific) is
;;;1407   		provided on the following link:
;;;1408   		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1409   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
000694  f7fffffe          BL       vPortValidateInterruptPriority
;;;1410   
;;;1411   		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
000698  f7fffffe          BL       ulPortSetInterruptMask
00069c  4607              MOV      r7,r0
;;;1412   		{
;;;1413   			if( prvTaskIsTaskSuspended( pxTCB ) == pdTRUE )
00069e  4620              MOV      r0,r4
0006a0  f7fffffe          BL       prvTaskIsTaskSuspended
0006a4  2801              CMP      r0,#1
0006a6  d003              BEQ      |L1.1712|
0006a8  e021              B        |L1.1774|
                  |L1.1706|
0006aa  f7fffffe          BL       ulPortSetInterruptMask
                  |L1.1710|
0006ae  e7fe              B        |L1.1710|
                  |L1.1712|
;;;1414   			{
;;;1415   				traceTASK_RESUME_FROM_ISR( pxTCB );
;;;1416   
;;;1417   				/* Check the ready lists can be accessed. */
;;;1418   				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
0006b0  4d83              LDR      r5,|L1.2240|
0006b2  6ae8              LDR      r0,[r5,#0x2c]  ; uxSchedulerSuspended
0006b4  b120              CBZ      r0,|L1.1728|
;;;1419   				{
;;;1420   					/* Ready lists can be accessed so move the task from the
;;;1421   					suspended list to the ready list directly. */
;;;1422   					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
;;;1423   					{
;;;1424   						xYieldRequired = pdTRUE;
;;;1425   					}
;;;1426   					else
;;;1427   					{
;;;1428   						mtCOVERAGE_TEST_MARKER();
;;;1429   					}
;;;1430   
;;;1431   					( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
;;;1432   					prvAddTaskToReadyList( pxTCB );
;;;1433   				}
;;;1434   				else
;;;1435   				{
;;;1436   					/* The delayed or ready lists cannot be accessed so the task
;;;1437   					is held in the pending ready list until the scheduler is
;;;1438   					unsuspended. */
;;;1439   					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
0006b6  4881              LDR      r0,|L1.2236|
0006b8  f1040118          ADD      r1,r4,#0x18
0006bc  308c              ADDS     r0,r0,#0x8c
0006be  e014              B        |L1.1770|
                  |L1.1728|
0006c0  6ae0              LDR      r0,[r4,#0x2c]         ;1422
0006c2  6829              LDR      r1,[r5,#0]            ;1422  ; pxCurrentTCB
0006c4  6ac9              LDR      r1,[r1,#0x2c]         ;1422
0006c6  4288              CMP      r0,r1                 ;1422
0006c8  d300              BCC      |L1.1740|
0006ca  2601              MOVS     r6,#1                 ;1424
                  |L1.1740|
0006cc  1d20              ADDS     r0,r4,#4              ;1431
0006ce  f7fffffe          BL       uxListRemove
0006d2  6ae1              LDR      r1,[r4,#0x2c]         ;1432
0006d4  2001              MOVS     r0,#1                 ;1432
0006d6  692a              LDR      r2,[r5,#0x10]         ;1432  ; uxTopReadyPriority
0006d8  4088              LSLS     r0,r0,r1              ;1432
0006da  4310              ORRS     r0,r0,r2              ;1432
0006dc  6128              STR      r0,[r5,#0x10]         ;1432  ; uxTopReadyPriority
0006de  eb010081          ADD      r0,r1,r1,LSL #2       ;1432
0006e2  4976              LDR      r1,|L1.2236|
0006e4  eb010080          ADD      r0,r1,r0,LSL #2       ;1432
0006e8  1d21              ADDS     r1,r4,#4              ;1432
                  |L1.1770|
0006ea  f7fffffe          BL       vListInsertEnd
                  |L1.1774|
;;;1440   				}
;;;1441   			}
;;;1442   			else
;;;1443   			{
;;;1444   				mtCOVERAGE_TEST_MARKER();
;;;1445   			}
;;;1446   		}
;;;1447   		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
0006ee  4638              MOV      r0,r7
0006f0  f7fffffe          BL       vPortClearInterruptMask
;;;1448   
;;;1449   		return xYieldRequired;
0006f4  4630              MOV      r0,r6
;;;1450   	}
0006f6  e5e1              B        |L1.700|
;;;1451   
                          ENDP

                  prvIdleTask PROC
;;;2554    */
;;;2555   static portTASK_FUNCTION( prvIdleTask, pvParameters )
0006f8  4c70              LDR      r4,|L1.2236|
;;;2556   {
;;;2557   	/* Stop warnings. */
;;;2558   	( void ) pvParameters;
;;;2559   
;;;2560   	for( ;; )
;;;2561   	{
;;;2562   		/* See if any tasks have been deleted. */
;;;2563   		prvCheckTasksWaitingTermination();
0006fa  bf00              NOP      
                  |L1.1788|
0006fc  f7fffffe          BL       prvCheckTasksWaitingTermination
;;;2564   
;;;2565   		#if ( configUSE_PREEMPTION == 0 )
;;;2566   		{
;;;2567   			/* If we are not using preemption we keep forcing a task switch to
;;;2568   			see if any other task has become available.  If we are using
;;;2569   			preemption we don't need to do this as any task becoming available
;;;2570   			will automatically get the processor anyway. */
;;;2571   			taskYIELD();
;;;2572   		}
;;;2573   		#endif /* configUSE_PREEMPTION */
;;;2574   
;;;2575   		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
;;;2576   		{
;;;2577   			/* When using preemption tasks of equal priority will be
;;;2578   			timesliced.  If a task that is sharing the idle priority is ready
;;;2579   			to run then the idle task should yield before the end of the
;;;2580   			timeslice.
;;;2581   
;;;2582   			A critical region is not required here as we are just reading from
;;;2583   			the list, and an occasional incorrect value will not matter.  If
;;;2584   			the ready list at the idle priority contains more than one task
;;;2585   			then a task other than the idle task is ready to execute. */
;;;2586   			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
000700  6820              LDR      r0,[r4,#0]  ; pxReadyTasksLists
000702  2801              CMP      r0,#1
000704  d901              BLS      |L1.1802|
;;;2587   			{
;;;2588   				taskYIELD();
000706  f7fffffe          BL       vPortYield
                  |L1.1802|
;;;2589   			}
;;;2590   			else
;;;2591   			{
;;;2592   				mtCOVERAGE_TEST_MARKER();
;;;2593   			}
;;;2594   		}
;;;2595   		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) ) */
;;;2596   
;;;2597   		#if ( configUSE_IDLE_HOOK == 1 )
;;;2598   		{
;;;2599   			extern void vApplicationIdleHook( void );
;;;2600   
;;;2601   			/* Call the user defined function from within the idle task.  This
;;;2602   			allows the application designer to add background functionality
;;;2603   			without the overhead of a separate task.
;;;2604   			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
;;;2605   			CALL A FUNCTION THAT MIGHT BLOCK. */
;;;2606   			vApplicationIdleHook();
00070a  f7fffffe          BL       vApplicationIdleHook
00070e  e7f5              B        |L1.1788|
;;;2607   		}
;;;2608   		#endif /* configUSE_IDLE_HOOK */
;;;2609   
;;;2610   		/* This conditional compilation should use inequality to 0, not equality
;;;2611   		to 1.  This is to ensure portSUPPRESS_TICKS_AND_SLEEP() is called when
;;;2612   		user defined low power mode	implementations require
;;;2613   		configUSE_TICKLESS_IDLE to be set to a value other than 1. */
;;;2614   		#if ( configUSE_TICKLESS_IDLE != 0 )
;;;2615   		{
;;;2616   		TickType_t xExpectedIdleTime;
;;;2617   
;;;2618   			/* It is not desirable to suspend then resume the scheduler on
;;;2619   			each iteration of the idle task.  Therefore, a preliminary
;;;2620   			test of the expected idle time is performed without the
;;;2621   			scheduler suspended.  The result here is not necessarily
;;;2622   			valid. */
;;;2623   			xExpectedIdleTime = prvGetExpectedIdleTime();
;;;2624   
;;;2625   			if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
;;;2626   			{
;;;2627   				vTaskSuspendAll();
;;;2628   				{
;;;2629   					/* Now the scheduler is suspended, the expected idle
;;;2630   					time can be sampled again, and this time its value can
;;;2631   					be used. */
;;;2632   					configASSERT( xNextTaskUnblockTime >= xTickCount );
;;;2633   					xExpectedIdleTime = prvGetExpectedIdleTime();
;;;2634   
;;;2635   					if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
;;;2636   					{
;;;2637   						traceLOW_POWER_IDLE_BEGIN();
;;;2638   						portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
;;;2639   						traceLOW_POWER_IDLE_END();
;;;2640   					}
;;;2641   					else
;;;2642   					{
;;;2643   						mtCOVERAGE_TEST_MARKER();
;;;2644   					}
;;;2645   				}
;;;2646   				( void ) xTaskResumeAll();
;;;2647   			}
;;;2648   			else
;;;2649   			{
;;;2650   				mtCOVERAGE_TEST_MARKER();
;;;2651   			}
;;;2652   		}
;;;2653   		#endif /* configUSE_TICKLESS_IDLE */
;;;2654   	}
;;;2655   }
;;;2656   /*-----------------------------------------------------------*/
                          ENDP

                  vTaskStartScheduler PROC
;;;1454   
;;;1455   void vTaskStartScheduler( void )
000710  b51f              PUSH     {r0-r4,lr}
;;;1456   {
;;;1457   BaseType_t xReturn;
;;;1458   
;;;1459   	/* Add the idle task at the lowest priority. */
;;;1460   	#if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
;;;1461   	{
;;;1462   		/* Create the idle task, storing its handle in xIdleTaskHandle so it can
;;;1463   		be returned by the xTaskGetIdleTaskHandle() function. */
;;;1464   		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
;;;1465   	}
;;;1466   	#else
;;;1467   	{
;;;1468   		/* Create the idle task without storing its handle. */
;;;1469   		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
000712  2400              MOVS     r4,#0
000714  9400              STR      r4,[sp,#0]
000716  9401              STR      r4,[sp,#4]
000718  9402              STR      r4,[sp,#8]
00071a  4623              MOV      r3,r4
00071c  2246              MOVS     r2,#0x46
00071e  a16a              ADR      r1,|L1.2248|
000720  486b              LDR      r0,|L1.2256|
000722  9403              STR      r4,[sp,#0xc]
000724  f7fffffe          BL       xTaskGenericCreate
;;;1470   	}
;;;1471   	#endif /* INCLUDE_xTaskGetIdleTaskHandle */
;;;1472   
;;;1473   	#if ( configUSE_TIMERS == 1 )
;;;1474   	{
;;;1475   		if( xReturn == pdPASS )
000728  2801              CMP      r0,#1
00072a  d103              BNE      |L1.1844|
;;;1476   		{
;;;1477   			xReturn = xTimerCreateTimerTask();
00072c  f7fffffe          BL       xTimerCreateTimerTask
;;;1478   		}
;;;1479   		else
;;;1480   		{
;;;1481   			mtCOVERAGE_TEST_MARKER();
;;;1482   		}
;;;1483   	}
;;;1484   	#endif /* configUSE_TIMERS */
;;;1485   
;;;1486   	if( xReturn == pdPASS )
000730  2801              CMP      r0,#1
000732  d004              BEQ      |L1.1854|
                  |L1.1844|
;;;1487   	{
;;;1488   		/* Interrupts are turned off here, to ensure a tick does not occur
;;;1489   		before or during the call to xPortStartScheduler().  The stacks of
;;;1490   		the created tasks contain a status word with interrupts switched on
;;;1491   		so interrupts will automatically get re-enabled when the first task
;;;1492   		starts to run. */
;;;1493   		portDISABLE_INTERRUPTS();
;;;1494   
;;;1495   		#if ( configUSE_NEWLIB_REENTRANT == 1 )
;;;1496   		{
;;;1497   			/* Switch Newlib's _impure_ptr variable to point to the _reent
;;;1498   			structure specific to the task that will run first. */
;;;1499   			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
;;;1500   		}
;;;1501   		#endif /* configUSE_NEWLIB_REENTRANT */
;;;1502   
;;;1503   		xSchedulerRunning = pdTRUE;
;;;1504   		xTickCount = ( TickType_t ) 0U;
;;;1505   
;;;1506   		/* If configGENERATE_RUN_TIME_STATS is defined then the following
;;;1507   		macro must be defined to configure the timer/counter used to generate
;;;1508   		the run time counter time base. */
;;;1509   		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
;;;1510   
;;;1511   		/* Setting up the timer tick is hardware specific and thus in the
;;;1512   		portable interface. */
;;;1513   		if( xPortStartScheduler() != pdFALSE )
;;;1514   		{
;;;1515   			/* Should not reach here as if the scheduler is running the
;;;1516   			function will not return. */
;;;1517   		}
;;;1518   		else
;;;1519   		{
;;;1520   			/* Should only reach here if a task calls xTaskEndScheduler(). */
;;;1521   		}
;;;1522   	}
;;;1523   	else
;;;1524   	{
;;;1525   		/* This line will only be reached if the kernel could not be started,
;;;1526   		because there was not enough FreeRTOS heap to create the idle task
;;;1527   		or the timer task. */
;;;1528   		configASSERT( xReturn );
000734  2800              CMP      r0,#0
000736  d10c              BNE      |L1.1874|
000738  f7fffffe          BL       ulPortSetInterruptMask
                  |L1.1852|
00073c  e7fe              B        |L1.1852|
                  |L1.1854|
00073e  f7fffffe          BL       ulPortSetInterruptMask
000742  485f              LDR      r0,|L1.2240|
000744  2101              MOVS     r1,#1                 ;1503
000746  6141              STR      r1,[r0,#0x14]         ;1503  ; xSchedulerRunning
000748  60c4              STR      r4,[r0,#0xc]          ;1504  ; xTickCount
00074a  e8bd401f          POP      {r0-r4,lr}            ;1513
00074e  f7ffbffe          B.W      xPortStartScheduler
                  |L1.1874|
;;;1529   	}
;;;1530   }
000752  bd1f              POP      {r0-r4,pc}
;;;1531   /*-----------------------------------------------------------*/
                          ENDP

                  vTaskEndScheduler PROC
;;;1532   
;;;1533   void vTaskEndScheduler( void )
000754  b510              PUSH     {r4,lr}
;;;1534   {
;;;1535   	/* Stop the scheduler interrupts and call the portable scheduler end
;;;1536   	routine so the original ISRs can be restored if necessary.  The port
;;;1537   	layer must ensure interrupts enable	bit is left in the correct state. */
;;;1538   	portDISABLE_INTERRUPTS();
000756  f7fffffe          BL       ulPortSetInterruptMask
;;;1539   	xSchedulerRunning = pdFALSE;
00075a  4959              LDR      r1,|L1.2240|
00075c  2000              MOVS     r0,#0
00075e  6148              STR      r0,[r1,#0x14]  ; xSchedulerRunning
;;;1540   	vPortEndScheduler();
000760  e8bd4010          POP      {r4,lr}
000764  f7ffbffe          B.W      vPortEndScheduler
;;;1541   }
;;;1542   /*----------------------------------------------------------*/
                          ENDP

                  xTaskGetTickCount PROC
;;;1674   
;;;1675   TickType_t xTaskGetTickCount( void )
000768  b510              PUSH     {r4,lr}
;;;1676   {
;;;1677   TickType_t xTicks;
;;;1678   
;;;1679   	/* Critical section required if running on a 16 bit processor. */
;;;1680   	taskENTER_CRITICAL();
00076a  f7fffffe          BL       vPortEnterCritical
;;;1681   	{
;;;1682   		xTicks = xTickCount;
00076e  4854              LDR      r0,|L1.2240|
000770  68c4              LDR      r4,[r0,#0xc]  ; xTickCount
;;;1683   	}
;;;1684   	taskEXIT_CRITICAL();
000772  f7fffffe          BL       vPortExitCritical
;;;1685   
;;;1686   	return xTicks;
000776  4620              MOV      r0,r4
;;;1687   }
000778  bd10              POP      {r4,pc}
;;;1688   /*-----------------------------------------------------------*/
                          ENDP

                  xTaskGetTickCountFromISR PROC
;;;1689   
;;;1690   TickType_t xTaskGetTickCountFromISR( void )
00077a  b510              PUSH     {r4,lr}
;;;1691   {
;;;1692   TickType_t xReturn;
;;;1693   UBaseType_t uxSavedInterruptStatus;
;;;1694   
;;;1695   	/* RTOS ports that support interrupt nesting have the concept of a maximum
;;;1696   	system call (or maximum API call) interrupt priority.  Interrupts that are
;;;1697   	above the maximum system call priority are kept permanently enabled, even
;;;1698   	when the RTOS kernel is in a critical section, but cannot make any calls to
;;;1699   	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
;;;1700   	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1701   	failure if a FreeRTOS API function is called from an interrupt that has been
;;;1702   	assigned a priority above the configured maximum system call priority.
;;;1703   	Only FreeRTOS functions that end in FromISR can be called from interrupts
;;;1704   	that have been assigned a priority at or (logically) below the maximum
;;;1705   	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
;;;1706   	safe API to ensure interrupt entry is as fast and as simple as possible.
;;;1707   	More information (albeit Cortex-M specific) is provided on the following
;;;1708   	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1709   	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
00077c  f7fffffe          BL       vPortValidateInterruptPriority
;;;1710   
;;;1711   	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
000780  f7fffffe          BL       ulPortSetInterruptMask
;;;1712   	{
;;;1713   		xReturn = xTickCount;
000784  494e              LDR      r1,|L1.2240|
000786  68cc              LDR      r4,[r1,#0xc]  ; xTickCount
;;;1714   	}
;;;1715   	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
000788  f7fffffe          BL       vPortClearInterruptMask
;;;1716   
;;;1717   	return xReturn;
00078c  4620              MOV      r0,r4
;;;1718   }
00078e  bd10              POP      {r4,pc}
;;;1719   /*-----------------------------------------------------------*/
                          ENDP

                  uxTaskGetNumberOfTasks PROC
;;;1720   
;;;1721   UBaseType_t uxTaskGetNumberOfTasks( void )
000790  484b              LDR      r0,|L1.2240|
;;;1722   {
;;;1723   	/* A critical section is not required because the variables are of type
;;;1724   	BaseType_t. */
;;;1725   	return uxCurrentNumberOfTasks;
000792  6880              LDR      r0,[r0,#8]  ; uxCurrentNumberOfTasks
;;;1726   }
000794  4770              BX       lr
;;;1727   /*-----------------------------------------------------------*/
                          ENDP

                  vTaskPlaceOnEventList PROC
;;;2173   
;;;2174   void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
000796  b570              PUSH     {r4-r6,lr}
;;;2175   {
000798  460d              MOV      r5,r1
00079a  b150              CBZ      r0,|L1.1970|
;;;2176   TickType_t xTimeToWake;
;;;2177   
;;;2178   	configASSERT( pxEventList );
;;;2179   
;;;2180   	/* THIS FUNCTION MUST BE CALLED WITH EITHER INTERRUPTS DISABLED OR THE
;;;2181   	SCHEDULER SUSPENDED AND THE QUEUE BEING ACCESSED LOCKED. */
;;;2182   
;;;2183   	/* Place the event list item of the TCB in the appropriate event list.
;;;2184   	This is placed in the list in priority order so the highest priority task
;;;2185   	is the first to be woken by the event.  The queue that contains the event
;;;2186   	list is locked, preventing simultaneous access from interrupts. */
;;;2187   	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
00079c  4c48              LDR      r4,|L1.2240|
00079e  6821              LDR      r1,[r4,#0]  ; pxCurrentTCB
0007a0  3118              ADDS     r1,r1,#0x18
0007a2  f7fffffe          BL       vListInsert
;;;2188   
;;;2189   	/* The task must be removed from from the ready list before it is added to
;;;2190   	the blocked list as the same list item is used for both lists.  Exclusive
;;;2191   	access to the ready lists guaranteed because the scheduler is locked. */
;;;2192   	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
0007a6  6820              LDR      r0,[r4,#0]  ; pxCurrentTCB
0007a8  1d00              ADDS     r0,r0,#4
0007aa  f7fffffe          BL       uxListRemove
0007ae  b118              CBZ      r0,|L1.1976|
0007b0  e00a              B        |L1.1992|
                  |L1.1970|
0007b2  f7fffffe          BL       ulPortSetInterruptMask
                  |L1.1974|
0007b6  e7fe              B        |L1.1974|
                  |L1.1976|
;;;2193   	{
;;;2194   		/* The current task must be in a ready list, so there is no need to
;;;2195   		check, and the port reset macro can be called directly. */
;;;2196   		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
0007b8  6820              LDR      r0,[r4,#0]  ; pxCurrentTCB
0007ba  f890102c          LDRB     r1,[r0,#0x2c]
0007be  2001              MOVS     r0,#1
0007c0  4088              LSLS     r0,r0,r1
0007c2  6921              LDR      r1,[r4,#0x10]  ; uxTopReadyPriority
0007c4  4381              BICS     r1,r1,r0
0007c6  6121              STR      r1,[r4,#0x10]  ; uxTopReadyPriority
                  |L1.1992|
;;;2197   	}
;;;2198   	else
;;;2199   	{
;;;2200   		mtCOVERAGE_TEST_MARKER();
;;;2201   	}
;;;2202   
;;;2203   	#if ( INCLUDE_vTaskSuspend == 1 )
;;;2204   	{
;;;2205   		if( xTicksToWait == portMAX_DELAY )
0007c8  1c68              ADDS     r0,r5,#1
0007ca  d004              BEQ      |L1.2006|
;;;2206   		{
;;;2207   			/* Add the task to the suspended task list instead of a delayed task
;;;2208   			list to ensure the task is not woken by a timing event.  It will
;;;2209   			block indefinitely. */
;;;2210   			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
;;;2211   		}
;;;2212   		else
;;;2213   		{
;;;2214   			/* Calculate the time at which the task should be woken if the event
;;;2215   			does not occur.  This may overflow but this doesn't matter, the
;;;2216   			scheduler will handle it. */
;;;2217   			xTimeToWake = xTickCount + xTicksToWait;
0007cc  68e0              LDR      r0,[r4,#0xc]  ; xTickCount
0007ce  4428              ADD      r0,r0,r5
;;;2218   			prvAddCurrentTaskToDelayedList( xTimeToWake );
0007d0  e8bd4070          POP      {r4-r6,lr}
0007d4  e7fe              B        prvAddCurrentTaskToDelayedList
                  |L1.2006|
0007d6  6821              LDR      r1,[r4,#0]            ;2210  ; pxCurrentTCB
0007d8  4838              LDR      r0,|L1.2236|
0007da  e8bd4070          POP      {r4-r6,lr}            ;2210
0007de  30b4              ADDS     r0,r0,#0xb4           ;2210
0007e0  1d09              ADDS     r1,r1,#4              ;2210
0007e2  f7ffbffe          B.W      vListInsertEnd
;;;2219   		}
;;;2220   	}
;;;2221   	#else /* INCLUDE_vTaskSuspend */
;;;2222   	{
;;;2223   			/* Calculate the time at which the task should be woken if the event does
;;;2224   			not occur.  This may overflow but this doesn't matter, the scheduler
;;;2225   			will handle it. */
;;;2226   			xTimeToWake = xTickCount + xTicksToWait;
;;;2227   			prvAddCurrentTaskToDelayedList( xTimeToWake );
;;;2228   	}
;;;2229   	#endif /* INCLUDE_vTaskSuspend */
;;;2230   }
;;;2231   /*-----------------------------------------------------------*/
                          ENDP

                  vTaskPlaceOnUnorderedEventList PROC
;;;2232   
;;;2233   void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
0007e6  b570              PUSH     {r4-r6,lr}
;;;2234   {
0007e8  4615              MOV      r5,r2
0007ea  b180              CBZ      r0,|L1.2062|
;;;2235   TickType_t xTimeToWake;
;;;2236   
;;;2237   	configASSERT( pxEventList );
;;;2238   
;;;2239   	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
;;;2240   	the event groups implementation. */
;;;2241   	configASSERT( uxSchedulerSuspended != 0 );
0007ec  4c34              LDR      r4,|L1.2240|
0007ee  6ae2              LDR      r2,[r4,#0x2c]  ; uxSchedulerSuspended
0007f0  b182              CBZ      r2,|L1.2068|
;;;2242   
;;;2243   	/* Store the item value in the event list item.  It is safe to access the
;;;2244   	event list item here as interrupts won't access the event list item of a
;;;2245   	task that is not in the Blocked state. */
;;;2246   	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
0007f2  6822              LDR      r2,[r4,#0]  ; pxCurrentTCB
0007f4  f0414100          ORR      r1,r1,#0x80000000
;;;2247   
;;;2248   	/* Place the event list item of the TCB at the end of the appropriate event
;;;2249   	list.  It is safe to access the event list here because it is part of an
;;;2250   	event group implementation - and interrupts don't access event groups
;;;2251   	directly (instead they access them indirectly by pending function calls to
;;;2252   	the task level). */
;;;2253   	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
0007f8  6191              STR      r1,[r2,#0x18]
0007fa  6821              LDR      r1,[r4,#0]  ; pxCurrentTCB
0007fc  3118              ADDS     r1,r1,#0x18
0007fe  f7fffffe          BL       vListInsertEnd
;;;2254   
;;;2255   	/* The task must be removed from the ready list before it is added to the
;;;2256   	blocked list.  Exclusive access can be assured to the ready list as the
;;;2257   	scheduler is locked. */
;;;2258   	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
000802  6820              LDR      r0,[r4,#0]  ; pxCurrentTCB
000804  1d00              ADDS     r0,r0,#4
000806  f7fffffe          BL       uxListRemove
00080a  b130              CBZ      r0,|L1.2074|
00080c  e00d              B        |L1.2090|
                  |L1.2062|
00080e  f7fffffe          BL       ulPortSetInterruptMask
                  |L1.2066|
000812  e7fe              B        |L1.2066|
                  |L1.2068|
000814  f7fffffe          BL       ulPortSetInterruptMask
                  |L1.2072|
000818  e7fe              B        |L1.2072|
                  |L1.2074|
;;;2259   	{
;;;2260   		/* The current task must be in a ready list, so there is no need to
;;;2261   		check, and the port reset macro can be called directly. */
;;;2262   		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
00081a  6820              LDR      r0,[r4,#0]  ; pxCurrentTCB
00081c  f890102c          LDRB     r1,[r0,#0x2c]
000820  2001              MOVS     r0,#1
000822  4088              LSLS     r0,r0,r1
000824  6921              LDR      r1,[r4,#0x10]  ; uxTopReadyPriority
000826  4381              BICS     r1,r1,r0
000828  6121              STR      r1,[r4,#0x10]  ; uxTopReadyPriority
                  |L1.2090|
;;;2263   	}
;;;2264   	else
;;;2265   	{
;;;2266   		mtCOVERAGE_TEST_MARKER();
;;;2267   	}
;;;2268   
;;;2269   	#if ( INCLUDE_vTaskSuspend == 1 )
;;;2270   	{
;;;2271   		if( xTicksToWait == portMAX_DELAY )
00082a  1c68              ADDS     r0,r5,#1
00082c  d004              BEQ      |L1.2104|
;;;2272   		{
;;;2273   			/* Add the task to the suspended task list instead of a delayed task
;;;2274   			list to ensure it is not woken by a timing event.  It will block
;;;2275   			indefinitely. */
;;;2276   			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
;;;2277   		}
;;;2278   		else
;;;2279   		{
;;;2280   			/* Calculate the time at which the task should be woken if the event
;;;2281   			does not occur.  This may overflow but this doesn't matter, the
;;;2282   			kernel will manage it correctly. */
;;;2283   			xTimeToWake = xTickCount + xTicksToWait;
00082e  68e0              LDR      r0,[r4,#0xc]  ; xTickCount
000830  4428              ADD      r0,r0,r5
;;;2284   			prvAddCurrentTaskToDelayedList( xTimeToWake );
000832  e8bd4070          POP      {r4-r6,lr}
000836  e7fe              B        prvAddCurrentTaskToDelayedList
                  |L1.2104|
000838  6821              LDR      r1,[r4,#0]            ;2276  ; pxCurrentTCB
00083a  4820              LDR      r0,|L1.2236|
00083c  e8bd4070          POP      {r4-r6,lr}            ;2276
000840  30b4              ADDS     r0,r0,#0xb4           ;2276
000842  1d09              ADDS     r1,r1,#4              ;2276
000844  f7ffbffe          B.W      vListInsertEnd
;;;2285   		}
;;;2286   	}
;;;2287   	#else /* INCLUDE_vTaskSuspend */
;;;2288   	{
;;;2289   			/* Calculate the time at which the task should be woken if the event does
;;;2290   			not occur.  This may overflow but this doesn't matter, the kernel
;;;2291   			will manage it correctly. */
;;;2292   			xTimeToWake = xTickCount + xTicksToWait;
;;;2293   			prvAddCurrentTaskToDelayedList( xTimeToWake );
;;;2294   	}
;;;2295   	#endif /* INCLUDE_vTaskSuspend */
;;;2296   }
;;;2297   /*-----------------------------------------------------------*/
                          ENDP

                  vTaskPlaceOnEventListRestricted PROC
;;;2300   
;;;2301   	void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, const TickType_t xTicksToWait )
000848  b570              PUSH     {r4-r6,lr}
;;;2302   	{
00084a  460d              MOV      r5,r1
00084c  b150              CBZ      r0,|L1.2148|
;;;2303   	TickType_t xTimeToWake;
;;;2304   
;;;2305   		configASSERT( pxEventList );
;;;2306   
;;;2307   		/* This function should not be called by application code hence the
;;;2308   		'Restricted' in its name.  It is not part of the public API.  It is
;;;2309   		designed for use by kernel code, and has special calling requirements -
;;;2310   		it should be called from a critical section. */
;;;2311   
;;;2312   
;;;2313   		/* Place the event list item of the TCB in the appropriate event list.
;;;2314   		In this case it is assume that this is the only task that is going to
;;;2315   		be waiting on this event list, so the faster vListInsertEnd() function
;;;2316   		can be used in place of vListInsert. */
;;;2317   		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
00084e  4c1c              LDR      r4,|L1.2240|
000850  6821              LDR      r1,[r4,#0]  ; pxCurrentTCB
000852  3118              ADDS     r1,r1,#0x18
000854  f7fffffe          BL       vListInsertEnd
;;;2318   
;;;2319   		/* We must remove this task from the ready list before adding it to the
;;;2320   		blocked list as the same list item is used for both lists.  This
;;;2321   		function is called form a critical section. */
;;;2322   		if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
000858  6820              LDR      r0,[r4,#0]  ; pxCurrentTCB
00085a  1d00              ADDS     r0,r0,#4
00085c  f7fffffe          BL       uxListRemove
000860  b118              CBZ      r0,|L1.2154|
000862  e00a              B        |L1.2170|
                  |L1.2148|
000864  f7fffffe          BL       ulPortSetInterruptMask
                  |L1.2152|
000868  e7fe              B        |L1.2152|
                  |L1.2154|
;;;2323   		{
;;;2324   			/* The current task must be in a ready list, so there is no need to
;;;2325   			check, and the port reset macro can be called directly. */
;;;2326   			portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
00086a  6820              LDR      r0,[r4,#0]  ; pxCurrentTCB
00086c  f890102c          LDRB     r1,[r0,#0x2c]
000870  2001              MOVS     r0,#1
000872  4088              LSLS     r0,r0,r1
000874  6921              LDR      r1,[r4,#0x10]  ; uxTopReadyPriority
000876  4381              BICS     r1,r1,r0
000878  6121              STR      r1,[r4,#0x10]  ; uxTopReadyPriority
                  |L1.2170|
;;;2327   		}
;;;2328   		else
;;;2329   		{
;;;2330   			mtCOVERAGE_TEST_MARKER();
;;;2331   		}
;;;2332   
;;;2333   		/* Calculate the time at which the task should be woken if the event does
;;;2334   		not occur.  This may overflow but this doesn't matter. */
;;;2335   		xTimeToWake = xTickCount + xTicksToWait;
00087a  68e0              LDR      r0,[r4,#0xc]  ; xTickCount
00087c  4428              ADD      r0,r0,r5
;;;2336   
;;;2337   		traceTASK_DELAY_UNTIL();
;;;2338   		prvAddCurrentTaskToDelayedList( xTimeToWake );
00087e  e8bd4070          POP      {r4-r6,lr}
000882  e7fe              B        prvAddCurrentTaskToDelayedList
;;;2339   	}
;;;2340   
                          ENDP

                  xTaskRemoveFromEventList PROC
;;;2343   
;;;2344   BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
000884  e92d41f0          PUSH     {r4-r8,lr}
;;;2345   {
;;;2346   TCB_t *pxUnblockedTCB;
;;;2347   BaseType_t xReturn;
;;;2348   
;;;2349   	/* THIS FUNCTION MUST BE CALLED FROM A CRITICAL SECTION.  It can also be
;;;2350   	called from a critical section within an ISR. */
;;;2351   
;;;2352   	/* The event list is sorted in priority order, so the first in the list can
;;;2353   	be removed as it is known to be the highest priority.  Remove the TCB from
;;;2354   	the delayed list, and add it to the ready list.
;;;2355   
;;;2356   	If an event is for a queue that is locked then this function will never
;;;2357   	get called - the lock count on the queue will get modified instead.  This
;;;2358   	means exclusive access to the event list is guaranteed here.
;;;2359   
;;;2360   	This function assumes that a check has already been made to ensure that
;;;2361   	pxEventList is not empty. */
;;;2362   	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
000888  68c0              LDR      r0,[r0,#0xc]
00088a  68c4              LDR      r4,[r0,#0xc]          ;2345
00088c  b314              CBZ      r4,|L1.2260|
;;;2363   	configASSERT( pxUnblockedTCB );
;;;2364   	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
00088e  f1040018          ADD      r0,r4,#0x18
000892  4607              MOV      r7,r0
000894  f7fffffe          BL       uxListRemove
;;;2365   
;;;2366   	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
000898  4d09              LDR      r5,|L1.2240|
00089a  6ae8              LDR      r0,[r5,#0x2c]  ; uxSchedulerSuspended
;;;2367   	{
;;;2368   		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
;;;2369   		prvAddTaskToReadyList( pxUnblockedTCB );
00089c  2601              MOVS     r6,#1
00089e  b1e0              CBZ      r0,|L1.2266|
;;;2370   	}
;;;2371   	else
;;;2372   	{
;;;2373   		/* The delayed and ready lists cannot be accessed, so hold this task
;;;2374   		pending until the scheduler is resumed. */
;;;2375   		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
0008a0  4806              LDR      r0,|L1.2236|
0008a2  4639              MOV      r1,r7                 ;2366
0008a4  f110008c          ADDS.W   r0,r0,#0x8c
                  |L1.2216|
0008a8  f7fffffe          BL       vListInsertEnd
;;;2376   	}
;;;2377   
;;;2378   	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
0008ac  6ae0              LDR      r0,[r4,#0x2c]
0008ae  6829              LDR      r1,[r5,#0]  ; pxCurrentTCB
0008b0  6ac9              LDR      r1,[r1,#0x2c]
0008b2  4288              CMP      r0,r1
0008b4  d921              BLS      |L1.2298|
;;;2379   	{
;;;2380   		/* Return true if the task removed from the event list has a higher
;;;2381   		priority than the calling task.  This allows the calling task to know if
;;;2382   		it should force a context switch now. */
;;;2383   		xReturn = pdTRUE;
0008b6  2001              MOVS     r0,#1
;;;2384   
;;;2385   		/* Mark that a yield is pending in case the user is not using the
;;;2386   		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
;;;2387   		xYieldPending = pdTRUE;
0008b8  61ee              STR      r6,[r5,#0x1c]  ; xYieldPending
;;;2388   	}
;;;2389   	else
;;;2390   	{
;;;2391   		xReturn = pdFALSE;
;;;2392   	}
;;;2393   
;;;2394   	return xReturn;
;;;2395   }
0008ba  e4ff              B        |L1.700|
                  |L1.2236|
                          DCD      ||.bss||
                  |L1.2240|
                          DCD      ||.data||
                  |L1.2244|
                          DCD      ||.constdata||
                  |L1.2248|
0008c8  49444c45          DCB      "IDLE",0
0008cc  00      
0008cd  00                DCB      0
0008ce  00                DCB      0
0008cf  00                DCB      0
                  |L1.2256|
                          DCD      prvIdleTask
                  |L1.2260|
0008d4  f7fffffe          BL       ulPortSetInterruptMask
                  |L1.2264|
0008d8  e7fe              B        |L1.2264|
                  |L1.2266|
0008da  1d20              ADDS     r0,r4,#4              ;2368
0008dc  f7fffffe          BL       uxListRemove
0008e0  6ae1              LDR      r1,[r4,#0x2c]         ;2369
0008e2  692a              LDR      r2,[r5,#0x10]         ;2369  ; uxTopReadyPriority
0008e4  fa06f001          LSL      r0,r6,r1              ;2369
0008e8  4310              ORRS     r0,r0,r2              ;2369
0008ea  6128              STR      r0,[r5,#0x10]         ;2369  ; uxTopReadyPriority
0008ec  eb010081          ADD      r0,r1,r1,LSL #2       ;2369
0008f0  49a5              LDR      r1,|L1.2952|
0008f2  eb010080          ADD      r0,r1,r0,LSL #2       ;2369
0008f6  1d21              ADDS     r1,r4,#4              ;2369
0008f8  e7d6              B        |L1.2216|
                  |L1.2298|
0008fa  2000              MOVS     r0,#0                 ;2391
0008fc  e4de              B        |L1.700|
;;;2396   /*-----------------------------------------------------------*/
                          ENDP

                  xTaskRemoveFromUnorderedEventList PROC
;;;2397   
;;;2398   BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
0008fe  b570              PUSH     {r4-r6,lr}
;;;2399   {
;;;2400   TCB_t *pxUnblockedTCB;
;;;2401   BaseType_t xReturn;
;;;2402   
;;;2403   	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
;;;2404   	the event flags implementation. */
;;;2405   	configASSERT( uxSchedulerSuspended != pdFALSE );
000900  4ea2              LDR      r6,|L1.2956|
000902  6af2              LDR      r2,[r6,#0x2c]  ; uxSchedulerSuspended
000904  b302              CBZ      r2,|L1.2376|
;;;2406   
;;;2407   	/* Store the new item value in the event list. */
;;;2408   	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
000906  f0414100          ORR      r1,r1,#0x80000000
;;;2409   
;;;2410   	/* Remove the event list form the event flag.  Interrupts do not access
;;;2411   	event flags. */
;;;2412   	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
00090a  6001              STR      r1,[r0,#0]
;;;2413   	configASSERT( pxUnblockedTCB );
00090c  68c4              LDR      r4,[r0,#0xc]
00090e  b1f4              CBZ      r4,|L1.2382|
;;;2414   	( void ) uxListRemove( pxEventListItem );
000910  f7fffffe          BL       uxListRemove
;;;2415   
;;;2416   	/* Remove the task from the delayed list and add it to the ready list.  The
;;;2417   	scheduler is suspended so interrupts will not be accessing the ready
;;;2418   	lists. */
;;;2419   	( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
000914  1d20              ADDS     r0,r4,#4
000916  f7fffffe          BL       uxListRemove
;;;2420   	prvAddTaskToReadyList( pxUnblockedTCB );
00091a  6ae1              LDR      r1,[r4,#0x2c]
00091c  2501              MOVS     r5,#1
00091e  6932              LDR      r2,[r6,#0x10]  ; uxTopReadyPriority
000920  fa05f001          LSL      r0,r5,r1
000924  4310              ORRS     r0,r0,r2
000926  6130              STR      r0,[r6,#0x10]  ; uxTopReadyPriority
000928  eb010081          ADD      r0,r1,r1,LSL #2
00092c  4996              LDR      r1,|L1.2952|
00092e  eb010080          ADD      r0,r1,r0,LSL #2
000932  1d21              ADDS     r1,r4,#4
000934  f7fffffe          BL       vListInsertEnd
;;;2421   
;;;2422   	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
000938  6ae0              LDR      r0,[r4,#0x2c]
00093a  6831              LDR      r1,[r6,#0]  ; pxCurrentTCB
00093c  6ac9              LDR      r1,[r1,#0x2c]
00093e  4288              CMP      r0,r1
000940  d908              BLS      |L1.2388|
;;;2423   	{
;;;2424   		/* Return true if the task removed from the event list has
;;;2425   		a higher priority than the calling task.  This allows
;;;2426   		the calling task to know if it should force a context
;;;2427   		switch now. */
;;;2428   		xReturn = pdTRUE;
000942  2001              MOVS     r0,#1
;;;2429   
;;;2430   		/* Mark that a yield is pending in case the user is not using the
;;;2431   		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
;;;2432   		xYieldPending = pdTRUE;
000944  61f5              STR      r5,[r6,#0x1c]  ; xYieldPending
;;;2433   	}
;;;2434   	else
;;;2435   	{
;;;2436   		xReturn = pdFALSE;
;;;2437   	}
;;;2438   
;;;2439   	return xReturn;
;;;2440   }
000946  bd70              POP      {r4-r6,pc}
                  |L1.2376|
000948  f7fffffe          BL       ulPortSetInterruptMask
                  |L1.2380|
00094c  e7fe              B        |L1.2380|
                  |L1.2382|
00094e  f7fffffe          BL       ulPortSetInterruptMask
                  |L1.2386|
000952  e7fe              B        |L1.2386|
                  |L1.2388|
000954  2000              MOVS     r0,#0                 ;2436
000956  bd70              POP      {r4-r6,pc}
;;;2441   /*-----------------------------------------------------------*/
                          ENDP

                  vTaskSetTimeOutState PROC
;;;2442   
;;;2443   void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
000958  b510              PUSH     {r4,lr}
;;;2444   {
00095a  b128              CBZ      r0,|L1.2408|
;;;2445   	configASSERT( pxTimeOut );
;;;2446   	pxTimeOut->xOverflowCount = xNumOfOverflows;
00095c  498b              LDR      r1,|L1.2956|
00095e  6a0a              LDR      r2,[r1,#0x20]  ; xNumOfOverflows
;;;2447   	pxTimeOut->xTimeOnEntering = xTickCount;
000960  6002              STR      r2,[r0,#0]
000962  68c9              LDR      r1,[r1,#0xc]  ; xTickCount
;;;2448   }
000964  6041              STR      r1,[r0,#4]
000966  bd10              POP      {r4,pc}
                  |L1.2408|
000968  f7fffffe          BL       ulPortSetInterruptMask
                  |L1.2412|
00096c  e7fe              B        |L1.2412|
;;;2449   /*-----------------------------------------------------------*/
                          ENDP

                  xTaskCheckForTimeOut PROC
;;;2450   
;;;2451   BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
00096e  b570              PUSH     {r4-r6,lr}
;;;2452   {
000970  460d              MOV      r5,r1
000972  0004              MOVS     r4,r0
000974  d019              BEQ      |L1.2474|
;;;2453   BaseType_t xReturn;
;;;2454   
;;;2455   	configASSERT( pxTimeOut );
;;;2456   	configASSERT( pxTicksToWait );
000976  b1dd              CBZ      r5,|L1.2480|
;;;2457   
;;;2458   	taskENTER_CRITICAL();
000978  f7fffffe          BL       vPortEnterCritical
;;;2459   	{
;;;2460   		/* Minor optimisation.  The tick count cannot change in this block. */
;;;2461   		const TickType_t xConstTickCount = xTickCount;
00097c  4a83              LDR      r2,|L1.2956|
00097e  68d1              LDR      r1,[r2,#0xc]  ; xTickCount
;;;2462   
;;;2463   		#if ( INCLUDE_vTaskSuspend == 1 )
;;;2464   			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
;;;2465   			the maximum block time then the task should block indefinitely, and
;;;2466   			therefore never time out. */
;;;2467   			if( *pxTicksToWait == portMAX_DELAY )
000980  6828              LDR      r0,[r5,#0]
000982  1c43              ADDS     r3,r0,#1
000984  d00f              BEQ      |L1.2470|
;;;2468   			{
;;;2469   				xReturn = pdFALSE;
;;;2470   			}
;;;2471   			else /* We are not blocking indefinitely, perform the checks below. */
;;;2472   		#endif
;;;2473   
;;;2474   		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
000986  6823              LDR      r3,[r4,#0]
000988  6a12              LDR      r2,[r2,#0x20]  ; xNumOfOverflows
00098a  4293              CMP      r3,r2
00098c  d002              BEQ      |L1.2452|
00098e  6862              LDR      r2,[r4,#4]
000990  428a              CMP      r2,r1
000992  d910              BLS      |L1.2486|
                  |L1.2452|
;;;2475   		{
;;;2476   			/* The tick count is greater than the time at which vTaskSetTimeout()
;;;2477   			was called, but has also overflowed since vTaskSetTimeOut() was called.
;;;2478   			It must have wrapped all the way around and gone past us again. This
;;;2479   			passed since vTaskSetTimeout() was called. */
;;;2480   			xReturn = pdTRUE;
;;;2481   		}
;;;2482   		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
000994  6862              LDR      r2,[r4,#4]
000996  1a89              SUBS     r1,r1,r2
000998  4281              CMP      r1,r0
00099a  d20c              BCS      |L1.2486|
;;;2483   		{
;;;2484   			/* Not a genuine timeout. Adjust parameters for time remaining. */
;;;2485   			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
00099c  1a40              SUBS     r0,r0,r1
;;;2486   			vTaskSetTimeOutState( pxTimeOut );
00099e  6028              STR      r0,[r5,#0]
0009a0  4620              MOV      r0,r4
0009a2  f7fffffe          BL       vTaskSetTimeOutState
                  |L1.2470|
0009a6  2400              MOVS     r4,#0                 ;2469
0009a8  e006              B        |L1.2488|
                  |L1.2474|
0009aa  f7fffffe          BL       ulPortSetInterruptMask
                  |L1.2478|
0009ae  e7fe              B        |L1.2478|
                  |L1.2480|
0009b0  f7fffffe          BL       ulPortSetInterruptMask
                  |L1.2484|
0009b4  e7fe              B        |L1.2484|
                  |L1.2486|
;;;2487   			xReturn = pdFALSE;
;;;2488   		}
;;;2489   		else
;;;2490   		{
;;;2491   			xReturn = pdTRUE;
0009b6  2401              MOVS     r4,#1
                  |L1.2488|
;;;2492   		}
;;;2493   	}
;;;2494   	taskEXIT_CRITICAL();
0009b8  f7fffffe          BL       vPortExitCritical
;;;2495   
;;;2496   	return xReturn;
0009bc  4620              MOV      r0,r4
;;;2497   }
0009be  bd70              POP      {r4-r6,pc}
;;;2498   /*-----------------------------------------------------------*/
                          ENDP

                  vTaskMissedYield PROC
;;;2499   
;;;2500   void vTaskMissedYield( void )
0009c0  4972              LDR      r1,|L1.2956|
;;;2501   {
;;;2502   	xYieldPending = pdTRUE;
0009c2  2001              MOVS     r0,#1
0009c4  61c8              STR      r0,[r1,#0x1c]  ; xYieldPending
;;;2503   }
0009c6  4770              BX       lr
;;;2504   /*-----------------------------------------------------------*/
                          ENDP

                  xTaskGetCurrentTaskHandle PROC
;;;3133   
;;;3134   	TaskHandle_t xTaskGetCurrentTaskHandle( void )
0009c8  4870              LDR      r0,|L1.2956|
;;;3135   	{
;;;3136   	TaskHandle_t xReturn;
;;;3137   
;;;3138   		/* A critical section is not required as this is not called from
;;;3139   		an interrupt and the current TCB will always be the same for any
;;;3140   		individual execution thread. */
;;;3141   		xReturn = pxCurrentTCB;
0009ca  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
;;;3142   
;;;3143   		return xReturn;
;;;3144   	}
0009cc  4770              BX       lr
;;;3145   
                          ENDP

                  xTaskGetSchedulerState PROC
;;;3150   
;;;3151   	BaseType_t xTaskGetSchedulerState( void )
0009ce  486f              LDR      r0,|L1.2956|
;;;3152   	{
;;;3153   	BaseType_t xReturn;
;;;3154   
;;;3155   		if( xSchedulerRunning == pdFALSE )
0009d0  6941              LDR      r1,[r0,#0x14]  ; xSchedulerRunning
0009d2  b119              CBZ      r1,|L1.2524|
;;;3156   		{
;;;3157   			xReturn = taskSCHEDULER_NOT_STARTED;
;;;3158   		}
;;;3159   		else
;;;3160   		{
;;;3161   			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
0009d4  6ac0              LDR      r0,[r0,#0x2c]  ; uxSchedulerSuspended
0009d6  b118              CBZ      r0,|L1.2528|
;;;3162   			{
;;;3163   				xReturn = taskSCHEDULER_RUNNING;
;;;3164   			}
;;;3165   			else
;;;3166   			{
;;;3167   				xReturn = taskSCHEDULER_SUSPENDED;
0009d8  2000              MOVS     r0,#0
;;;3168   			}
;;;3169   		}
;;;3170   
;;;3171   		return xReturn;
;;;3172   	}
0009da  4770              BX       lr
                  |L1.2524|
0009dc  2001              MOVS     r0,#1                 ;3157
0009de  4770              BX       lr
                  |L1.2528|
0009e0  2002              MOVS     r0,#2                 ;3163
0009e2  4770              BX       lr
;;;3173   
                          ENDP

                  vTaskPriorityInherit PROC
;;;3178   
;;;3179   	void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
0009e4  b570              PUSH     {r4-r6,lr}
;;;3180   	{
;;;3181   	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
0009e6  0004              MOVS     r4,r0
0009e8  d039              BEQ      |L1.2654|
;;;3182   
;;;3183   		/* If the mutex was given back by an interrupt while the queue was
;;;3184   		locked then the mutex holder might now be NULL. */
;;;3185   		if( pxMutexHolder != NULL )
;;;3186   		{
;;;3187   			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
0009ea  4d68              LDR      r5,|L1.2956|
0009ec  6ae0              LDR      r0,[r4,#0x2c]
0009ee  6829              LDR      r1,[r5,#0]  ; pxCurrentTCB
0009f0  6ac9              LDR      r1,[r1,#0x2c]
0009f2  4288              CMP      r0,r1
0009f4  d233              BCS      |L1.2654|
;;;3188   			{
;;;3189   				/* Adjust the mutex holder state to account for its new
;;;3190   				priority.  Only reset the event list item value if the value is
;;;3191   				not	being used for anything else. */
;;;3192   				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
0009f6  69a0              LDR      r0,[r4,#0x18]
0009f8  2800              CMP      r0,#0
0009fa  db04              BLT      |L1.2566|
;;;3193   				{
;;;3194   					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
0009fc  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
0009fe  6ac0              LDR      r0,[r0,#0x2c]
000a00  f1c00005          RSB      r0,r0,#5
000a04  61a0              STR      r0,[r4,#0x18]
                  |L1.2566|
;;;3195   				}
;;;3196   				else
;;;3197   				{
;;;3198   					mtCOVERAGE_TEST_MARKER();
;;;3199   				}
;;;3200   
;;;3201   				/* If the task being modified is in the ready state it will need to
;;;3202   				be moved into a new list. */
;;;3203   				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
000a06  6ae1              LDR      r1,[r4,#0x2c]
000a08  4e5f              LDR      r6,|L1.2952|
000a0a  eb010181          ADD      r1,r1,r1,LSL #2
000a0e  6960              LDR      r0,[r4,#0x14]
000a10  eb060181          ADD      r1,r6,r1,LSL #2
000a14  4288              CMP      r0,r1
000a16  d11f              BNE      |L1.2648|
;;;3204   				{
;;;3205   					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
000a18  1d20              ADDS     r0,r4,#4
000a1a  f7fffffe          BL       uxListRemove
;;;3206   					{
;;;3207   						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
000a1e  2101              MOVS     r1,#1
000a20  b950              CBNZ     r0,|L1.2616|
000a22  6ae0              LDR      r0,[r4,#0x2c]
000a24  eb000280          ADD      r2,r0,r0,LSL #2
000a28  f8562022          LDR      r2,[r6,r2,LSL #2]
000a2c  b922              CBNZ     r2,|L1.2616|
000a2e  692a              LDR      r2,[r5,#0x10]  ; uxTopReadyPriority
000a30  fa01f000          LSL      r0,r1,r0
000a34  4382              BICS     r2,r2,r0
000a36  612a              STR      r2,[r5,#0x10]  ; uxTopReadyPriority
                  |L1.2616|
;;;3208   					}
;;;3209   					else
;;;3210   					{
;;;3211   						mtCOVERAGE_TEST_MARKER();
;;;3212   					}
;;;3213   
;;;3214   					/* Inherit the priority before being moved into the new list. */
;;;3215   					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
000a38  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
000a3a  6ac0              LDR      r0,[r0,#0x2c]
;;;3216   					prvAddTaskToReadyList( pxTCB );
000a3c  62e0              STR      r0,[r4,#0x2c]
000a3e  692a              LDR      r2,[r5,#0x10]  ; uxTopReadyPriority
000a40  4081              LSLS     r1,r1,r0
000a42  4311              ORRS     r1,r1,r2
000a44  6129              STR      r1,[r5,#0x10]  ; uxTopReadyPriority
000a46  eb000080          ADD      r0,r0,r0,LSL #2
000a4a  eb060080          ADD      r0,r6,r0,LSL #2
000a4e  1d21              ADDS     r1,r4,#4
000a50  e8bd4070          POP      {r4-r6,lr}
000a54  f7ffbffe          B.W      vListInsertEnd
                  |L1.2648|
;;;3217   				}
;;;3218   				else
;;;3219   				{
;;;3220   					/* Just inherit the priority. */
;;;3221   					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
000a58  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
000a5a  6ac0              LDR      r0,[r0,#0x2c]
000a5c  62e0              STR      r0,[r4,#0x2c]
                  |L1.2654|
;;;3222   				}
;;;3223   
;;;3224   				traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
;;;3225   			}
;;;3226   			else
;;;3227   			{
;;;3228   				mtCOVERAGE_TEST_MARKER();
;;;3229   			}
;;;3230   		}
;;;3231   		else
;;;3232   		{
;;;3233   			mtCOVERAGE_TEST_MARKER();
;;;3234   		}
;;;3235   	}
000a5e  bd70              POP      {r4-r6,pc}
;;;3236   
                          ENDP

                  xTaskPriorityDisinherit PROC
;;;3241   
;;;3242   	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
000a60  b570              PUSH     {r4-r6,lr}
;;;3243   	{
000a62  0004              MOVS     r4,r0
;;;3244   	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
;;;3245   	BaseType_t xReturn = pdFALSE;
000a64  f04f0100          MOV      r1,#0
000a68  d030              BEQ      |L1.2764|
;;;3246   
;;;3247   		if( pxMutexHolder != NULL )
;;;3248   		{
;;;3249   			configASSERT( pxTCB->uxMutexesHeld );
000a6a  6c60              LDR      r0,[r4,#0x44]
000a6c  b138              CBZ      r0,|L1.2686|
000a6e  1e40              SUBS     r0,r0,#1
;;;3250   			( pxTCB->uxMutexesHeld )--;
;;;3251   
;;;3252   			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
000a70  6460              STR      r0,[r4,#0x44]
000a72  6c23              LDR      r3,[r4,#0x40]
000a74  6ae2              LDR      r2,[r4,#0x2c]
000a76  429a              CMP      r2,r3
000a78  d028              BEQ      |L1.2764|
;;;3253   			{
;;;3254   				/* Only disinherit if no other mutexes are held. */
;;;3255   				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
000a7a  b118              CBZ      r0,|L1.2692|
000a7c  e026              B        |L1.2764|
                  |L1.2686|
000a7e  f7fffffe          BL       ulPortSetInterruptMask
                  |L1.2690|
000a82  e7fe              B        |L1.2690|
                  |L1.2692|
;;;3256   				{
;;;3257   					/* The holding task must be the running task to be able to give
;;;3258   					the mutex back.  Remove the holding task from the ready list. */
;;;3259   					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
000a84  1d20              ADDS     r0,r4,#4
000a86  f7fffffe          BL       uxListRemove
;;;3260   					{
;;;3261   						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
000a8a  4b3f              LDR      r3,|L1.2952|
000a8c  4a3f              LDR      r2,|L1.2956|
000a8e  2101              MOVS     r1,#1
000a90  b950              CBNZ     r0,|L1.2728|
000a92  6ae0              LDR      r0,[r4,#0x2c]
000a94  eb000580          ADD      r5,r0,r0,LSL #2
000a98  f8535025          LDR      r5,[r3,r5,LSL #2]
000a9c  b925              CBNZ     r5,|L1.2728|
000a9e  6915              LDR      r5,[r2,#0x10]  ; uxTopReadyPriority
000aa0  fa01f000          LSL      r0,r1,r0
000aa4  4385              BICS     r5,r5,r0
000aa6  6115              STR      r5,[r2,#0x10]  ; uxTopReadyPriority
                  |L1.2728|
;;;3262   					}
;;;3263   					else
;;;3264   					{
;;;3265   						mtCOVERAGE_TEST_MARKER();
;;;3266   					}
;;;3267   
;;;3268   					/* Disinherit the priority before adding the task into the new
;;;3269   					ready list. */
;;;3270   					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
;;;3271   					pxTCB->uxPriority = pxTCB->uxBasePriority;
000aa8  6c20              LDR      r0,[r4,#0x40]
;;;3272   
;;;3273   					/* Reset the event list item value.  It cannot be in use for
;;;3274   					any other purpose if this task is running, and it must be
;;;3275   					running to give back the mutex. */
;;;3276   					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000aaa  62e0              STR      r0,[r4,#0x2c]
000aac  f1c00005          RSB      r0,r0,#5
;;;3277   					prvAddTaskToReadyList( pxTCB );
000ab0  61a0              STR      r0,[r4,#0x18]
000ab2  6ae0              LDR      r0,[r4,#0x2c]
000ab4  6915              LDR      r5,[r2,#0x10]  ; uxTopReadyPriority
000ab6  4081              LSLS     r1,r1,r0
000ab8  4329              ORRS     r1,r1,r5
000aba  6111              STR      r1,[r2,#0x10]  ; uxTopReadyPriority
000abc  eb000080          ADD      r0,r0,r0,LSL #2
000ac0  eb030080          ADD      r0,r3,r0,LSL #2
000ac4  1d21              ADDS     r1,r4,#4
000ac6  f7fffffe          BL       vListInsertEnd
;;;3278   
;;;3279   					/* Return true to indicate that a context switch is required.
;;;3280   					This is only actually required in the corner case whereby
;;;3281   					multiple mutexes were held and the mutexes were given back
;;;3282   					in an order different to that in which they were taken. */
;;;3283   					xReturn = pdTRUE;
000aca  2101              MOVS     r1,#1
                  |L1.2764|
;;;3284   				}
;;;3285   				else
;;;3286   				{
;;;3287   					mtCOVERAGE_TEST_MARKER();
;;;3288   				}
;;;3289   			}
;;;3290   			else
;;;3291   			{
;;;3292   				mtCOVERAGE_TEST_MARKER();
;;;3293   			}
;;;3294   		}
;;;3295   		else
;;;3296   		{
;;;3297   			mtCOVERAGE_TEST_MARKER();
;;;3298   		}
;;;3299   
;;;3300   		return xReturn;
000acc  4608              MOV      r0,r1
;;;3301   	}
000ace  bd70              POP      {r4-r6,pc}
;;;3302   
                          ENDP

                  uxTaskResetEventItemValue PROC
;;;3575   
;;;3576   TickType_t uxTaskResetEventItemValue( void )
000ad0  492e              LDR      r1,|L1.2956|
;;;3577   {
;;;3578   TickType_t uxReturn;
;;;3579   
;;;3580   	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
000ad2  6808              LDR      r0,[r1,#0]  ; pxCurrentTCB
;;;3581   
;;;3582   	/* Reset the event list item to its normal value - so it can be used with
;;;3583   	queues and semaphores. */
;;;3584   	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000ad4  680a              LDR      r2,[r1,#0]  ; pxCurrentTCB
000ad6  6980              LDR      r0,[r0,#0x18]         ;3580
000ad8  6ad2              LDR      r2,[r2,#0x2c]
000ada  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000adc  f1c20205          RSB      r2,r2,#5
000ae0  618a              STR      r2,[r1,#0x18]
;;;3585   
;;;3586   	return uxReturn;
;;;3587   }
000ae2  4770              BX       lr
;;;3588   /*-----------------------------------------------------------*/
                          ENDP

                  pvTaskIncrementMutexHeldCount PROC
;;;3591   
;;;3592   	void *pvTaskIncrementMutexHeldCount( void )
000ae4  4929              LDR      r1,|L1.2956|
;;;3593   	{
;;;3594   		/* If xSemaphoreCreateMutex() is called before any tasks have been created
;;;3595   		then pxCurrentTCB will be NULL. */
;;;3596   		if( pxCurrentTCB != NULL )
000ae6  6808              LDR      r0,[r1,#0]  ; pxCurrentTCB
000ae8  b118              CBZ      r0,|L1.2802|
;;;3597   		{
;;;3598   			( pxCurrentTCB->uxMutexesHeld )++;
000aea  6808              LDR      r0,[r1,#0]  ; pxCurrentTCB
000aec  6c42              LDR      r2,[r0,#0x44]
000aee  1c52              ADDS     r2,r2,#1
000af0  6442              STR      r2,[r0,#0x44]
                  |L1.2802|
;;;3599   		}
;;;3600   
;;;3601   		return pxCurrentTCB;
000af2  6808              LDR      r0,[r1,#0]  ; pxCurrentTCB
;;;3602   	}
000af4  4770              BX       lr
;;;3603   
                          ENDP

                  prvResetNextTaskUnblockTime PROC
;;;3106   
;;;3107   static void prvResetNextTaskUnblockTime( void )
000af6  4825              LDR      r0,|L1.2956|
;;;3108   {
;;;3109   TCB_t *pxTCB;
;;;3110   
;;;3111   	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
000af8  6b01              LDR      r1,[r0,#0x30]  ; pxDelayedTaskList
000afa  6809              LDR      r1,[r1,#0]
000afc  b129              CBZ      r1,|L1.2826|
;;;3112   	{
;;;3113   		/* The new current delayed list is empty.  Set
;;;3114   		xNextTaskUnblockTime to the maximum possible value so it is
;;;3115   		extremely unlikely that the
;;;3116   		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
;;;3117   		there is an item in the delayed list. */
;;;3118   		xNextTaskUnblockTime = portMAX_DELAY;
;;;3119   	}
;;;3120   	else
;;;3121   	{
;;;3122   		/* The new current delayed list is not empty, get the value of
;;;3123   		the item at the head of the delayed list.  This is the time at
;;;3124   		which the task at the head of the delayed list should be removed
;;;3125   		from the Blocked state. */
;;;3126   		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
000afe  6b01              LDR      r1,[r0,#0x30]  ; pxDelayedTaskList
000b00  68c9              LDR      r1,[r1,#0xc]
000b02  68c9              LDR      r1,[r1,#0xc]
;;;3127   		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
000b04  6849              LDR      r1,[r1,#4]
                  |L1.2822|
000b06  6281              STR      r1,[r0,#0x28]         ;3118  ; xNextTaskUnblockTime
;;;3128   	}
;;;3129   }
000b08  4770              BX       lr
                  |L1.2826|
000b0a  f04f31ff          MOV      r1,#0xffffffff        ;3118
000b0e  e7fa              B        |L1.2822|
;;;3130   /*-----------------------------------------------------------*/
                          ENDP

                  prvTaskIsTaskSuspended PROC
;;;1284   
;;;1285   	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
000b10  b510              PUSH     {r4,lr}
;;;1286   	{
;;;1287   	BaseType_t xReturn = pdFALSE;
000b12  2100              MOVS     r1,#0
000b14  b158              CBZ      r0,|L1.2862|
;;;1288   	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
;;;1289   
;;;1290   		/* Accesses xPendingReadyList so must be called from a critical
;;;1291   		section. */
;;;1292   
;;;1293   		/* It does not make sense to check if the calling task is suspended. */
;;;1294   		configASSERT( xTask );
;;;1295   
;;;1296   		/* Is the task being resumed actually in the suspended list? */
;;;1297   		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
000b16  4b1c              LDR      r3,|L1.2952|
000b18  6942              LDR      r2,[r0,#0x14]
000b1a  33b4              ADDS     r3,r3,#0xb4
000b1c  429a              CMP      r2,r3
000b1e  d10a              BNE      |L1.2870|
;;;1298   		{
;;;1299   			/* Has the task already been resumed from within an ISR? */
;;;1300   			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
000b20  6a80              LDR      r0,[r0,#0x28]
000b22  f1a30228          SUB      r2,r3,#0x28
000b26  4290              CMP      r0,r2
000b28  d005              BEQ      |L1.2870|
;;;1301   			{
;;;1302   				/* Is it in the suspended list because it is in the	Suspended
;;;1303   				state, or because is is blocked with no timeout? */
;;;1304   				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE )
000b2a  b118              CBZ      r0,|L1.2868|
000b2c  e003              B        |L1.2870|
                  |L1.2862|
000b2e  f7fffffe          BL       ulPortSetInterruptMask
                  |L1.2866|
000b32  e7fe              B        |L1.2866|
                  |L1.2868|
;;;1305   				{
;;;1306   					xReturn = pdTRUE;
000b34  2101              MOVS     r1,#1
                  |L1.2870|
;;;1307   				}
;;;1308   				else
;;;1309   				{
;;;1310   					mtCOVERAGE_TEST_MARKER();
;;;1311   				}
;;;1312   			}
;;;1313   			else
;;;1314   			{
;;;1315   				mtCOVERAGE_TEST_MARKER();
;;;1316   			}
;;;1317   		}
;;;1318   		else
;;;1319   		{
;;;1320   			mtCOVERAGE_TEST_MARKER();
;;;1321   		}
;;;1322   
;;;1323   		return xReturn;
000b36  4608              MOV      r0,r1
;;;1324   	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
000b38  bd10              POP      {r4,pc}
;;;1325   
                          ENDP

                  prvCheckTasksWaitingTermination PROC
;;;2842   
;;;2843   static void prvCheckTasksWaitingTermination( void )
000b3a  b570              PUSH     {r4-r6,lr}
;;;2844   {
;;;2845   	#if ( INCLUDE_vTaskDelete == 1 )
;;;2846   	{
;;;2847   		BaseType_t xListIsEmpty;
;;;2848   
;;;2849   		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
;;;2850   		too often in the idle task. */
;;;2851   		while( uxTasksDeleted > ( UBaseType_t ) 0U )
;;;2852   		{
;;;2853   			vTaskSuspendAll();
;;;2854   			{
;;;2855   				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
000b3c  4e12              LDR      r6,|L1.2952|
;;;2856   			}
;;;2857   			( void ) xTaskResumeAll();
;;;2858   
;;;2859   			if( xListIsEmpty == pdFALSE )
;;;2860   			{
;;;2861   				TCB_t *pxTCB;
;;;2862   
;;;2863   				taskENTER_CRITICAL();
;;;2864   				{
;;;2865   					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
;;;2866   					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
;;;2867   					--uxCurrentNumberOfTasks;
000b3e  4c13              LDR      r4,|L1.2956|
000b40  36a0              ADDS     r6,r6,#0xa0           ;2855
000b42  e01a              B        |L1.2938|
                  |L1.2884|
000b44  f7fffffe          BL       vTaskSuspendAll
000b48  6830              LDR      r0,[r6,#0]            ;2855  ; xTasksWaitingTermination
000b4a  b1d0              CBZ      r0,|L1.2946|
000b4c  f7fffffe          BL       xTaskResumeAll
000b50  f7fffffe          BL       vPortEnterCritical
000b54  68f0              LDR      r0,[r6,#0xc]          ;2865  ; xTasksWaitingTermination
000b56  68c5              LDR      r5,[r0,#0xc]          ;2866
000b58  1d28              ADDS     r0,r5,#4              ;2866
000b5a  f7fffffe          BL       uxListRemove
000b5e  68a0              LDR      r0,[r4,#8]  ; uxCurrentNumberOfTasks
000b60  1e40              SUBS     r0,r0,#1
000b62  60a0              STR      r0,[r4,#8]  ; uxCurrentNumberOfTasks
;;;2868   					--uxTasksDeleted;
000b64  6860              LDR      r0,[r4,#4]  ; uxTasksDeleted
000b66  1e40              SUBS     r0,r0,#1
000b68  6060              STR      r0,[r4,#4]  ; uxTasksDeleted
;;;2869   				}
;;;2870   				taskEXIT_CRITICAL();
000b6a  f7fffffe          BL       vPortExitCritical
000b6e  6b28              LDR      r0,[r5,#0x30]
000b70  f7fffffe          BL       vPortFree
000b74  4628              MOV      r0,r5
000b76  f7fffffe          BL       vPortFree
                  |L1.2938|
000b7a  6860              LDR      r0,[r4,#4]            ;2851  ; uxTasksDeleted
000b7c  2800              CMP      r0,#0                 ;2851
000b7e  d1e1              BNE      |L1.2884|
;;;2871   
;;;2872   				prvDeleteTCB( pxTCB );
;;;2873   			}
;;;2874   			else
;;;2875   			{
;;;2876   				mtCOVERAGE_TEST_MARKER();
;;;2877   			}
;;;2878   		}
;;;2879   	}
;;;2880   	#endif /* vTaskDelete */
;;;2881   }
000b80  bd70              POP      {r4-r6,pc}
                  |L1.2946|
000b82  f7fffffe          BL       xTaskResumeAll
000b86  e7f8              B        |L1.2938|
;;;2882   /*-----------------------------------------------------------*/
                          ENDP

                  |L1.2952|
                          DCD      ||.bss||
                  |L1.2956|
                          DCD      ||.data||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  pxReadyTasksLists
                          %        100
                  xDelayedTaskList1
                          %        20
                  xDelayedTaskList2
                          %        20
                  xPendingReadyList
                          %        20
                  xTasksWaitingTermination
                          %        20
                  xSuspendedTaskList
                          %        20

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  ucExpectedStackBytes
000000  a5a5a5a5          DCB      0xa5,0xa5,0xa5,0xa5
000004  a5a5a5a5          DCB      0xa5,0xa5,0xa5,0xa5
000008  a5a5a5a5          DCB      0xa5,0xa5,0xa5,0xa5
00000c  a5a5a5a5          DCB      0xa5,0xa5,0xa5,0xa5
000010  a5a5a5a5          DCB      0xa5,0xa5,0xa5,0xa5

                          AREA ||.data||, DATA, ALIGN=2

                  pxCurrentTCB
                          DCD      0x00000000
                  uxTasksDeleted
                          DCD      0x00000000
                  uxCurrentNumberOfTasks
                          DCD      0x00000000
                  xTickCount
                          DCD      0x00000000
                  uxTopReadyPriority
                          DCD      0x00000000
                  xSchedulerRunning
                          DCD      0x00000000
                  uxPendedTicks
                          DCD      0x00000000
                  xYieldPending
                          DCD      0x00000000
                  xNumOfOverflows
                          DCD      0x00000000
                  uxTaskNumber
                          DCD      0x00000000
                  xNextTaskUnblockTime
                          DCD      0xffffffff
                  uxSchedulerSuspended
                          DCD      0x00000000
                  pxDelayedTaskList
                          DCD      0x00000000
                  pxOverflowDelayedTaskList
                          DCD      0x00000000
