; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o.\queue.o --asm_dir=.\ --list_dir=.\ --depend=.\queue.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\hooks -I..\lcd -I..\led -I..\load_cpu -I..\main -I..\printf -I..\limit_switch -I..\control_task -I..\mode_task -I..\lcdTask -I..\hit -I..\move_task -I..\project -I..\..\rtos -I..\..\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\STM32F10x_StdPeriph_Driver\inc -I..\..\STM32F10x_StdPeriph_Driver\src -I"C:\Program Files\keil\ARM\RV31\INC" -I"C:\Program Files\keil\ARM\PACK\ARM\CMSIS\3.20.4\CMSIS\Include" -I"C:\Program Files\keil\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include" -DSTM32F10X_MD_VL -DUSE_STDPERIPH_DRIVER --omf_browse=.\queue.crf ..\..\rtos\queue.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  xQueueGenericReset PROC
;;;254    
;;;255    BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
000000  b570              PUSH     {r4-r6,lr}
;;;256    {
000002  460d              MOV      r5,r1
000004  0004              MOVS     r4,r0
000006  d023              BEQ      |L1.80|
;;;257    Queue_t * const pxQueue = ( Queue_t * ) xQueue;
;;;258    
;;;259    	configASSERT( pxQueue );
;;;260    
;;;261    	taskENTER_CRITICAL();
000008  f7fffffe          BL       vPortEnterCritical
;;;262    	{
;;;263    		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
00000c  e9d4200f          LDRD     r2,r0,[r4,#0x3c]
000010  6821              LDR      r1,[r4,#0]
000012  fb021100          MLA      r1,r2,r0,r1
;;;264    		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
000016  6061              STR      r1,[r4,#4]
000018  2100              MOVS     r1,#0
00001a  63a1              STR      r1,[r4,#0x38]
;;;265    		pxQueue->pcWriteTo = pxQueue->pcHead;
00001c  6821              LDR      r1,[r4,#0]
;;;266    		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
00001e  60a1              STR      r1,[r4,#8]
000020  460a              MOV      r2,r1
000022  e9d4010f          LDRD     r0,r1,[r4,#0x3c]
000026  1e40              SUBS     r0,r0,#1
000028  fb002101          MLA      r1,r0,r1,r2
;;;267    		pxQueue->xRxLock = queueUNLOCKED;
00002c  f04f30ff          MOV      r0,#0xffffffff
000030  60e1              STR      r1,[r4,#0xc]
000032  6460              STR      r0,[r4,#0x44]
;;;268    		pxQueue->xTxLock = queueUNLOCKED;
000034  64a0              STR      r0,[r4,#0x48]
;;;269    
;;;270    		if( xNewQueue == pdFALSE )
;;;271    		{
;;;272    			/* If there are tasks blocked waiting to read from the queue, then
;;;273    			the tasks will remain blocked as after this function exits the queue
;;;274    			will still be empty.  If there are tasks blocked waiting to write to
;;;275    			the queue, then one should be unblocked as after this function exits
;;;276    			it will be possible to write to it. */
;;;277    			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
;;;278    			{
;;;279    				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
000036  f1040010          ADD      r0,r4,#0x10
00003a  b165              CBZ      r5,|L1.86|
;;;280    				{
;;;281    					queueYIELD_IF_USING_PREEMPTION();
;;;282    				}
;;;283    				else
;;;284    				{
;;;285    					mtCOVERAGE_TEST_MARKER();
;;;286    				}
;;;287    			}
;;;288    			else
;;;289    			{
;;;290    				mtCOVERAGE_TEST_MARKER();
;;;291    			}
;;;292    		}
;;;293    		else
;;;294    		{
;;;295    			/* Ensure the event queues start in the correct state. */
;;;296    			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
00003c  f7fffffe          BL       vListInitialise
;;;297    			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
000040  f1040024          ADD      r0,r4,#0x24
000044  f7fffffe          BL       vListInitialise
                  |L1.72|
;;;298    		}
;;;299    	}
;;;300    	taskEXIT_CRITICAL();
000048  f7fffffe          BL       vPortExitCritical
;;;301    
;;;302    	/* A value is returned for calling semantic consistency with previous
;;;303    	versions. */
;;;304    	return pdPASS;
00004c  2001              MOVS     r0,#1
;;;305    }
00004e  bd70              POP      {r4-r6,pc}
                  |L1.80|
000050  f7fffffe          BL       ulPortSetInterruptMask
                  |L1.84|
000054  e7fe              B        |L1.84|
                  |L1.86|
000056  6921              LDR      r1,[r4,#0x10]         ;277
000058  2900              CMP      r1,#0                 ;277
00005a  d0f5              BEQ      |L1.72|
00005c  f7fffffe          BL       xTaskRemoveFromEventList
000060  2801              CMP      r0,#1                 ;279
000062  d1f1              BNE      |L1.72|
000064  f7fffffe          BL       vPortYield
000068  e7ee              B        |L1.72|
;;;306    /*-----------------------------------------------------------*/
                          ENDP

                  xQueueGenericCreate PROC
;;;307    
;;;308    QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
00006a  b570              PUSH     {r4-r6,lr}
;;;309    {
00006c  460e              MOV      r6,r1
00006e  0005              MOVS     r5,r0
000070  d016              BEQ      |L1.160|
;;;310    Queue_t *pxNewQueue;
;;;311    size_t xQueueSizeInBytes;
;;;312    QueueHandle_t xReturn = NULL;
;;;313    
;;;314    	/* Remove compiler warnings about unused parameters should
;;;315    	configUSE_TRACE_FACILITY not be set to 1. */
;;;316    	( void ) ucQueueType;
;;;317    
;;;318    	/* Allocate the new queue structure. */
;;;319    	if( uxQueueLength > ( UBaseType_t ) 0 )
;;;320    	{
;;;321    		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
000072  204c              MOVS     r0,#0x4c
000074  f7fffffe          BL       pvPortMalloc
000078  0004              MOVS     r4,r0
;;;322    		if( pxNewQueue != NULL )
00007a  d011              BEQ      |L1.160|
;;;323    		{
;;;324    			/* Create the list of pointers to queue items.  The queue is one byte
;;;325    			longer than asked for to make wrap checking easier/faster. */
;;;326    			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
00007c  fb05f006          MUL      r0,r5,r6
000080  1c40              ADDS     r0,r0,#1
;;;327    
;;;328    			pxNewQueue->pcHead = ( int8_t * ) pvPortMalloc( xQueueSizeInBytes );
000082  f7fffffe          BL       pvPortMalloc
;;;329    			if( pxNewQueue->pcHead != NULL )
000086  6020              STR      r0,[r4,#0]
000088  b138              CBZ      r0,|L1.154|
;;;330    			{
;;;331    				/* Initialise the queue members as described above where the
;;;332    				queue type is defined. */
;;;333    				pxNewQueue->uxLength = uxQueueLength;
;;;334    				pxNewQueue->uxItemSize = uxItemSize;
;;;335    				( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
00008a  e9c4560f          STRD     r5,r6,[r4,#0x3c]
00008e  2101              MOVS     r1,#1
000090  4620              MOV      r0,r4
000092  f7fffffe          BL       xQueueGenericReset
;;;336    
;;;337    				#if ( configUSE_TRACE_FACILITY == 1 )
;;;338    				{
;;;339    					pxNewQueue->ucQueueType = ucQueueType;
;;;340    				}
;;;341    				#endif /* configUSE_TRACE_FACILITY */
;;;342    
;;;343    				#if( configUSE_QUEUE_SETS == 1 )
;;;344    				{
;;;345    					pxNewQueue->pxQueueSetContainer = NULL;
;;;346    				}
;;;347    				#endif /* configUSE_QUEUE_SETS */
;;;348    
;;;349    				traceQUEUE_CREATE( pxNewQueue );
;;;350    				xReturn = pxNewQueue;
000096  4620              MOV      r0,r4
;;;351    			}
;;;352    			else
;;;353    			{
;;;354    				traceQUEUE_CREATE_FAILED( ucQueueType );
;;;355    				vPortFree( pxNewQueue );
;;;356    			}
;;;357    		}
;;;358    		else
;;;359    		{
;;;360    			mtCOVERAGE_TEST_MARKER();
;;;361    		}
;;;362    	}
;;;363    	else
;;;364    	{
;;;365    		mtCOVERAGE_TEST_MARKER();
;;;366    	}
;;;367    
;;;368    	configASSERT( xReturn );
;;;369    
;;;370    	return xReturn;
;;;371    }
000098  bd70              POP      {r4-r6,pc}
                  |L1.154|
00009a  4620              MOV      r0,r4                 ;355
00009c  f7fffffe          BL       vPortFree
                  |L1.160|
0000a0  f7fffffe          BL       ulPortSetInterruptMask
                  |L1.164|
0000a4  e7fe              B        |L1.164|
;;;372    /*-----------------------------------------------------------*/
                          ENDP

                  prvUnlockQueue PROC
;;;1713   
;;;1714   static void prvUnlockQueue( Queue_t * const pxQueue )
0000a6  b570              PUSH     {r4-r6,lr}
;;;1715   {
0000a8  4604              MOV      r4,r0
;;;1716   	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
;;;1717   
;;;1718   	/* The lock counts contains the number of extra data items placed or
;;;1719   	removed from the queue while the queue was locked.  When a queue is
;;;1720   	locked items can be added or removed, but the event lists cannot be
;;;1721   	updated. */
;;;1722   	taskENTER_CRITICAL();
0000aa  f7fffffe          BL       vPortEnterCritical
;;;1723   	{
;;;1724   		/* See if data was added to the queue while it was locked. */
;;;1725   		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
;;;1726   		{
;;;1727   			/* Data was posted while the queue was locked.  Are any tasks
;;;1728   			blocked waiting for data to become available? */
;;;1729   			#if ( configUSE_QUEUE_SETS == 1 )
;;;1730   			{
;;;1731   				if( pxQueue->pxQueueSetContainer != NULL )
;;;1732   				{
;;;1733   					if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) == pdTRUE )
;;;1734   					{
;;;1735   						/* The queue is a member of a queue set, and posting to
;;;1736   						the queue set caused a higher priority task to unblock.
;;;1737   						A context switch is required. */
;;;1738   						vTaskMissedYield();
;;;1739   					}
;;;1740   					else
;;;1741   					{
;;;1742   						mtCOVERAGE_TEST_MARKER();
;;;1743   					}
;;;1744   				}
;;;1745   				else
;;;1746   				{
;;;1747   					/* Tasks that are removed from the event list will get added to
;;;1748   					the pending ready list as the scheduler is still suspended. */
;;;1749   					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;1750   					{
;;;1751   						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
;;;1752   						{
;;;1753   							/* The task waiting has a higher priority so record that a
;;;1754   							context	switch is required. */
;;;1755   							vTaskMissedYield();
;;;1756   						}
;;;1757   						else
;;;1758   						{
;;;1759   							mtCOVERAGE_TEST_MARKER();
;;;1760   						}
;;;1761   					}
;;;1762   					else
;;;1763   					{
;;;1764   						break;
;;;1765   					}
;;;1766   				}
;;;1767   			}
;;;1768   			#else /* configUSE_QUEUE_SETS */
;;;1769   			{
;;;1770   				/* Tasks that are removed from the event list will get added to
;;;1771   				the pending ready list as the scheduler is still suspended. */
;;;1772   				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;1773   				{
;;;1774   					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
0000ae  f1040524          ADD      r5,r4,#0x24
0000b2  e00a              B        |L1.202|
                  |L1.180|
0000b4  6a60              LDR      r0,[r4,#0x24]         ;1772
0000b6  b158              CBZ      r0,|L1.208|
0000b8  4628              MOV      r0,r5                 ;1772
0000ba  f7fffffe          BL       xTaskRemoveFromEventList
0000be  b108              CBZ      r0,|L1.196|
;;;1775   					{
;;;1776   						/* The task waiting has a higher priority so record that a
;;;1777   						context	switch is required. */
;;;1778   						vTaskMissedYield();
0000c0  f7fffffe          BL       vTaskMissedYield
                  |L1.196|
;;;1779   					}
;;;1780   					else
;;;1781   					{
;;;1782   						mtCOVERAGE_TEST_MARKER();
;;;1783   					}
;;;1784   				}
;;;1785   				else
;;;1786   				{
;;;1787   					break;
;;;1788   				}
;;;1789   			}
;;;1790   			#endif /* configUSE_QUEUE_SETS */
;;;1791   
;;;1792   			--( pxQueue->xTxLock );
0000c4  6ca0              LDR      r0,[r4,#0x48]
0000c6  1e40              SUBS     r0,r0,#1
0000c8  64a0              STR      r0,[r4,#0x48]
                  |L1.202|
0000ca  6ca0              LDR      r0,[r4,#0x48]         ;1725
0000cc  2800              CMP      r0,#0                 ;1725
0000ce  dcf1              BGT      |L1.180|
                  |L1.208|
;;;1793   		}
;;;1794   
;;;1795   		pxQueue->xTxLock = queueUNLOCKED;
0000d0  f04f36ff          MOV      r6,#0xffffffff
0000d4  64a6              STR      r6,[r4,#0x48]
;;;1796   	}
;;;1797   	taskEXIT_CRITICAL();
0000d6  f7fffffe          BL       vPortExitCritical
;;;1798   
;;;1799   	/* Do the same for the Rx lock. */
;;;1800   	taskENTER_CRITICAL();
0000da  f7fffffe          BL       vPortEnterCritical
;;;1801   	{
;;;1802   		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
;;;1803   		{
;;;1804   			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
;;;1805   			{
;;;1806   				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
0000de  f1040510          ADD      r5,r4,#0x10
0000e2  e00a              B        |L1.250|
                  |L1.228|
0000e4  6920              LDR      r0,[r4,#0x10]         ;1804
0000e6  b158              CBZ      r0,|L1.256|
0000e8  4628              MOV      r0,r5                 ;1804
0000ea  f7fffffe          BL       xTaskRemoveFromEventList
0000ee  b108              CBZ      r0,|L1.244|
;;;1807   				{
;;;1808   					vTaskMissedYield();
0000f0  f7fffffe          BL       vTaskMissedYield
                  |L1.244|
;;;1809   				}
;;;1810   				else
;;;1811   				{
;;;1812   					mtCOVERAGE_TEST_MARKER();
;;;1813   				}
;;;1814   
;;;1815   				--( pxQueue->xRxLock );
0000f4  6c60              LDR      r0,[r4,#0x44]
0000f6  1e40              SUBS     r0,r0,#1
0000f8  6460              STR      r0,[r4,#0x44]
                  |L1.250|
0000fa  6c60              LDR      r0,[r4,#0x44]         ;1802
0000fc  2800              CMP      r0,#0                 ;1802
0000fe  dcf1              BGT      |L1.228|
                  |L1.256|
;;;1816   			}
;;;1817   			else
;;;1818   			{
;;;1819   				break;
;;;1820   			}
;;;1821   		}
;;;1822   
;;;1823   		pxQueue->xRxLock = queueUNLOCKED;
000100  6466              STR      r6,[r4,#0x44]
;;;1824   	}
;;;1825   	taskEXIT_CRITICAL();
000102  e8bd4070          POP      {r4-r6,lr}
000106  f7ffbffe          B.W      vPortExitCritical
;;;1826   }
;;;1827   /*-----------------------------------------------------------*/
                          ENDP

                  prvCopyDataToQueue PROC
;;;1621   
;;;1622   static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
00010a  b570              PUSH     {r4-r6,lr}
;;;1623   {
00010c  4616              MOV      r6,r2
00010e  6c02              LDR      r2,[r0,#0x40]
000110  4604              MOV      r4,r0
;;;1624   BaseType_t xReturn = pdFALSE;
000112  2500              MOVS     r5,#0
000114  b182              CBZ      r2,|L1.312|
;;;1625   
;;;1626   	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
;;;1627   	{
;;;1628   		#if ( configUSE_MUTEXES == 1 )
;;;1629   		{
;;;1630   			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
;;;1631   			{
;;;1632   				/* The mutex is no longer being held. */
;;;1633   				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
;;;1634   				pxQueue->pxMutexHolder = NULL;
;;;1635   			}
;;;1636   			else
;;;1637   			{
;;;1638   				mtCOVERAGE_TEST_MARKER();
;;;1639   			}
;;;1640   		}
;;;1641   		#endif /* configUSE_MUTEXES */
;;;1642   	}
;;;1643   	else if( xPosition == queueSEND_TO_BACK )
000116  b1c6              CBZ      r6,|L1.330|
;;;1644   	{
;;;1645   		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
;;;1646   		pxQueue->pcWriteTo += pxQueue->uxItemSize;
;;;1647   		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
;;;1648   		{
;;;1649   			pxQueue->pcWriteTo = pxQueue->pcHead;
;;;1650   		}
;;;1651   		else
;;;1652   		{
;;;1653   			mtCOVERAGE_TEST_MARKER();
;;;1654   		}
;;;1655   	}
;;;1656   	else
;;;1657   	{
;;;1658   		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000118  68e0              LDR      r0,[r4,#0xc]
00011a  f7fffffe          BL       __aeabi_memcpy
;;;1659   		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
00011e  68e1              LDR      r1,[r4,#0xc]
000120  6c20              LDR      r0,[r4,#0x40]
000122  1a09              SUBS     r1,r1,r0
;;;1660   		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
000124  60e1              STR      r1,[r4,#0xc]
000126  6822              LDR      r2,[r4,#0]
000128  4291              CMP      r1,r2
00012a  d202              BCS      |L1.306|
;;;1661   		{
;;;1662   			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
00012c  6861              LDR      r1,[r4,#4]
00012e  1a08              SUBS     r0,r1,r0
000130  60e0              STR      r0,[r4,#0xc]
                  |L1.306|
;;;1663   		}
;;;1664   		else
;;;1665   		{
;;;1666   			mtCOVERAGE_TEST_MARKER();
;;;1667   		}
;;;1668   
;;;1669   		if( xPosition == queueOVERWRITE )
000132  2e02              CMP      r6,#2
000134  d016              BEQ      |L1.356|
000136  e01a              B        |L1.366|
                  |L1.312|
000138  6820              LDR      r0,[r4,#0]            ;1630
00013a  b9c0              CBNZ     r0,|L1.366|
00013c  6860              LDR      r0,[r4,#4]            ;1633
00013e  f7fffffe          BL       xTaskPriorityDisinherit
000142  4605              MOV      r5,r0                 ;1633
000144  2000              MOVS     r0,#0                 ;1634
000146  6060              STR      r0,[r4,#4]            ;1634
000148  e011              B        |L1.366|
                  |L1.330|
00014a  68a0              LDR      r0,[r4,#8]            ;1645
00014c  f7fffffe          BL       __aeabi_memcpy
000150  6c21              LDR      r1,[r4,#0x40]         ;1646
000152  68a0              LDR      r0,[r4,#8]            ;1646
000154  4408              ADD      r0,r0,r1              ;1646
000156  60a0              STR      r0,[r4,#8]            ;1647
000158  6861              LDR      r1,[r4,#4]            ;1647
00015a  4288              CMP      r0,r1                 ;1647
00015c  d307              BCC      |L1.366|
00015e  6820              LDR      r0,[r4,#0]            ;1649
000160  60a0              STR      r0,[r4,#8]            ;1649
000162  e004              B        |L1.366|
                  |L1.356|
;;;1670   		{
;;;1671   			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
000164  6ba0              LDR      r0,[r4,#0x38]
000166  b110              CBZ      r0,|L1.366|
;;;1672   			{
;;;1673   				/* An item is not being added but overwritten, so subtract
;;;1674   				one from the recorded number of items in the queue so when
;;;1675   				one is added again below the number of recorded items remains
;;;1676   				correct. */
;;;1677   				--( pxQueue->uxMessagesWaiting );
000168  6ba0              LDR      r0,[r4,#0x38]
00016a  1e40              SUBS     r0,r0,#1
00016c  63a0              STR      r0,[r4,#0x38]
                  |L1.366|
;;;1678   			}
;;;1679   			else
;;;1680   			{
;;;1681   				mtCOVERAGE_TEST_MARKER();
;;;1682   			}
;;;1683   		}
;;;1684   		else
;;;1685   		{
;;;1686   			mtCOVERAGE_TEST_MARKER();
;;;1687   		}
;;;1688   	}
;;;1689   
;;;1690   	++( pxQueue->uxMessagesWaiting );
00016e  6ba0              LDR      r0,[r4,#0x38]
000170  1c40              ADDS     r0,r0,#1
000172  63a0              STR      r0,[r4,#0x38]
;;;1691   
;;;1692   	return xReturn;
000174  4628              MOV      r0,r5
;;;1693   }
000176  bd70              POP      {r4-r6,pc}
;;;1694   /*-----------------------------------------------------------*/
                          ENDP

                  xQueueGenericSend PROC
;;;594    
;;;595    BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
000178  e92d41ff          PUSH     {r0-r8,lr}
;;;596    {
;;;597    BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
00017c  2600              MOVS     r6,#0
00017e  b082              SUB      sp,sp,#8              ;596
000180  461d              MOV      r5,r3                 ;596
000182  4688              MOV      r8,r1                 ;596
;;;598    TimeOut_t xTimeOut;
;;;599    Queue_t * const pxQueue = ( Queue_t * ) xQueue;
000184  0004              MOVS     r4,r0
000186  d003              BEQ      |L1.400|
;;;600    
;;;601    	configASSERT( pxQueue );
;;;602    	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
000188  f1b80f00          CMP      r8,#0
00018c  d003              BEQ      |L1.406|
00018e  e007              B        |L1.416|
                  |L1.400|
000190  f7fffffe          BL       ulPortSetInterruptMask
                  |L1.404|
000194  e7fe              B        |L1.404|
                  |L1.406|
000196  6c20              LDR      r0,[r4,#0x40]
000198  b110              CBZ      r0,|L1.416|
00019a  f7fffffe          BL       ulPortSetInterruptMask
                  |L1.414|
00019e  e7fe              B        |L1.414|
                  |L1.416|
;;;603    	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
0001a0  2d02              CMP      r5,#2
0001a2  d105              BNE      |L1.432|
0001a4  6be0              LDR      r0,[r4,#0x3c]
0001a6  2801              CMP      r0,#1
0001a8  d002              BEQ      |L1.432|
0001aa  f7fffffe          BL       ulPortSetInterruptMask
                  |L1.430|
0001ae  e7fe              B        |L1.430|
                  |L1.432|
;;;604    	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
;;;605    	{
;;;606    		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
0001b0  f7fffffe          BL       xTaskGetSchedulerState
0001b4  2700              MOVS     r7,#0
0001b6  b920              CBNZ     r0,|L1.450|
0001b8  9804              LDR      r0,[sp,#0x10]
0001ba  b110              CBZ      r0,|L1.450|
0001bc  f7fffffe          BL       ulPortSetInterruptMask
                  |L1.448|
0001c0  e7fe              B        |L1.448|
                  |L1.450|
;;;607    	}
;;;608    	#endif
;;;609    
;;;610    
;;;611    	/* This function relaxes the coding standard somewhat to allow return
;;;612    	statements within the function itself.  This is done in the interest
;;;613    	of execution time efficiency. */
;;;614    	for( ;; )
;;;615    	{
;;;616    		taskENTER_CRITICAL();
0001c2  f7fffffe          BL       vPortEnterCritical
;;;617    		{
;;;618    			/* Is there room on the queue now?  The running task must be
;;;619    			the highest priority task wanting to access the queue.  If
;;;620    			the head item in the queue is to be overwritten then it does
;;;621    			not matter if the queue is full. */
;;;622    			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
0001c6  6ba0              LDR      r0,[r4,#0x38]
0001c8  6be1              LDR      r1,[r4,#0x3c]
0001ca  4288              CMP      r0,r1
0001cc  d305              BCC      |L1.474|
0001ce  2d02              CMP      r5,#2
0001d0  d003              BEQ      |L1.474|
;;;623    			{
;;;624    				traceQUEUE_SEND( pxQueue );
;;;625    				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
;;;626    
;;;627    				#if ( configUSE_QUEUE_SETS == 1 )
;;;628    				{
;;;629    					if( pxQueue->pxQueueSetContainer != NULL )
;;;630    					{
;;;631    						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) == pdTRUE )
;;;632    						{
;;;633    							/* The queue is a member of a queue set, and posting
;;;634    							to the queue set caused a higher priority task to
;;;635    							unblock. A context switch is required. */
;;;636    							queueYIELD_IF_USING_PREEMPTION();
;;;637    						}
;;;638    						else
;;;639    						{
;;;640    							mtCOVERAGE_TEST_MARKER();
;;;641    						}
;;;642    					}
;;;643    					else
;;;644    					{
;;;645    						/* If there was a task waiting for data to arrive on the
;;;646    						queue then unblock it now. */
;;;647    						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;648    						{
;;;649    							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
;;;650    							{
;;;651    								/* The unblocked task has a priority higher than
;;;652    								our own so yield immediately.  Yes it is ok to
;;;653    								do this from within the critical section - the
;;;654    								kernel takes care of that. */
;;;655    								queueYIELD_IF_USING_PREEMPTION();
;;;656    							}
;;;657    							else
;;;658    							{
;;;659    								mtCOVERAGE_TEST_MARKER();
;;;660    							}
;;;661    						}
;;;662    						else if( xYieldRequired != pdFALSE )
;;;663    						{
;;;664    							/* This path is a special case that will only get
;;;665    							executed if the task was holding multiple mutexes
;;;666    							and the mutexes were given back in an order that is
;;;667    							different to that in which they were taken. */
;;;668    							queueYIELD_IF_USING_PREEMPTION();
;;;669    						}
;;;670    						else
;;;671    						{
;;;672    							mtCOVERAGE_TEST_MARKER();
;;;673    						}
;;;674    					}
;;;675    				}
;;;676    				#else /* configUSE_QUEUE_SETS */
;;;677    				{
;;;678    					/* If there was a task waiting for data to arrive on the
;;;679    					queue then unblock it now. */
;;;680    					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;681    					{
;;;682    						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
;;;683    						{
;;;684    							/* The unblocked task has a priority higher than
;;;685    							our own so yield immediately.  Yes it is ok to do
;;;686    							this from within the critical section - the kernel
;;;687    							takes care of that. */
;;;688    							queueYIELD_IF_USING_PREEMPTION();
;;;689    						}
;;;690    						else
;;;691    						{
;;;692    							mtCOVERAGE_TEST_MARKER();
;;;693    						}
;;;694    					}
;;;695    					else if( xYieldRequired != pdFALSE )
;;;696    					{
;;;697    						/* This path is a special case that will only get
;;;698    						executed if the task was holding multiple mutexes and
;;;699    						the mutexes were given back in an order that is
;;;700    						different to that in which they were taken. */
;;;701    						queueYIELD_IF_USING_PREEMPTION();
;;;702    					}
;;;703    					else
;;;704    					{
;;;705    						mtCOVERAGE_TEST_MARKER();
;;;706    					}
;;;707    				}
;;;708    				#endif /* configUSE_QUEUE_SETS */
;;;709    
;;;710    				taskEXIT_CRITICAL();
;;;711    				return pdPASS;
;;;712    			}
;;;713    			else
;;;714    			{
;;;715    				if( xTicksToWait == ( TickType_t ) 0 )
0001d2  9804              LDR      r0,[sp,#0x10]
0001d4  b1c0              CBZ      r0,|L1.520|
;;;716    				{
;;;717    					/* The queue was full and no block time is specified (or
;;;718    					the block time has expired) so leave now. */
;;;719    					taskEXIT_CRITICAL();
;;;720    
;;;721    					/* Return to the original privilege level before exiting
;;;722    					the function. */
;;;723    					traceQUEUE_SEND_FAILED( pxQueue );
;;;724    					return errQUEUE_FULL;
;;;725    				}
;;;726    				else if( xEntryTimeSet == pdFALSE )
0001d6  b1d6              CBZ      r6,|L1.526|
0001d8  e01d              B        |L1.534|
                  |L1.474|
0001da  462a              MOV      r2,r5                 ;625
0001dc  4641              MOV      r1,r8                 ;625
0001de  4620              MOV      r0,r4                 ;625
0001e0  f7fffffe          BL       prvCopyDataToQueue
0001e4  6a61              LDR      r1,[r4,#0x24]         ;680
0001e6  b131              CBZ      r1,|L1.502|
0001e8  f1040024          ADD      r0,r4,#0x24           ;682
0001ec  f7fffffe          BL       xTaskRemoveFromEventList
0001f0  2801              CMP      r0,#1                 ;682
0001f2  d001              BEQ      |L1.504|
0001f4  e002              B        |L1.508|
                  |L1.502|
0001f6  b108              CBZ      r0,|L1.508|
                  |L1.504|
0001f8  f7fffffe          BL       vPortYield
                  |L1.508|
0001fc  f7fffffe          BL       vPortExitCritical
000200  2001              MOVS     r0,#1                 ;711
                  |L1.514|
;;;727    				{
;;;728    					/* The queue was full and a block time was specified so
;;;729    					configure the timeout structure. */
;;;730    					vTaskSetTimeOutState( &xTimeOut );
;;;731    					xEntryTimeSet = pdTRUE;
;;;732    				}
;;;733    				else
;;;734    				{
;;;735    					/* Entry time was already set. */
;;;736    					mtCOVERAGE_TEST_MARKER();
;;;737    				}
;;;738    			}
;;;739    		}
;;;740    		taskEXIT_CRITICAL();
;;;741    
;;;742    		/* Interrupts and other tasks can send to and receive from the queue
;;;743    		now the critical section has been exited. */
;;;744    
;;;745    		vTaskSuspendAll();
;;;746    		prvLockQueue( pxQueue );
;;;747    
;;;748    		/* Update the timeout state to see if it has expired yet. */
;;;749    		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
;;;750    		{
;;;751    			if( prvIsQueueFull( pxQueue ) != pdFALSE )
;;;752    			{
;;;753    				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
;;;754    				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
;;;755    
;;;756    				/* Unlocking the queue means queue events can effect the
;;;757    				event list.  It is possible	that interrupts occurring now
;;;758    				remove this task from the event	list again - but as the
;;;759    				scheduler is suspended the task will go onto the pending
;;;760    				ready last instead of the actual ready list. */
;;;761    				prvUnlockQueue( pxQueue );
;;;762    
;;;763    				/* Resuming the scheduler will move tasks from the pending
;;;764    				ready list into the ready list - so it is feasible that this
;;;765    				task is already in a ready list before it yields - in which
;;;766    				case the yield will not cause a context switch unless there
;;;767    				is also a higher priority task in the pending ready list. */
;;;768    				if( xTaskResumeAll() == pdFALSE )
;;;769    				{
;;;770    					portYIELD_WITHIN_API();
;;;771    				}
;;;772    			}
;;;773    			else
;;;774    			{
;;;775    				/* Try again. */
;;;776    				prvUnlockQueue( pxQueue );
;;;777    				( void ) xTaskResumeAll();
;;;778    			}
;;;779    		}
;;;780    		else
;;;781    		{
;;;782    			/* The timeout has expired. */
;;;783    			prvUnlockQueue( pxQueue );
;;;784    			( void ) xTaskResumeAll();
;;;785    
;;;786    			/* Return to the original privilege level before exiting the
;;;787    			function. */
;;;788    			traceQUEUE_SEND_FAILED( pxQueue );
;;;789    			return errQUEUE_FULL;
;;;790    		}
;;;791    	}
;;;792    }
000202  b006              ADD      sp,sp,#0x18
                  |L1.516|
000204  e8bd81f0          POP      {r4-r8,pc}
                  |L1.520|
000208  f7fffffe          BL       vPortExitCritical
00020c  e01d              B        |L1.586|
                  |L1.526|
00020e  4668              MOV      r0,sp                 ;730
000210  f7fffffe          BL       vTaskSetTimeOutState
000214  2601              MOVS     r6,#1                 ;731
                  |L1.534|
000216  f7fffffe          BL       vPortExitCritical
00021a  f7fffffe          BL       vTaskSuspendAll
00021e  f7fffffe          BL       vPortEnterCritical
000222  6c60              LDR      r0,[r4,#0x44]         ;746
000224  1c40              ADDS     r0,r0,#1              ;746
000226  d100              BNE      |L1.554|
000228  6467              STR      r7,[r4,#0x44]         ;746
                  |L1.554|
00022a  6ca0              LDR      r0,[r4,#0x48]         ;746
00022c  1c40              ADDS     r0,r0,#1              ;746
00022e  d100              BNE      |L1.562|
000230  64a7              STR      r7,[r4,#0x48]         ;746
                  |L1.562|
000232  f7fffffe          BL       vPortExitCritical
000236  a904              ADD      r1,sp,#0x10           ;749
000238  4668              MOV      r0,sp                 ;749
00023a  f7fffffe          BL       xTaskCheckForTimeOut
00023e  b130              CBZ      r0,|L1.590|
000240  4620              MOV      r0,r4                 ;783
000242  f7fffffe          BL       prvUnlockQueue
000246  f7fffffe          BL       xTaskResumeAll
                  |L1.586|
00024a  2000              MOVS     r0,#0                 ;789
00024c  e7d9              B        |L1.514|
                  |L1.590|
00024e  f7fffffe          BL       vPortEnterCritical
000252  6ba0              LDR      r0,[r4,#0x38]
000254  6be1              LDR      r1,[r4,#0x3c]
000256  4288              CMP      r0,r1
000258  d110              BNE      |L1.636|
00025a  f7fffffe          BL       vPortExitCritical
00025e  f1040010          ADD      r0,r4,#0x10           ;754
000262  9904              LDR      r1,[sp,#0x10]         ;754
000264  f7fffffe          BL       vTaskPlaceOnEventList
000268  4620              MOV      r0,r4                 ;761
00026a  f7fffffe          BL       prvUnlockQueue
00026e  f7fffffe          BL       xTaskResumeAll
000272  2800              CMP      r0,#0                 ;768
000274  d1a5              BNE      |L1.450|
000276  f7fffffe          BL       vPortYield
00027a  e7a2              B        |L1.450|
                  |L1.636|
00027c  f7fffffe          BL       vPortExitCritical
000280  4620              MOV      r0,r4                 ;776
000282  f7fffffe          BL       prvUnlockQueue
000286  f7fffffe          BL       xTaskResumeAll
00028a  e79a              B        |L1.450|
;;;793    /*-----------------------------------------------------------*/
                          ENDP

                  xQueueCreateMutex PROC
;;;375    
;;;376    	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
00028c  b510              PUSH     {r4,lr}
;;;377    	{
;;;378    	Queue_t *pxNewQueue;
;;;379    
;;;380    		/* Prevent compiler warnings about unused parameters if
;;;381    		configUSE_TRACE_FACILITY does not equal 1. */
;;;382    		( void ) ucQueueType;
;;;383    
;;;384    		/* Allocate the new queue structure. */
;;;385    		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
00028e  204c              MOVS     r0,#0x4c
000290  f7fffffe          BL       pvPortMalloc
000294  0004              MOVS     r4,r0
;;;386    		if( pxNewQueue != NULL )
000296  d01b              BEQ      |L1.720|
;;;387    		{
;;;388    			/* Information required for priority inheritance. */
;;;389    			pxNewQueue->pxMutexHolder = NULL;
000298  2000              MOVS     r0,#0
;;;390    			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
00029a  6060              STR      r0,[r4,#4]
;;;391    
;;;392    			/* Queues used as a mutex no data is actually copied into or out
;;;393    			of the queue. */
;;;394    			pxNewQueue->pcWriteTo = NULL;
00029c  6020              STR      r0,[r4,#0]
;;;395    			pxNewQueue->u.pcReadFrom = NULL;
00029e  60a0              STR      r0,[r4,#8]
;;;396    
;;;397    			/* Each mutex has a length of 1 (like a binary semaphore) and
;;;398    			an item size of 0 as nothing is actually copied into or out
;;;399    			of the mutex. */
;;;400    			pxNewQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
0002a0  60e0              STR      r0,[r4,#0xc]
0002a2  63a0              STR      r0,[r4,#0x38]
;;;401    			pxNewQueue->uxLength = ( UBaseType_t ) 1U;
0002a4  2101              MOVS     r1,#1
0002a6  e9c4100f          STRD     r1,r0,[r4,#0x3c]
;;;402    			pxNewQueue->uxItemSize = ( UBaseType_t ) 0U;
;;;403    			pxNewQueue->xRxLock = queueUNLOCKED;
0002aa  1e40              SUBS     r0,r0,#1
0002ac  6460              STR      r0,[r4,#0x44]
;;;404    			pxNewQueue->xTxLock = queueUNLOCKED;
0002ae  64a0              STR      r0,[r4,#0x48]
;;;405    
;;;406    			#if ( configUSE_TRACE_FACILITY == 1 )
;;;407    			{
;;;408    				pxNewQueue->ucQueueType = ucQueueType;
;;;409    			}
;;;410    			#endif
;;;411    
;;;412    			#if ( configUSE_QUEUE_SETS == 1 )
;;;413    			{
;;;414    				pxNewQueue->pxQueueSetContainer = NULL;
;;;415    			}
;;;416    			#endif
;;;417    
;;;418    			/* Ensure the event queues start with the correct state. */
;;;419    			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
0002b0  f1040010          ADD      r0,r4,#0x10
0002b4  f7fffffe          BL       vListInitialise
;;;420    			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
0002b8  f1040024          ADD      r0,r4,#0x24
0002bc  f7fffffe          BL       vListInitialise
;;;421    
;;;422    			traceCREATE_MUTEX( pxNewQueue );
;;;423    
;;;424    			/* Start with the semaphore in the expected state. */
;;;425    			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
0002c0  2300              MOVS     r3,#0
0002c2  461a              MOV      r2,r3
0002c4  4619              MOV      r1,r3
0002c6  4620              MOV      r0,r4
0002c8  f7fffffe          BL       xQueueGenericSend
;;;426    		}
;;;427    		else
;;;428    		{
;;;429    			traceCREATE_MUTEX_FAILED();
;;;430    		}
;;;431    
;;;432    		configASSERT( pxNewQueue );
;;;433    		return pxNewQueue;
0002cc  4620              MOV      r0,r4
;;;434    	}
0002ce  bd10              POP      {r4,pc}
                  |L1.720|
0002d0  f7fffffe          BL       ulPortSetInterruptMask
                  |L1.724|
0002d4  e7fe              B        |L1.724|
;;;435    
                          ENDP

                  xQueueGenericSendFromISR PROC
;;;1039   
;;;1040   BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
0002d6  e92d41f0          PUSH     {r4-r8,lr}
;;;1041   {
0002da  461e              MOV      r6,r3
0002dc  4615              MOV      r5,r2
0002de  460f              MOV      r7,r1
;;;1042   BaseType_t xReturn;
;;;1043   UBaseType_t uxSavedInterruptStatus;
;;;1044   Queue_t * const pxQueue = ( Queue_t * ) xQueue;
0002e0  0004              MOVS     r4,r0
0002e2  d001              BEQ      |L1.744|
;;;1045   
;;;1046   	configASSERT( pxQueue );
;;;1047   	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
0002e4  b11f              CBZ      r7,|L1.750|
0002e6  e007              B        |L1.760|
                  |L1.744|
0002e8  f7fffffe          BL       ulPortSetInterruptMask
                  |L1.748|
0002ec  e7fe              B        |L1.748|
                  |L1.750|
0002ee  6c20              LDR      r0,[r4,#0x40]
0002f0  b110              CBZ      r0,|L1.760|
0002f2  f7fffffe          BL       ulPortSetInterruptMask
                  |L1.758|
0002f6  e7fe              B        |L1.758|
                  |L1.760|
;;;1048   	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
0002f8  2e02              CMP      r6,#2
0002fa  d105              BNE      |L1.776|
0002fc  6be0              LDR      r0,[r4,#0x3c]
0002fe  2801              CMP      r0,#1
000300  d002              BEQ      |L1.776|
000302  f7fffffe          BL       ulPortSetInterruptMask
                  |L1.774|
000306  e7fe              B        |L1.774|
                  |L1.776|
;;;1049   
;;;1050   	/* RTOS ports that support interrupt nesting have the concept of a maximum
;;;1051   	system call (or maximum API call) interrupt priority.  Interrupts that are
;;;1052   	above the maximum system call priority are kept permanently enabled, even
;;;1053   	when the RTOS kernel is in a critical section, but cannot make any calls to
;;;1054   	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
;;;1055   	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1056   	failure if a FreeRTOS API function is called from an interrupt that has been
;;;1057   	assigned a priority above the configured maximum system call priority.
;;;1058   	Only FreeRTOS functions that end in FromISR can be called from interrupts
;;;1059   	that have been assigned a priority at or (logically) below the maximum
;;;1060   	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
;;;1061   	safe API to ensure interrupt entry is as fast and as simple as possible.
;;;1062   	More information (albeit Cortex-M specific) is provided on the following
;;;1063   	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1064   	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
000308  f7fffffe          BL       vPortValidateInterruptPriority
;;;1065   
;;;1066   	/* Similar to xQueueGenericSend, except without blocking if there is no room
;;;1067   	in the queue.  Also don't directly wake a task that was blocked on a queue
;;;1068   	read, instead return a flag to say whether a context switch is required or
;;;1069   	not (i.e. has a task with a higher priority than us been woken by this
;;;1070   	post). */
;;;1071   	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
00030c  f7fffffe          BL       ulPortSetInterruptMask
000310  4680              MOV      r8,r0
;;;1072   	{
;;;1073   		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
000312  6ba0              LDR      r0,[r4,#0x38]
000314  6be1              LDR      r1,[r4,#0x3c]
000316  4288              CMP      r0,r1
000318  d307              BCC      |L1.810|
00031a  2e02              CMP      r6,#2
00031c  d005              BEQ      |L1.810|
;;;1074   		{
;;;1075   			traceQUEUE_SEND_FROM_ISR( pxQueue );
;;;1076   
;;;1077   			if( prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition ) != pdFALSE )
;;;1078   			{
;;;1079   				/* This is a special case that can only be executed if a task
;;;1080   				holds multiple mutexes and then gives the mutexes back in an
;;;1081   				order that is different to that in which they were taken. */
;;;1082   				if( pxHigherPriorityTaskWoken != NULL )
;;;1083   				{
;;;1084   					*pxHigherPriorityTaskWoken = pdTRUE;
;;;1085   				}
;;;1086   				else
;;;1087   				{
;;;1088   					mtCOVERAGE_TEST_MARKER();
;;;1089   				}
;;;1090   			}
;;;1091   
;;;1092   			/* The event list is not altered if the queue is locked.  This will
;;;1093   			be done when the queue is unlocked later. */
;;;1094   			if( pxQueue->xTxLock == queueUNLOCKED )
;;;1095   			{
;;;1096   				#if ( configUSE_QUEUE_SETS == 1 )
;;;1097   				{
;;;1098   					if( pxQueue->pxQueueSetContainer != NULL )
;;;1099   					{
;;;1100   						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) == pdTRUE )
;;;1101   						{
;;;1102   							/* The queue is a member of a queue set, and posting
;;;1103   							to the queue set caused a higher priority task to
;;;1104   							unblock.  A context switch is required. */
;;;1105   							if( pxHigherPriorityTaskWoken != NULL )
;;;1106   							{
;;;1107   								*pxHigherPriorityTaskWoken = pdTRUE;
;;;1108   							}
;;;1109   							else
;;;1110   							{
;;;1111   								mtCOVERAGE_TEST_MARKER();
;;;1112   							}
;;;1113   						}
;;;1114   						else
;;;1115   						{
;;;1116   							mtCOVERAGE_TEST_MARKER();
;;;1117   						}
;;;1118   					}
;;;1119   					else
;;;1120   					{
;;;1121   						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;1122   						{
;;;1123   							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
;;;1124   							{
;;;1125   								/* The task waiting has a higher priority so
;;;1126   								record that a context switch is required. */
;;;1127   								if( pxHigherPriorityTaskWoken != NULL )
;;;1128   								{
;;;1129   									*pxHigherPriorityTaskWoken = pdTRUE;
;;;1130   								}
;;;1131   								else
;;;1132   								{
;;;1133   									mtCOVERAGE_TEST_MARKER();
;;;1134   								}
;;;1135   							}
;;;1136   							else
;;;1137   							{
;;;1138   								mtCOVERAGE_TEST_MARKER();
;;;1139   							}
;;;1140   						}
;;;1141   						else
;;;1142   						{
;;;1143   							mtCOVERAGE_TEST_MARKER();
;;;1144   						}
;;;1145   					}
;;;1146   				}
;;;1147   				#else /* configUSE_QUEUE_SETS */
;;;1148   				{
;;;1149   					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;1150   					{
;;;1151   						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
;;;1152   						{
;;;1153   							/* The task waiting has a higher priority so record that a
;;;1154   							context	switch is required. */
;;;1155   							if( pxHigherPriorityTaskWoken != NULL )
;;;1156   							{
;;;1157   								*pxHigherPriorityTaskWoken = pdTRUE;
;;;1158   							}
;;;1159   							else
;;;1160   							{
;;;1161   								mtCOVERAGE_TEST_MARKER();
;;;1162   							}
;;;1163   						}
;;;1164   						else
;;;1165   						{
;;;1166   							mtCOVERAGE_TEST_MARKER();
;;;1167   						}
;;;1168   					}
;;;1169   					else
;;;1170   					{
;;;1171   						mtCOVERAGE_TEST_MARKER();
;;;1172   					}
;;;1173   				}
;;;1174   				#endif /* configUSE_QUEUE_SETS */
;;;1175   			}
;;;1176   			else
;;;1177   			{
;;;1178   				/* Increment the lock count so the task that unlocks the queue
;;;1179   				knows that data was posted while it was locked. */
;;;1180   				++( pxQueue->xTxLock );
;;;1181   			}
;;;1182   
;;;1183   			xReturn = pdPASS;
;;;1184   		}
;;;1185   		else
;;;1186   		{
;;;1187   			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
;;;1188   			xReturn = errQUEUE_FULL;
00031e  2400              MOVS     r4,#0
                  |L1.800|
;;;1189   		}
;;;1190   	}
;;;1191   	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
000320  4640              MOV      r0,r8
000322  f7fffffe          BL       vPortClearInterruptMask
;;;1192   
;;;1193   	return xReturn;
000326  4620              MOV      r0,r4
;;;1194   }
000328  e76c              B        |L1.516|
                  |L1.810|
00032a  4632              MOV      r2,r6                 ;1077
00032c  4639              MOV      r1,r7                 ;1077
00032e  4620              MOV      r0,r4                 ;1077
000330  f7fffffe          BL       prvCopyDataToQueue
000334  2601              MOVS     r6,#1                 ;1048
000336  b108              CBZ      r0,|L1.828|
000338  b105              CBZ      r5,|L1.828|
00033a  602e              STR      r6,[r5,#0]            ;1084
                  |L1.828|
00033c  6ca0              LDR      r0,[r4,#0x48]         ;1094
00033e  1c40              ADDS     r0,r0,#1              ;1094
000340  d004              BEQ      |L1.844|
000342  6ca0              LDR      r0,[r4,#0x48]         ;1180
000344  1c40              ADDS     r0,r0,#1              ;1180
000346  64a0              STR      r0,[r4,#0x48]         ;1180
                  |L1.840|
000348  2401              MOVS     r4,#1                 ;1183
00034a  e7e9              B        |L1.800|
                  |L1.844|
00034c  6a60              LDR      r0,[r4,#0x24]         ;1149
00034e  2800              CMP      r0,#0                 ;1149
000350  d0fa              BEQ      |L1.840|
000352  f1040024          ADD      r0,r4,#0x24           ;1151
000356  f7fffffe          BL       xTaskRemoveFromEventList
00035a  2800              CMP      r0,#0                 ;1151
00035c  d0f4              BEQ      |L1.840|
00035e  2d00              CMP      r5,#0                 ;1155
000360  d0f2              BEQ      |L1.840|
000362  602e              STR      r6,[r5,#0]            ;1157
000364  e7f0              B        |L1.840|
;;;1195   /*-----------------------------------------------------------*/
                          ENDP

                  prvCopyDataFromQueue PROC
;;;1695   
;;;1696   static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
000366  b430              PUSH     {r4,r5}
;;;1697   {
000368  6c02              LDR      r2,[r0,#0x40]
00036a  460b              MOV      r3,r1
00036c  2a00              CMP      r2,#0
00036e  d00b              BEQ      |L1.904|
;;;1698   	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
;;;1699   	{
;;;1700   		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
000370  68c1              LDR      r1,[r0,#0xc]
000372  4411              ADD      r1,r1,r2
;;;1701   		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
000374  60c1              STR      r1,[r0,#0xc]
000376  6844              LDR      r4,[r0,#4]
000378  42a1              CMP      r1,r4
00037a  d301              BCC      |L1.896|
;;;1702   		{
;;;1703   			pxQueue->u.pcReadFrom = pxQueue->pcHead;
00037c  6801              LDR      r1,[r0,#0]
00037e  60c1              STR      r1,[r0,#0xc]
                  |L1.896|
;;;1704   		}
;;;1705   		else
;;;1706   		{
;;;1707   			mtCOVERAGE_TEST_MARKER();
;;;1708   		}
;;;1709   		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
000380  bc30              POP      {r4,r5}
000382  4618              MOV      r0,r3
000384  f7ffbffe          B.W      __aeabi_memcpy
                  |L1.904|
;;;1710   	}
;;;1711   }
000388  bc30              POP      {r4,r5}
00038a  4770              BX       lr
;;;1712   /*-----------------------------------------------------------*/
                          ENDP

                  xQueueGenericReceive PROC
;;;1196   
;;;1197   BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
00038c  e92d41ff          PUSH     {r0-r8,lr}
;;;1198   {
;;;1199   BaseType_t xEntryTimeSet = pdFALSE;
000390  2500              MOVS     r5,#0
000392  b082              SUB      sp,sp,#8              ;1198
000394  4698              MOV      r8,r3                 ;1198
000396  460e              MOV      r6,r1                 ;1198
;;;1200   TimeOut_t xTimeOut;
;;;1201   int8_t *pcOriginalReadPosition;
;;;1202   Queue_t * const pxQueue = ( Queue_t * ) xQueue;
000398  0004              MOVS     r4,r0
00039a  d001              BEQ      |L1.928|
;;;1203   
;;;1204   	configASSERT( pxQueue );
;;;1205   	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
00039c  b11e              CBZ      r6,|L1.934|
00039e  e007              B        |L1.944|
                  |L1.928|
0003a0  f7fffffe          BL       ulPortSetInterruptMask
                  |L1.932|
0003a4  e7fe              B        |L1.932|
                  |L1.934|
0003a6  6c20              LDR      r0,[r4,#0x40]
0003a8  b110              CBZ      r0,|L1.944|
0003aa  f7fffffe          BL       ulPortSetInterruptMask
                  |L1.942|
0003ae  e7fe              B        |L1.942|
                  |L1.944|
;;;1206   	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
;;;1207   	{
;;;1208   		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
0003b0  f7fffffe          BL       xTaskGetSchedulerState
0003b4  2700              MOVS     r7,#0
0003b6  b920              CBNZ     r0,|L1.962|
0003b8  9804              LDR      r0,[sp,#0x10]
0003ba  b110              CBZ      r0,|L1.962|
0003bc  f7fffffe          BL       ulPortSetInterruptMask
                  |L1.960|
0003c0  e7fe              B        |L1.960|
                  |L1.962|
;;;1209   	}
;;;1210   	#endif
;;;1211   
;;;1212   	/* This function relaxes the coding standard somewhat to allow return
;;;1213   	statements within the function itself.  This is done in the interest
;;;1214   	of execution time efficiency. */
;;;1215   
;;;1216   	for( ;; )
;;;1217   	{
;;;1218   		taskENTER_CRITICAL();
0003c2  f7fffffe          BL       vPortEnterCritical
;;;1219   		{
;;;1220   			/* Is there data in the queue now?  To be running we must be
;;;1221   			the highest priority task wanting to access the queue. */
;;;1222   			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
0003c6  6ba0              LDR      r0,[r4,#0x38]
0003c8  b340              CBZ      r0,|L1.1052|
;;;1223   			{
;;;1224   				/* Remember the read position in case the queue is only being
;;;1225   				peeked. */
;;;1226   				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
;;;1227   
;;;1228   				prvCopyDataFromQueue( pxQueue, pvBuffer );
0003ca  4631              MOV      r1,r6
0003cc  4620              MOV      r0,r4
0003ce  68e5              LDR      r5,[r4,#0xc]
0003d0  f7fffffe          BL       prvCopyDataFromQueue
;;;1229   
;;;1230   				if( xJustPeeking == pdFALSE )
0003d4  f1b80f00          CMP      r8,#0
0003d8  d00e              BEQ      |L1.1016|
;;;1231   				{
;;;1232   					traceQUEUE_RECEIVE( pxQueue );
;;;1233   
;;;1234   					/* Actually removing data, not just peeking. */
;;;1235   					--( pxQueue->uxMessagesWaiting );
;;;1236   
;;;1237   					#if ( configUSE_MUTEXES == 1 )
;;;1238   					{
;;;1239   						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
;;;1240   						{
;;;1241   							/* Record the information required to implement
;;;1242   							priority inheritance should it become necessary. */
;;;1243   							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
;;;1244   						}
;;;1245   						else
;;;1246   						{
;;;1247   							mtCOVERAGE_TEST_MARKER();
;;;1248   						}
;;;1249   					}
;;;1250   					#endif /* configUSE_MUTEXES */
;;;1251   
;;;1252   					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
;;;1253   					{
;;;1254   						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
;;;1255   						{
;;;1256   							queueYIELD_IF_USING_PREEMPTION();
;;;1257   						}
;;;1258   						else
;;;1259   						{
;;;1260   							mtCOVERAGE_TEST_MARKER();
;;;1261   						}
;;;1262   					}
;;;1263   					else
;;;1264   					{
;;;1265   						mtCOVERAGE_TEST_MARKER();
;;;1266   					}
;;;1267   				}
;;;1268   				else
;;;1269   				{
;;;1270   					traceQUEUE_PEEK( pxQueue );
;;;1271   
;;;1272   					/* The data is not being removed, so reset the read
;;;1273   					pointer. */
;;;1274   					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
;;;1275   
;;;1276   					/* The data is being left in the queue, so see if there are
;;;1277   					any other tasks waiting for the data. */
;;;1278   					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
0003da  60e5              STR      r5,[r4,#0xc]
0003dc  6a60              LDR      r0,[r4,#0x24]
0003de  b138              CBZ      r0,|L1.1008|
;;;1279   					{
;;;1280   						/* Tasks that are removed from the event list will get added to
;;;1281   						the pending ready list as the scheduler is still suspended. */
;;;1282   						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
0003e0  f1040024          ADD      r0,r4,#0x24
0003e4  f7fffffe          BL       xTaskRemoveFromEventList
0003e8  b110              CBZ      r0,|L1.1008|
;;;1283   						{
;;;1284   							/* The task waiting has a higher priority than this task. */
;;;1285   							queueYIELD_IF_USING_PREEMPTION();
0003ea  bf00              NOP      
                  |L1.1004|
0003ec  f7fffffe          BL       vPortYield
                  |L1.1008|
;;;1286   						}
;;;1287   						else
;;;1288   						{
;;;1289   							mtCOVERAGE_TEST_MARKER();
;;;1290   						}
;;;1291   					}
;;;1292   					else
;;;1293   					{
;;;1294   						mtCOVERAGE_TEST_MARKER();
;;;1295   					}
;;;1296   				}
;;;1297   
;;;1298   				taskEXIT_CRITICAL();
0003f0  f7fffffe          BL       vPortExitCritical
;;;1299   				return pdPASS;
0003f4  2001              MOVS     r0,#1
;;;1300   			}
;;;1301   			else
;;;1302   			{
;;;1303   				if( xTicksToWait == ( TickType_t ) 0 )
;;;1304   				{
;;;1305   					/* The queue was empty and no block time is specified (or
;;;1306   					the block time has expired) so leave now. */
;;;1307   					taskEXIT_CRITICAL();
;;;1308   					traceQUEUE_RECEIVE_FAILED( pxQueue );
;;;1309   					return errQUEUE_EMPTY;
;;;1310   				}
;;;1311   				else if( xEntryTimeSet == pdFALSE )
;;;1312   				{
;;;1313   					/* The queue was empty and a block time was specified so
;;;1314   					configure the timeout structure. */
;;;1315   					vTaskSetTimeOutState( &xTimeOut );
;;;1316   					xEntryTimeSet = pdTRUE;
;;;1317   				}
;;;1318   				else
;;;1319   				{
;;;1320   					/* Entry time was already set. */
;;;1321   					mtCOVERAGE_TEST_MARKER();
;;;1322   				}
;;;1323   			}
;;;1324   		}
;;;1325   		taskEXIT_CRITICAL();
;;;1326   
;;;1327   		/* Interrupts and other tasks can send to and receive from the queue
;;;1328   		now the critical section has been exited. */
;;;1329   
;;;1330   		vTaskSuspendAll();
;;;1331   		prvLockQueue( pxQueue );
;;;1332   
;;;1333   		/* Update the timeout state to see if it has expired yet. */
;;;1334   		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
;;;1335   		{
;;;1336   			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
;;;1337   			{
;;;1338   				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
;;;1339   
;;;1340   				#if ( configUSE_MUTEXES == 1 )
;;;1341   				{
;;;1342   					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
;;;1343   					{
;;;1344   						taskENTER_CRITICAL();
;;;1345   						{
;;;1346   							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
;;;1347   						}
;;;1348   						taskEXIT_CRITICAL();
;;;1349   					}
;;;1350   					else
;;;1351   					{
;;;1352   						mtCOVERAGE_TEST_MARKER();
;;;1353   					}
;;;1354   				}
;;;1355   				#endif
;;;1356   
;;;1357   				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
;;;1358   				prvUnlockQueue( pxQueue );
;;;1359   				if( xTaskResumeAll() == pdFALSE )
;;;1360   				{
;;;1361   					portYIELD_WITHIN_API();
;;;1362   				}
;;;1363   				else
;;;1364   				{
;;;1365   					mtCOVERAGE_TEST_MARKER();
;;;1366   				}
;;;1367   			}
;;;1368   			else
;;;1369   			{
;;;1370   				/* Try again. */
;;;1371   				prvUnlockQueue( pxQueue );
;;;1372   				( void ) xTaskResumeAll();
;;;1373   			}
;;;1374   		}
;;;1375   		else
;;;1376   		{
;;;1377   			prvUnlockQueue( pxQueue );
;;;1378   			( void ) xTaskResumeAll();
;;;1379   			traceQUEUE_RECEIVE_FAILED( pxQueue );
;;;1380   			return errQUEUE_EMPTY;
;;;1381   		}
;;;1382   	}
;;;1383   }
0003f6  e704              B        |L1.514|
                  |L1.1016|
0003f8  6ba0              LDR      r0,[r4,#0x38]         ;1235
0003fa  1e40              SUBS     r0,r0,#1              ;1235
0003fc  63a0              STR      r0,[r4,#0x38]         ;1235
0003fe  6820              LDR      r0,[r4,#0]            ;1239
000400  b910              CBNZ     r0,|L1.1032|
000402  f7fffffe          BL       pvTaskIncrementMutexHeldCount
000406  6060              STR      r0,[r4,#4]            ;1243
                  |L1.1032|
000408  6920              LDR      r0,[r4,#0x10]         ;1252
00040a  2800              CMP      r0,#0                 ;1252
00040c  d0f0              BEQ      |L1.1008|
00040e  f1040010          ADD      r0,r4,#0x10           ;1254
000412  f7fffffe          BL       xTaskRemoveFromEventList
000416  2801              CMP      r0,#1                 ;1254
000418  d0e8              BEQ      |L1.1004|
00041a  e7e9              B        |L1.1008|
                  |L1.1052|
00041c  9804              LDR      r0,[sp,#0x10]         ;1303
00041e  b108              CBZ      r0,|L1.1060|
000420  b11d              CBZ      r5,|L1.1066|
000422  e006              B        |L1.1074|
                  |L1.1060|
000424  f7fffffe          BL       vPortExitCritical
000428  e01d              B        |L1.1126|
                  |L1.1066|
00042a  4668              MOV      r0,sp                 ;1315
00042c  f7fffffe          BL       vTaskSetTimeOutState
000430  2501              MOVS     r5,#1                 ;1316
                  |L1.1074|
000432  f7fffffe          BL       vPortExitCritical
000436  f7fffffe          BL       vTaskSuspendAll
00043a  f7fffffe          BL       vPortEnterCritical
00043e  6c60              LDR      r0,[r4,#0x44]         ;1331
000440  1c40              ADDS     r0,r0,#1              ;1331
000442  d100              BNE      |L1.1094|
000444  6467              STR      r7,[r4,#0x44]         ;1331
                  |L1.1094|
000446  6ca0              LDR      r0,[r4,#0x48]         ;1331
000448  1c40              ADDS     r0,r0,#1              ;1331
00044a  d100              BNE      |L1.1102|
00044c  64a7              STR      r7,[r4,#0x48]         ;1331
                  |L1.1102|
00044e  f7fffffe          BL       vPortExitCritical
000452  a904              ADD      r1,sp,#0x10           ;1334
000454  4668              MOV      r0,sp                 ;1334
000456  f7fffffe          BL       xTaskCheckForTimeOut
00045a  b130              CBZ      r0,|L1.1130|
00045c  4620              MOV      r0,r4                 ;1377
00045e  f7fffffe          BL       prvUnlockQueue
000462  f7fffffe          BL       xTaskResumeAll
                  |L1.1126|
000466  2000              MOVS     r0,#0                 ;1380
000468  e6cb              B        |L1.514|
                  |L1.1130|
00046a  f7fffffe          BL       vPortEnterCritical
00046e  6ba0              LDR      r0,[r4,#0x38]
000470  b138              CBZ      r0,|L1.1154|
000472  f7fffffe          BL       vPortExitCritical
000476  4620              MOV      r0,r4                 ;1371
000478  f7fffffe          BL       prvUnlockQueue
00047c  f7fffffe          BL       xTaskResumeAll
000480  e79f              B        |L1.962|
                  |L1.1154|
000482  f7fffffe          BL       vPortExitCritical
000486  6820              LDR      r0,[r4,#0]            ;1372
000488  b930              CBNZ     r0,|L1.1176|
00048a  f7fffffe          BL       vPortEnterCritical
00048e  6860              LDR      r0,[r4,#4]            ;1346
000490  f7fffffe          BL       vTaskPriorityInherit
000494  f7fffffe          BL       vPortExitCritical
                  |L1.1176|
000498  f1040024          ADD      r0,r4,#0x24           ;1357
00049c  9904              LDR      r1,[sp,#0x10]         ;1357
00049e  f7fffffe          BL       vTaskPlaceOnEventList
0004a2  4620              MOV      r0,r4                 ;1358
0004a4  f7fffffe          BL       prvUnlockQueue
0004a8  f7fffffe          BL       xTaskResumeAll
0004ac  2800              CMP      r0,#0                 ;1359
0004ae  d188              BNE      |L1.962|
0004b0  f7fffffe          BL       vPortYield
0004b4  e785              B        |L1.962|
;;;1384   /*-----------------------------------------------------------*/
                          ENDP

                  xQueueReceiveFromISR PROC
;;;1385   
;;;1386   BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
0004b6  e92d41f0          PUSH     {r4-r8,lr}
;;;1387   {
0004ba  4615              MOV      r5,r2
0004bc  460e              MOV      r6,r1
;;;1388   BaseType_t xReturn;
;;;1389   UBaseType_t uxSavedInterruptStatus;
;;;1390   Queue_t * const pxQueue = ( Queue_t * ) xQueue;
0004be  0004              MOVS     r4,r0
0004c0  d001              BEQ      |L1.1222|
;;;1391   
;;;1392   	configASSERT( pxQueue );
;;;1393   	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
0004c2  b11e              CBZ      r6,|L1.1228|
0004c4  e007              B        |L1.1238|
                  |L1.1222|
0004c6  f7fffffe          BL       ulPortSetInterruptMask
                  |L1.1226|
0004ca  e7fe              B        |L1.1226|
                  |L1.1228|
0004cc  6c20              LDR      r0,[r4,#0x40]
0004ce  b110              CBZ      r0,|L1.1238|
0004d0  f7fffffe          BL       ulPortSetInterruptMask
                  |L1.1236|
0004d4  e7fe              B        |L1.1236|
                  |L1.1238|
;;;1394   
;;;1395   	/* RTOS ports that support interrupt nesting have the concept of a maximum
;;;1396   	system call (or maximum API call) interrupt priority.  Interrupts that are
;;;1397   	above the maximum system call priority are kept permanently enabled, even
;;;1398   	when the RTOS kernel is in a critical section, but cannot make any calls to
;;;1399   	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
;;;1400   	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1401   	failure if a FreeRTOS API function is called from an interrupt that has been
;;;1402   	assigned a priority above the configured maximum system call priority.
;;;1403   	Only FreeRTOS functions that end in FromISR can be called from interrupts
;;;1404   	that have been assigned a priority at or (logically) below the maximum
;;;1405   	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
;;;1406   	safe API to ensure interrupt entry is as fast and as simple as possible.
;;;1407   	More information (albeit Cortex-M specific) is provided on the following
;;;1408   	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1409   	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
0004d6  f7fffffe          BL       vPortValidateInterruptPriority
;;;1410   
;;;1411   	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
0004da  f7fffffe          BL       ulPortSetInterruptMask
0004de  4607              MOV      r7,r0
;;;1412   	{
;;;1413   		/* Cannot block in an ISR, so check there is data available. */
;;;1414   		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
0004e0  6ba0              LDR      r0,[r4,#0x38]
0004e2  b1e0              CBZ      r0,|L1.1310|
;;;1415   		{
;;;1416   			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );
;;;1417   
;;;1418   			prvCopyDataFromQueue( pxQueue, pvBuffer );
0004e4  4631              MOV      r1,r6
0004e6  4620              MOV      r0,r4
0004e8  f7fffffe          BL       prvCopyDataFromQueue
;;;1419   			--( pxQueue->uxMessagesWaiting );
0004ec  6ba0              LDR      r0,[r4,#0x38]
0004ee  1e40              SUBS     r0,r0,#1
0004f0  63a0              STR      r0,[r4,#0x38]
;;;1420   
;;;1421   			/* If the queue is locked the event list will not be modified.
;;;1422   			Instead update the lock count so the task that unlocks the queue
;;;1423   			will know that an ISR has removed data while the queue was
;;;1424   			locked. */
;;;1425   			if( pxQueue->xRxLock == queueUNLOCKED )
0004f2  6c60              LDR      r0,[r4,#0x44]
0004f4  1c40              ADDS     r0,r0,#1
0004f6  d004              BEQ      |L1.1282|
;;;1426   			{
;;;1427   				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
;;;1428   				{
;;;1429   					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
;;;1430   					{
;;;1431   						/* The task waiting has a higher priority than us so
;;;1432   						force a context switch. */
;;;1433   						if( pxHigherPriorityTaskWoken != NULL )
;;;1434   						{
;;;1435   							*pxHigherPriorityTaskWoken = pdTRUE;
;;;1436   						}
;;;1437   						else
;;;1438   						{
;;;1439   							mtCOVERAGE_TEST_MARKER();
;;;1440   						}
;;;1441   					}
;;;1442   					else
;;;1443   					{
;;;1444   						mtCOVERAGE_TEST_MARKER();
;;;1445   					}
;;;1446   				}
;;;1447   				else
;;;1448   				{
;;;1449   					mtCOVERAGE_TEST_MARKER();
;;;1450   				}
;;;1451   			}
;;;1452   			else
;;;1453   			{
;;;1454   				/* Increment the lock count so the task that unlocks the queue
;;;1455   				knows that data was removed while it was locked. */
;;;1456   				++( pxQueue->xRxLock );
0004f8  6c60              LDR      r0,[r4,#0x44]
0004fa  1c40              ADDS     r0,r0,#1
0004fc  6460              STR      r0,[r4,#0x44]
                  |L1.1278|
;;;1457   			}
;;;1458   
;;;1459   			xReturn = pdPASS;
0004fe  2401              MOVS     r4,#1
000500  e00e              B        |L1.1312|
                  |L1.1282|
000502  6920              LDR      r0,[r4,#0x10]         ;1427
000504  2800              CMP      r0,#0                 ;1427
000506  d0fa              BEQ      |L1.1278|
000508  f1040010          ADD      r0,r4,#0x10           ;1429
00050c  f7fffffe          BL       xTaskRemoveFromEventList
000510  2800              CMP      r0,#0                 ;1429
000512  d0f4              BEQ      |L1.1278|
000514  2d00              CMP      r5,#0                 ;1433
000516  d0f2              BEQ      |L1.1278|
000518  2001              MOVS     r0,#1                 ;1435
00051a  6028              STR      r0,[r5,#0]            ;1435
00051c  e7ef              B        |L1.1278|
                  |L1.1310|
;;;1460   		}
;;;1461   		else
;;;1462   		{
;;;1463   			xReturn = pdFAIL;
00051e  2400              MOVS     r4,#0
                  |L1.1312|
;;;1464   			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
;;;1465   		}
;;;1466   	}
;;;1467   	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
000520  4638              MOV      r0,r7
000522  f7fffffe          BL       vPortClearInterruptMask
;;;1468   
;;;1469   	return xReturn;
000526  4620              MOV      r0,r4
;;;1470   }
000528  e66c              B        |L1.516|
;;;1471   /*-----------------------------------------------------------*/
                          ENDP

                  xQueuePeekFromISR PROC
;;;1472   
;;;1473   BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
00052a  e92d41f0          PUSH     {r4-r8,lr}
;;;1474   {
00052e  460d              MOV      r5,r1
;;;1475   BaseType_t xReturn;
;;;1476   UBaseType_t uxSavedInterruptStatus;
;;;1477   int8_t *pcOriginalReadPosition;
;;;1478   Queue_t * const pxQueue = ( Queue_t * ) xQueue;
000530  0004              MOVS     r4,r0
000532  d001              BEQ      |L1.1336|
;;;1479   
;;;1480   	configASSERT( pxQueue );
;;;1481   	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
000534  b11d              CBZ      r5,|L1.1342|
000536  e007              B        |L1.1352|
                  |L1.1336|
000538  f7fffffe          BL       ulPortSetInterruptMask
                  |L1.1340|
00053c  e7fe              B        |L1.1340|
                  |L1.1342|
00053e  6c20              LDR      r0,[r4,#0x40]
000540  b110              CBZ      r0,|L1.1352|
000542  f7fffffe          BL       ulPortSetInterruptMask
                  |L1.1350|
000546  e7fe              B        |L1.1350|
                  |L1.1352|
;;;1482   
;;;1483   	/* RTOS ports that support interrupt nesting have the concept of a maximum
;;;1484   	system call (or maximum API call) interrupt priority.  Interrupts that are
;;;1485   	above the maximum system call priority are kept permanently enabled, even
;;;1486   	when the RTOS kernel is in a critical section, but cannot make any calls to
;;;1487   	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
;;;1488   	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1489   	failure if a FreeRTOS API function is called from an interrupt that has been
;;;1490   	assigned a priority above the configured maximum system call priority.
;;;1491   	Only FreeRTOS functions that end in FromISR can be called from interrupts
;;;1492   	that have been assigned a priority at or (logically) below the maximum
;;;1493   	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
;;;1494   	safe API to ensure interrupt entry is as fast and as simple as possible.
;;;1495   	More information (albeit Cortex-M specific) is provided on the following
;;;1496   	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1497   	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
000548  f7fffffe          BL       vPortValidateInterruptPriority
;;;1498   
;;;1499   	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
00054c  f7fffffe          BL       ulPortSetInterruptMask
000550  4606              MOV      r6,r0
;;;1500   	{
;;;1501   		/* Cannot block in an ISR, so check there is data available. */
;;;1502   		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
000552  6ba0              LDR      r0,[r4,#0x38]
000554  b138              CBZ      r0,|L1.1382|
;;;1503   		{
;;;1504   			traceQUEUE_PEEK_FROM_ISR( pxQueue );
;;;1505   
;;;1506   			/* Remember the read position so it can be reset as nothing is
;;;1507   			actually being removed from the queue. */
;;;1508   			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
;;;1509   			prvCopyDataFromQueue( pxQueue, pvBuffer );
000556  4629              MOV      r1,r5
000558  4620              MOV      r0,r4
00055a  68e7              LDR      r7,[r4,#0xc]
00055c  f7fffffe          BL       prvCopyDataFromQueue
;;;1510   			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
;;;1511   
;;;1512   			xReturn = pdPASS;
000560  60e7              STR      r7,[r4,#0xc]
000562  2401              MOVS     r4,#1
000564  e000              B        |L1.1384|
                  |L1.1382|
;;;1513   		}
;;;1514   		else
;;;1515   		{
;;;1516   			xReturn = pdFAIL;
000566  2400              MOVS     r4,#0
                  |L1.1384|
;;;1517   			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
;;;1518   		}
;;;1519   	}
;;;1520   	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
000568  4630              MOV      r0,r6
00056a  f7fffffe          BL       vPortClearInterruptMask
;;;1521   
;;;1522   	return xReturn;
00056e  4620              MOV      r0,r4
;;;1523   }
000570  e648              B        |L1.516|
;;;1524   /*-----------------------------------------------------------*/
                          ENDP

                  uxQueueMessagesWaiting PROC
;;;1525   
;;;1526   UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
000572  b510              PUSH     {r4,lr}
;;;1527   {
000574  0004              MOVS     r4,r0
000576  d006              BEQ      |L1.1414|
;;;1528   UBaseType_t uxReturn;
;;;1529   
;;;1530   	configASSERT( xQueue );
;;;1531   
;;;1532   	taskENTER_CRITICAL();
000578  f7fffffe          BL       vPortEnterCritical
;;;1533   	{
;;;1534   		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
00057c  6ba4              LDR      r4,[r4,#0x38]
;;;1535   	}
;;;1536   	taskEXIT_CRITICAL();
00057e  f7fffffe          BL       vPortExitCritical
;;;1537   
;;;1538   	return uxReturn;
000582  4620              MOV      r0,r4
;;;1539   } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
000584  bd10              POP      {r4,pc}
                  |L1.1414|
000586  f7fffffe          BL       ulPortSetInterruptMask
                  |L1.1418|
00058a  e7fe              B        |L1.1418|
;;;1540   /*-----------------------------------------------------------*/
                          ENDP

                  uxQueueSpacesAvailable PROC
;;;1541   
;;;1542   UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
00058c  b510              PUSH     {r4,lr}
;;;1543   {
;;;1544   UBaseType_t uxReturn;
;;;1545   Queue_t *pxQueue;
;;;1546   
;;;1547   	pxQueue = ( Queue_t * ) xQueue;
00058e  0004              MOVS     r4,r0
000590  d008              BEQ      |L1.1444|
;;;1548   	configASSERT( pxQueue );
;;;1549   
;;;1550   	taskENTER_CRITICAL();
000592  f7fffffe          BL       vPortEnterCritical
;;;1551   	{
;;;1552   		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
000596  e9d4100e          LDRD     r1,r0,[r4,#0x38]
00059a  1a44              SUBS     r4,r0,r1
;;;1553   	}
;;;1554   	taskEXIT_CRITICAL();
00059c  f7fffffe          BL       vPortExitCritical
;;;1555   
;;;1556   	return uxReturn;
0005a0  4620              MOV      r0,r4
;;;1557   } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
0005a2  bd10              POP      {r4,pc}
                  |L1.1444|
0005a4  f7fffffe          BL       ulPortSetInterruptMask
                  |L1.1448|
0005a8  e7fe              B        |L1.1448|
;;;1558   /*-----------------------------------------------------------*/
                          ENDP

                  uxQueueMessagesWaitingFromISR PROC
;;;1559   
;;;1560   UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
0005aa  b510              PUSH     {r4,lr}
;;;1561   {
0005ac  b108              CBZ      r0,|L1.1458|
;;;1562   UBaseType_t uxReturn;
;;;1563   
;;;1564   	configASSERT( xQueue );
;;;1565   
;;;1566   	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
0005ae  6b80              LDR      r0,[r0,#0x38]
;;;1567   
;;;1568   	return uxReturn;
;;;1569   } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
0005b0  bd10              POP      {r4,pc}
                  |L1.1458|
0005b2  f7fffffe          BL       ulPortSetInterruptMask
                  |L1.1462|
0005b6  e7fe              B        |L1.1462|
;;;1570   /*-----------------------------------------------------------*/
                          ENDP

                  vQueueDelete PROC
;;;1571   
;;;1572   void vQueueDelete( QueueHandle_t xQueue )
0005b8  b510              PUSH     {r4,lr}
;;;1573   {
;;;1574   Queue_t * const pxQueue = ( Queue_t * ) xQueue;
0005ba  0004              MOVS     r4,r0
0005bc  d008              BEQ      |L1.1488|
;;;1575   
;;;1576   	configASSERT( pxQueue );
;;;1577   
;;;1578   	traceQUEUE_DELETE( pxQueue );
;;;1579   	#if ( configQUEUE_REGISTRY_SIZE > 0 )
;;;1580   	{
;;;1581   		vQueueUnregisterQueue( pxQueue );
;;;1582   	}
;;;1583   	#endif
;;;1584   	if( pxQueue->pcHead != NULL )
0005be  6820              LDR      r0,[r4,#0]
0005c0  b108              CBZ      r0,|L1.1478|
;;;1585   	{
;;;1586   		vPortFree( pxQueue->pcHead );
0005c2  f7fffffe          BL       vPortFree
                  |L1.1478|
;;;1587   	}
;;;1588   	vPortFree( pxQueue );
0005c6  4620              MOV      r0,r4
0005c8  e8bd4010          POP      {r4,lr}
0005cc  f7ffbffe          B.W      vPortFree
                  |L1.1488|
0005d0  f7fffffe          BL       ulPortSetInterruptMask
                  |L1.1492|
0005d4  e7fe              B        |L1.1492|
;;;1589   }
;;;1590   /*-----------------------------------------------------------*/
                          ENDP

                  xQueueIsQueueEmptyFromISR PROC
;;;1849   
;;;1850   BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
0005d6  b510              PUSH     {r4,lr}
;;;1851   {
0005d8  b118              CBZ      r0,|L1.1506|
;;;1852   BaseType_t xReturn;
;;;1853   
;;;1854   	configASSERT( xQueue );
;;;1855   	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
0005da  6b80              LDR      r0,[r0,#0x38]
0005dc  b120              CBZ      r0,|L1.1512|
;;;1856   	{
;;;1857   		xReturn = pdTRUE;
;;;1858   	}
;;;1859   	else
;;;1860   	{
;;;1861   		xReturn = pdFALSE;
0005de  2000              MOVS     r0,#0
;;;1862   	}
;;;1863   
;;;1864   	return xReturn;
;;;1865   } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
0005e0  bd10              POP      {r4,pc}
                  |L1.1506|
0005e2  f7fffffe          BL       ulPortSetInterruptMask
                  |L1.1510|
0005e6  e7fe              B        |L1.1510|
                  |L1.1512|
0005e8  2001              MOVS     r0,#1                 ;1857
0005ea  bd10              POP      {r4,pc}
;;;1866   /*-----------------------------------------------------------*/
                          ENDP

                  xQueueIsQueueFullFromISR PROC
;;;1888   
;;;1889   BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
0005ec  b510              PUSH     {r4,lr}
;;;1890   {
0005ee  b128              CBZ      r0,|L1.1532|
;;;1891   BaseType_t xReturn;
;;;1892   
;;;1893   	configASSERT( xQueue );
;;;1894   	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
0005f0  6b81              LDR      r1,[r0,#0x38]
0005f2  6bc0              LDR      r0,[r0,#0x3c]
0005f4  4281              CMP      r1,r0
0005f6  d104              BNE      |L1.1538|
;;;1895   	{
;;;1896   		xReturn = pdTRUE;
0005f8  2001              MOVS     r0,#1
;;;1897   	}
;;;1898   	else
;;;1899   	{
;;;1900   		xReturn = pdFALSE;
;;;1901   	}
;;;1902   
;;;1903   	return xReturn;
;;;1904   } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
0005fa  bd10              POP      {r4,pc}
                  |L1.1532|
0005fc  f7fffffe          BL       ulPortSetInterruptMask
                  |L1.1536|
000600  e7fe              B        |L1.1536|
                  |L1.1538|
000602  2000              MOVS     r0,#0                 ;1900
000604  bd10              POP      {r4,pc}
;;;1905   /*-----------------------------------------------------------*/
                          ENDP

                  vQueueWaitForMessageRestricted PROC
;;;2239   
;;;2240   	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait )
000606  b570              PUSH     {r4-r6,lr}
;;;2241   	{
000608  460d              MOV      r5,r1
;;;2242   	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
00060a  4604              MOV      r4,r0
;;;2243   
;;;2244   		/* This function should not be called by application code hence the
;;;2245   		'Restricted' in its name.  It is not part of the public API.  It is
;;;2246   		designed for use by kernel code, and has special calling requirements.
;;;2247   		It can result in vListInsert() being called on a list that can only
;;;2248   		possibly ever have one item in it, so the list will be fast, but even
;;;2249   		so it should be called with the scheduler locked and not from a critical
;;;2250   		section. */
;;;2251   
;;;2252   		/* Only do anything if there are no messages in the queue.  This function
;;;2253   		will not actually cause the task to block, just place it on a blocked
;;;2254   		list.  It will not block until the scheduler is unlocked - at which
;;;2255   		time a yield will be performed.  If an item is added to the queue while
;;;2256   		the queue is locked, and the calling task blocks on the queue, then the
;;;2257   		calling task will be immediately unblocked when the queue is unlocked. */
;;;2258   		prvLockQueue( pxQueue );
00060c  f7fffffe          BL       vPortEnterCritical
000610  6c61              LDR      r1,[r4,#0x44]
000612  2000              MOVS     r0,#0
000614  1c49              ADDS     r1,r1,#1
000616  d100              BNE      |L1.1562|
000618  6460              STR      r0,[r4,#0x44]
                  |L1.1562|
00061a  6ca1              LDR      r1,[r4,#0x48]
00061c  1c49              ADDS     r1,r1,#1
00061e  d100              BNE      |L1.1570|
000620  64a0              STR      r0,[r4,#0x48]
                  |L1.1570|
000622  f7fffffe          BL       vPortExitCritical
;;;2259   		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
000626  6ba0              LDR      r0,[r4,#0x38]
000628  b920              CBNZ     r0,|L1.1588|
;;;2260   		{
;;;2261   			/* There is nothing in the queue, block for the specified period. */
;;;2262   			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
00062a  4629              MOV      r1,r5
00062c  f1040024          ADD      r0,r4,#0x24
000630  f7fffffe          BL       vTaskPlaceOnEventListRestricted
                  |L1.1588|
;;;2263   		}
;;;2264   		else
;;;2265   		{
;;;2266   			mtCOVERAGE_TEST_MARKER();
;;;2267   		}
;;;2268   		prvUnlockQueue( pxQueue );
000634  4620              MOV      r0,r4
000636  e8bd4070          POP      {r4-r6,lr}
00063a  e7fe              B        prvUnlockQueue
;;;2269   	}
;;;2270   
                          ENDP

