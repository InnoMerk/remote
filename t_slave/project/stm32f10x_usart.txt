; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o.\stm32f10x_usart.o --asm_dir=.\ --list_dir=.\ --depend=.\stm32f10x_usart.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\project -I..\CMSIS\CM3\CoreSupport -I..\hooks -I..\lcd -I..\led -I..\load_cpu -I..\main -I..\printf -I..\rtos -I..\STM32F10x_StdPeriph_Driver\inc -I..\STM32F10x_StdPeriph_Driver\src -I..\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\limit_switch -I..\control_task -I..\mode_task -I..\lcdTask -I..\hit -I..\move_task -I"C:\Program Files\keil\ARM\RV31\INC" -I"C:\Program Files\keil\ARM\PACK\ARM\CMSIS\3.20.4\CMSIS\Include" -I"C:\Program Files\keil\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include" -DSTM32F10X_MD_VL -DUSE_STDPERIPH_DRIVER --omf_browse=.\stm32f10x_usart.crf ..\STM32F10x_StdPeriph_Driver\src\stm32f10x_usart.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  USART_DeInit PROC
;;;129      */
;;;130    void USART_DeInit(USART_TypeDef* USARTx)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;131    {
000004  4604              MOV      r4,r0
;;;132      /* Check the parameters */
;;;133      assert_param(IS_USART_ALL_PERIPH(USARTx));
000006  48fe              LDR      r0,|L1.1024|
000008  4284              CMP      r4,r0
00000a  d015              BEQ      |L1.56|
00000c  4ffd              LDR      r7,|L1.1028|
00000e  4dfe              LDR      r5,|L1.1032|
000010  4efe              LDR      r6,|L1.1036|
000012  f8df83fc          LDR      r8,|L1.1040|
000016  42bc              CMP      r4,r7
000018  d009              BEQ      |L1.46|
00001a  42ac              CMP      r4,r5
00001c  d007              BEQ      |L1.46|
00001e  42b4              CMP      r4,r6
000020  d005              BEQ      |L1.46|
000022  4544              CMP      r4,r8
000024  d01f              BEQ      |L1.102|
000026  2185              MOVS     r1,#0x85
000028  a0fa              ADR      r0,|L1.1044|
00002a  f7fffffe          BL       assert_failed
                  |L1.46|
;;;134    
;;;135      if (USARTx == USART1)
;;;136      {
;;;137        RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, ENABLE);
;;;138        RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, DISABLE);
;;;139      }
;;;140      else if (USARTx == USART2)
00002e  42bc              CMP      r4,r7
000030  d10d              BNE      |L1.78|
;;;141      {
;;;142        RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, ENABLE);
000032  2101              MOVS     r1,#1
000034  044c              LSLS     r4,r1,#17
;;;143        RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, DISABLE);
000036  e018              B        |L1.106|
                  |L1.56|
000038  2101              MOVS     r1,#1                 ;137
00003a  038c              LSLS     r4,r1,#14             ;137
00003c  4620              MOV      r0,r4                 ;137
00003e  f7fffffe          BL       RCC_APB2PeriphResetCmd
000042  4620              MOV      r0,r4                 ;138
000044  e8bd41f0          POP      {r4-r8,lr}            ;138
000048  2100              MOVS     r1,#0                 ;138
00004a  f7ffbffe          B.W      RCC_APB2PeriphResetCmd
                  |L1.78|
;;;144      }
;;;145      else if (USARTx == USART3)
00004e  42ac              CMP      r4,r5
000050  d102              BNE      |L1.88|
;;;146      {
;;;147        RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, ENABLE);
000052  2101              MOVS     r1,#1
000054  048c              LSLS     r4,r1,#18
;;;148        RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, DISABLE);
000056  e008              B        |L1.106|
                  |L1.88|
;;;149      }    
;;;150      else if (USARTx == UART4)
000058  42b4              CMP      r4,r6
00005a  d102              BNE      |L1.98|
;;;151      {
;;;152        RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, ENABLE);
00005c  2101              MOVS     r1,#1
00005e  04cc              LSLS     r4,r1,#19
;;;153        RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, DISABLE);
000060  e003              B        |L1.106|
                  |L1.98|
;;;154      }    
;;;155      else
;;;156      {
;;;157        if (USARTx == UART5)
000062  4544              CMP      r4,r8
000064  d10a              BNE      |L1.124|
                  |L1.102|
;;;158        { 
;;;159          RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, ENABLE);
000066  2101              MOVS     r1,#1
000068  050c              LSLS     r4,r1,#20
                  |L1.106|
00006a  4620              MOV      r0,r4
00006c  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;160          RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, DISABLE);
000070  4620              MOV      r0,r4
000072  e8bd41f0          POP      {r4-r8,lr}
000076  2100              MOVS     r1,#0
000078  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L1.124|
;;;161        }
;;;162      }
;;;163    }
00007c  e8bd81f0          POP      {r4-r8,pc}
;;;164    
                          ENDP

                  USART_Init PROC
;;;175      */
;;;176    void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
000080  e92d43f0          PUSH     {r4-r9,lr}
;;;177    {
;;;178      uint32_t tmpreg = 0x00, apbclock = 0x00;
;;;179      uint32_t integerdivider = 0x00;
;;;180      uint32_t fractionaldivider = 0x00;
;;;181      uint32_t usartxbase = 0;
;;;182      RCC_ClocksTypeDef RCC_ClocksStatus;
;;;183      /* Check the parameters */
;;;184      assert_param(IS_USART_ALL_PERIPH(USARTx));
000084  4ede              LDR      r6,|L1.1024|
000086  4fdf              LDR      r7,|L1.1028|
000088  f8df837c          LDR      r8,|L1.1032|
00008c  b085              SUB      sp,sp,#0x14           ;177
00008e  460d              MOV      r5,r1                 ;177
000090  4604              MOV      r4,r0                 ;177
000092  42b0              CMP      r0,r6
000094  d00d              BEQ      |L1.178|
000096  42bc              CMP      r4,r7
000098  d00b              BEQ      |L1.178|
00009a  4544              CMP      r4,r8
00009c  d009              BEQ      |L1.178|
00009e  48db              LDR      r0,|L1.1036|
0000a0  4284              CMP      r4,r0
0000a2  d006              BEQ      |L1.178|
0000a4  48da              LDR      r0,|L1.1040|
0000a6  4284              CMP      r4,r0
0000a8  d003              BEQ      |L1.178|
0000aa  21b8              MOVS     r1,#0xb8
0000ac  a0d9              ADR      r0,|L1.1044|
0000ae  f7fffffe          BL       assert_failed
                  |L1.178|
;;;185      assert_param(IS_USART_BAUDRATE(USART_InitStruct->USART_BaudRate));  
0000b2  6828              LDR      r0,[r5,#0]
0000b4  49e4              LDR      r1,|L1.1096|
0000b6  1e40              SUBS     r0,r0,#1
0000b8  4288              CMP      r0,r1
0000ba  d303              BCC      |L1.196|
0000bc  21b9              MOVS     r1,#0xb9
0000be  a0d5              ADR      r0,|L1.1044|
0000c0  f7fffffe          BL       assert_failed
                  |L1.196|
;;;186      assert_param(IS_USART_WORD_LENGTH(USART_InitStruct->USART_WordLength));
0000c4  88a8              LDRH     r0,[r5,#4]
0000c6  f44f5980          MOV      r9,#0x1000
0000ca  b128              CBZ      r0,|L1.216|
0000cc  4548              CMP      r0,r9
0000ce  d003              BEQ      |L1.216|
0000d0  21ba              MOVS     r1,#0xba
0000d2  a0d0              ADR      r0,|L1.1044|
0000d4  f7fffffe          BL       assert_failed
                  |L1.216|
;;;187      assert_param(IS_USART_STOPBITS(USART_InitStruct->USART_StopBits));
0000d8  88e8              LDRH     r0,[r5,#6]
0000da  b158              CBZ      r0,|L1.244|
0000dc  4548              CMP      r0,r9
0000de  d009              BEQ      |L1.244|
0000e0  f5b05f00          CMP      r0,#0x2000
0000e4  d006              BEQ      |L1.244|
0000e6  f5b05f40          CMP      r0,#0x3000
0000ea  d003              BEQ      |L1.244|
0000ec  21bb              MOVS     r1,#0xbb
0000ee  a0c9              ADR      r0,|L1.1044|
0000f0  f7fffffe          BL       assert_failed
                  |L1.244|
;;;188      assert_param(IS_USART_PARITY(USART_InitStruct->USART_Parity));
0000f4  8928              LDRH     r0,[r5,#8]
0000f6  b148              CBZ      r0,|L1.268|
0000f8  f5b06f80          CMP      r0,#0x400
0000fc  d006              BEQ      |L1.268|
0000fe  f5b06fc0          CMP      r0,#0x600
000102  d003              BEQ      |L1.268|
000104  21bc              MOVS     r1,#0xbc
000106  a0c3              ADR      r0,|L1.1044|
000108  f7fffffe          BL       assert_failed
                  |L1.268|
;;;189      assert_param(IS_USART_MODE(USART_InitStruct->USART_Mode));
00010c  8968              LDRH     r0,[r5,#0xa]
00010e  f030010c          BICS     r1,r0,#0xc
000112  d100              BNE      |L1.278|
000114  b918              CBNZ     r0,|L1.286|
                  |L1.278|
000116  21bd              MOVS     r1,#0xbd
000118  a0be              ADR      r0,|L1.1044|
00011a  f7fffffe          BL       assert_failed
                  |L1.286|
;;;190      assert_param(IS_USART_HARDWARE_FLOW_CONTROL(USART_InitStruct->USART_HardwareFlowControl));
00011e  89a8              LDRH     r0,[r5,#0xc]
000120  b1c0              CBZ      r0,|L1.340|
000122  f5b07f80          CMP      r0,#0x100
000126  d00b              BEQ      |L1.320|
000128  f5b07f00          CMP      r0,#0x200
00012c  d008              BEQ      |L1.320|
00012e  f5b07f40          CMP      r0,#0x300
000132  d005              BEQ      |L1.320|
000134  21be              MOVS     r1,#0xbe
000136  a0b7              ADR      r0,|L1.1044|
000138  f7fffffe          BL       assert_failed
;;;191      /* The hardware flow control is available only for USART1, USART2 and USART3 */
;;;192      if (USART_InitStruct->USART_HardwareFlowControl != USART_HardwareFlowControl_None)
00013c  89a8              LDRH     r0,[r5,#0xc]
00013e  b148              CBZ      r0,|L1.340|
                  |L1.320|
;;;193      {
;;;194        assert_param(IS_USART_123_PERIPH(USARTx));
000140  42b4              CMP      r4,r6
000142  d007              BEQ      |L1.340|
000144  42bc              CMP      r4,r7
000146  d005              BEQ      |L1.340|
000148  4544              CMP      r4,r8
00014a  d003              BEQ      |L1.340|
00014c  21c2              MOVS     r1,#0xc2
00014e  a0b1              ADR      r0,|L1.1044|
000150  f7fffffe          BL       assert_failed
                  |L1.340|
;;;195      }
;;;196    
;;;197      usartxbase = (uint32_t)USARTx;
;;;198    
;;;199    /*---------------------------- USART CR2 Configuration -----------------------*/
;;;200      tmpreg = USARTx->CR2;
000154  8a20              LDRH     r0,[r4,#0x10]
;;;201      /* Clear STOP[13:12] bits */
;;;202      tmpreg &= CR2_STOP_CLEAR_Mask;
000156  f64c71ff          MOV      r1,#0xcfff
00015a  4008              ANDS     r0,r0,r1
;;;203      /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit ------------*/
;;;204      /* Set STOP[13:12] bits according to USART_StopBits value */
;;;205      tmpreg |= (uint32_t)USART_InitStruct->USART_StopBits;
00015c  88e9              LDRH     r1,[r5,#6]
00015e  4301              ORRS     r1,r1,r0
;;;206      
;;;207      /* Write to USART CR2 */
;;;208      USARTx->CR2 = (uint16_t)tmpreg;
000160  8221              STRH     r1,[r4,#0x10]
;;;209    
;;;210    /*---------------------------- USART CR1 Configuration -----------------------*/
;;;211      tmpreg = USARTx->CR1;
000162  89a1              LDRH     r1,[r4,#0xc]
;;;212      /* Clear M, PCE, PS, TE and RE bits */
;;;213      tmpreg &= CR1_CLEAR_Mask;
000164  f64e10f3          MOV      r0,#0xe9f3
000168  4001              ANDS     r1,r1,r0
;;;214      /* Configure the USART Word Length, Parity and mode ----------------------- */
;;;215      /* Set the M bits according to USART_WordLength value */
;;;216      /* Set PCE and PS bits according to USART_Parity value */
;;;217      /* Set TE and RE bits according to USART_Mode value */
;;;218      tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
00016a  88a8              LDRH     r0,[r5,#4]
00016c  892a              LDRH     r2,[r5,#8]
00016e  4310              ORRS     r0,r0,r2
000170  896a              LDRH     r2,[r5,#0xa]
000172  430a              ORRS     r2,r2,r1
000174  4310              ORRS     r0,r0,r2
;;;219                USART_InitStruct->USART_Mode;
;;;220      /* Write to USART CR1 */
;;;221      USARTx->CR1 = (uint16_t)tmpreg;
000176  81a0              STRH     r0,[r4,#0xc]
;;;222    
;;;223    /*---------------------------- USART CR3 Configuration -----------------------*/  
;;;224      tmpreg = USARTx->CR3;
000178  8aa0              LDRH     r0,[r4,#0x14]
;;;225      /* Clear CTSE and RTSE bits */
;;;226      tmpreg &= CR3_CLEAR_Mask;
00017a  f64f41ff          MOV      r1,#0xfcff
00017e  4008              ANDS     r0,r0,r1
;;;227      /* Configure the USART HFC -------------------------------------------------*/
;;;228      /* Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
;;;229      tmpreg |= USART_InitStruct->USART_HardwareFlowControl;
000180  89a9              LDRH     r1,[r5,#0xc]
000182  4301              ORRS     r1,r1,r0
;;;230      /* Write to USART CR3 */
;;;231      USARTx->CR3 = (uint16_t)tmpreg;
000184  82a1              STRH     r1,[r4,#0x14]
;;;232    
;;;233    /*---------------------------- USART BRR Configuration -----------------------*/
;;;234      /* Configure the USART Baud Rate -------------------------------------------*/
;;;235      RCC_GetClocksFreq(&RCC_ClocksStatus);
000186  4668              MOV      r0,sp
000188  f7fffffe          BL       RCC_GetClocksFreq
;;;236      if (usartxbase == USART1_BASE)
00018c  42b4              CMP      r4,r6
00018e  d101              BNE      |L1.404|
;;;237      {
;;;238        apbclock = RCC_ClocksStatus.PCLK2_Frequency;
000190  9803              LDR      r0,[sp,#0xc]
000192  e000              B        |L1.406|
                  |L1.404|
;;;239      }
;;;240      else
;;;241      {
;;;242        apbclock = RCC_ClocksStatus.PCLK1_Frequency;
000194  9802              LDR      r0,[sp,#8]
                  |L1.406|
;;;243      }
;;;244      
;;;245      /* Determine the integer part */
;;;246      if ((USARTx->CR1 & CR1_OVER8_Set) != 0)
000196  89a1              LDRH     r1,[r4,#0xc]
000198  0409              LSLS     r1,r1,#16
;;;247      {
;;;248        /* Integer part computing in case Oversampling mode is 8 Samples */
;;;249        integerdivider = ((25 * apbclock) / (2 * (USART_InitStruct->USART_BaudRate)));    
;;;250      }
;;;251      else /* if ((USARTx->CR1 & CR1_OVER8_Set) == 0) */
;;;252      {
;;;253        /* Integer part computing in case Oversampling mode is 16 Samples */
;;;254        integerdivider = ((25 * apbclock) / (4 * (USART_InitStruct->USART_BaudRate)));    
00019a  eb0001c0          ADD      r1,r0,r0,LSL #3
00019e  eb011000          ADD      r0,r1,r0,LSL #4
0001a2  6829              LDR      r1,[r5,#0]            ;246
0001a4  d501              BPL      |L1.426|
0001a6  0049              LSLS     r1,r1,#1              ;249
0001a8  e000              B        |L1.428|
                  |L1.426|
0001aa  0089              LSLS     r1,r1,#2
                  |L1.428|
0001ac  fbb0f0f1          UDIV     r0,r0,r1
;;;255      }
;;;256      tmpreg = (integerdivider / 100) << 4;
0001b0  2264              MOVS     r2,#0x64
0001b2  fbb0f1f2          UDIV     r1,r0,r2
0001b6  0109              LSLS     r1,r1,#4
;;;257    
;;;258      /* Determine the fractional part */
;;;259      fractionaldivider = integerdivider - (100 * (tmpreg >> 4));
0001b8  090b              LSRS     r3,r1,#4
0001ba  f06f0518          MVN      r5,#0x18
0001be  436b              MULS     r3,r5,r3
0001c0  eb000083          ADD      r0,r0,r3,LSL #2
;;;260    
;;;261      /* Implement the fractional part in the register */
;;;262      if ((USARTx->CR1 & CR1_OVER8_Set) != 0)
0001c4  89a3              LDRH     r3,[r4,#0xc]
0001c6  041d              LSLS     r5,r3,#16
;;;263      {
;;;264        tmpreg |= ((((fractionaldivider * 8) + 50) / 100)) & ((uint8_t)0x07);
0001c8  f04f0332          MOV      r3,#0x32
0001cc  d506              BPL      |L1.476|
0001ce  eb0300c0          ADD      r0,r3,r0,LSL #3
0001d2  fbb0f0f2          UDIV     r0,r0,r2
0001d6  f0000007          AND      r0,r0,#7
0001da  e005              B        |L1.488|
                  |L1.476|
;;;265      }
;;;266      else /* if ((USARTx->CR1 & CR1_OVER8_Set) == 0) */
;;;267      {
;;;268        tmpreg |= ((((fractionaldivider * 16) + 50) / 100)) & ((uint8_t)0x0F);
0001dc  eb031000          ADD      r0,r3,r0,LSL #4
0001e0  fbb0f0f2          UDIV     r0,r0,r2
0001e4  f000000f          AND      r0,r0,#0xf
                  |L1.488|
0001e8  4308              ORRS     r0,r0,r1
;;;269      }
;;;270      
;;;271      /* Write to USART BRR */
;;;272      USARTx->BRR = (uint16_t)tmpreg;
0001ea  8120              STRH     r0,[r4,#8]
;;;273    }
0001ec  b005              ADD      sp,sp,#0x14
0001ee  e8bd83f0          POP      {r4-r9,pc}
;;;274    
                          ENDP

                  USART_StructInit PROC
;;;280      */
;;;281    void USART_StructInit(USART_InitTypeDef* USART_InitStruct)
0001f2  f44f5116          MOV      r1,#0x2580
;;;282    {
;;;283      /* USART_InitStruct members default value */
;;;284      USART_InitStruct->USART_BaudRate = 9600;
;;;285      USART_InitStruct->USART_WordLength = USART_WordLength_8b;
0001f6  6001              STR      r1,[r0,#0]
0001f8  2100              MOVS     r1,#0
0001fa  8081              STRH     r1,[r0,#4]
;;;286      USART_InitStruct->USART_StopBits = USART_StopBits_1;
0001fc  80c1              STRH     r1,[r0,#6]
;;;287      USART_InitStruct->USART_Parity = USART_Parity_No ;
0001fe  8101              STRH     r1,[r0,#8]
;;;288      USART_InitStruct->USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
000200  220c              MOVS     r2,#0xc
000202  8142              STRH     r2,[r0,#0xa]
;;;289      USART_InitStruct->USART_HardwareFlowControl = USART_HardwareFlowControl_None;  
000204  8181              STRH     r1,[r0,#0xc]
;;;290    }
000206  4770              BX       lr
;;;291    
                          ENDP

                  USART_ClockInit PROC
;;;301      */
;;;302    void USART_ClockInit(USART_TypeDef* USARTx, USART_ClockInitTypeDef* USART_ClockInitStruct)
000208  b570              PUSH     {r4-r6,lr}
;;;303    {
00020a  4605              MOV      r5,r0
;;;304      uint32_t tmpreg = 0x00;
;;;305      /* Check the parameters */
;;;306      assert_param(IS_USART_123_PERIPH(USARTx));
00020c  487c              LDR      r0,|L1.1024|
00020e  460c              MOV      r4,r1                 ;303
000210  4285              CMP      r5,r0
000212  d00a              BEQ      |L1.554|
000214  487b              LDR      r0,|L1.1028|
000216  4285              CMP      r5,r0
000218  d007              BEQ      |L1.554|
00021a  487b              LDR      r0,|L1.1032|
00021c  4285              CMP      r5,r0
00021e  d004              BEQ      |L1.554|
000220  f44f7199          MOV      r1,#0x132
000224  a07b              ADR      r0,|L1.1044|
000226  f7fffffe          BL       assert_failed
                  |L1.554|
;;;307      assert_param(IS_USART_CLOCK(USART_ClockInitStruct->USART_Clock));
00022a  8820              LDRH     r0,[r4,#0]
00022c  b138              CBZ      r0,|L1.574|
00022e  f5b06f00          CMP      r0,#0x800
000232  d004              BEQ      |L1.574|
000234  f2401133          MOV      r1,#0x133
000238  a076              ADR      r0,|L1.1044|
00023a  f7fffffe          BL       assert_failed
                  |L1.574|
;;;308      assert_param(IS_USART_CPOL(USART_ClockInitStruct->USART_CPOL));
00023e  8860              LDRH     r0,[r4,#2]
000240  b138              CBZ      r0,|L1.594|
000242  f5b06f80          CMP      r0,#0x400
000246  d004              BEQ      |L1.594|
000248  f44f719a          MOV      r1,#0x134
00024c  a071              ADR      r0,|L1.1044|
00024e  f7fffffe          BL       assert_failed
                  |L1.594|
;;;309      assert_param(IS_USART_CPHA(USART_ClockInitStruct->USART_CPHA));
000252  88a0              LDRH     r0,[r4,#4]
000254  b138              CBZ      r0,|L1.614|
000256  f5b07f00          CMP      r0,#0x200
00025a  d004              BEQ      |L1.614|
00025c  f2401135          MOV      r1,#0x135
000260  a06c              ADR      r0,|L1.1044|
000262  f7fffffe          BL       assert_failed
                  |L1.614|
;;;310      assert_param(IS_USART_LASTBIT(USART_ClockInitStruct->USART_LastBit));
000266  88e0              LDRH     r0,[r4,#6]
000268  b138              CBZ      r0,|L1.634|
00026a  f5b07f80          CMP      r0,#0x100
00026e  d004              BEQ      |L1.634|
000270  f44f719b          MOV      r1,#0x136
000274  a067              ADR      r0,|L1.1044|
000276  f7fffffe          BL       assert_failed
                  |L1.634|
;;;311      
;;;312    /*---------------------------- USART CR2 Configuration -----------------------*/
;;;313      tmpreg = USARTx->CR2;
00027a  8a29              LDRH     r1,[r5,#0x10]
;;;314      /* Clear CLKEN, CPOL, CPHA and LBCL bits */
;;;315      tmpreg &= CR2_CLOCK_CLEAR_Mask;
00027c  f24f00ff          MOV      r0,#0xf0ff
000280  4001              ANDS     r1,r1,r0
;;;316      /* Configure the USART Clock, CPOL, CPHA and LastBit ------------*/
;;;317      /* Set CLKEN bit according to USART_Clock value */
;;;318      /* Set CPOL bit according to USART_CPOL value */
;;;319      /* Set CPHA bit according to USART_CPHA value */
;;;320      /* Set LBCL bit according to USART_LastBit value */
;;;321      tmpreg |= (uint32_t)USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
000282  8820              LDRH     r0,[r4,#0]
000284  8862              LDRH     r2,[r4,#2]
000286  88e3              LDRH     r3,[r4,#6]
000288  4310              ORRS     r0,r0,r2
00028a  88a2              LDRH     r2,[r4,#4]
00028c  431a              ORRS     r2,r2,r3
00028e  4310              ORRS     r0,r0,r2
000290  4308              ORRS     r0,r0,r1
;;;322                     USART_ClockInitStruct->USART_CPHA | USART_ClockInitStruct->USART_LastBit;
;;;323      /* Write to USART CR2 */
;;;324      USARTx->CR2 = (uint16_t)tmpreg;
000292  8228              STRH     r0,[r5,#0x10]
;;;325    }
000294  bd70              POP      {r4-r6,pc}
;;;326    
                          ENDP

                  USART_ClockStructInit PROC
;;;332      */
;;;333    void USART_ClockStructInit(USART_ClockInitTypeDef* USART_ClockInitStruct)
000296  2100              MOVS     r1,#0
;;;334    {
;;;335      /* USART_ClockInitStruct members default value */
;;;336      USART_ClockInitStruct->USART_Clock = USART_Clock_Disable;
000298  8001              STRH     r1,[r0,#0]
;;;337      USART_ClockInitStruct->USART_CPOL = USART_CPOL_Low;
00029a  8041              STRH     r1,[r0,#2]
;;;338      USART_ClockInitStruct->USART_CPHA = USART_CPHA_1Edge;
00029c  8081              STRH     r1,[r0,#4]
;;;339      USART_ClockInitStruct->USART_LastBit = USART_LastBit_Disable;
00029e  80c1              STRH     r1,[r0,#6]
;;;340    }
0002a0  4770              BX       lr
;;;341    
                          ENDP

                  USART_Cmd PROC
;;;350      */
;;;351    void USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
0002a2  b570              PUSH     {r4-r6,lr}
;;;352    {
0002a4  4604              MOV      r4,r0
;;;353      /* Check the parameters */
;;;354      assert_param(IS_USART_ALL_PERIPH(USARTx));
0002a6  4856              LDR      r0,|L1.1024|
0002a8  460d              MOV      r5,r1                 ;352
0002aa  4284              CMP      r4,r0
0002ac  d010              BEQ      |L1.720|
0002ae  4855              LDR      r0,|L1.1028|
0002b0  4284              CMP      r4,r0
0002b2  d00d              BEQ      |L1.720|
0002b4  4854              LDR      r0,|L1.1032|
0002b6  4284              CMP      r4,r0
0002b8  d00a              BEQ      |L1.720|
0002ba  4854              LDR      r0,|L1.1036|
0002bc  4284              CMP      r4,r0
0002be  d007              BEQ      |L1.720|
0002c0  4853              LDR      r0,|L1.1040|
0002c2  4284              CMP      r4,r0
0002c4  d004              BEQ      |L1.720|
0002c6  f44f71b1          MOV      r1,#0x162
0002ca  a052              ADR      r0,|L1.1044|
0002cc  f7fffffe          BL       assert_failed
                  |L1.720|
;;;355      assert_param(IS_FUNCTIONAL_STATE(NewState));
0002d0  b155              CBZ      r5,|L1.744|
0002d2  2d01              CMP      r5,#1
0002d4  d004              BEQ      |L1.736|
0002d6  f2401163          MOV      r1,#0x163
0002da  a04e              ADR      r0,|L1.1044|
0002dc  f7fffffe          BL       assert_failed
                  |L1.736|
;;;356      
;;;357      if (NewState != DISABLE)
;;;358      {
;;;359        /* Enable the selected USART by setting the UE bit in the CR1 register */
;;;360        USARTx->CR1 |= CR1_UE_Set;
0002e0  89a0              LDRH     r0,[r4,#0xc]
0002e2  f4405000          ORR      r0,r0,#0x2000
0002e6  e002              B        |L1.750|
                  |L1.744|
;;;361      }
;;;362      else
;;;363      {
;;;364        /* Disable the selected USART by clearing the UE bit in the CR1 register */
;;;365        USARTx->CR1 &= CR1_UE_Reset;
0002e8  89a0              LDRH     r0,[r4,#0xc]
0002ea  f4205000          BIC      r0,r0,#0x2000
                  |L1.750|
0002ee  81a0              STRH     r0,[r4,#0xc]          ;360
;;;366      }
;;;367    }
0002f0  bd70              POP      {r4-r6,pc}
;;;368    
                          ENDP

                  USART_ITConfig PROC
;;;387      */
;;;388    void USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState)
0002f2  e92d47f0          PUSH     {r4-r10,lr}
;;;389    {
;;;390      uint32_t usartreg = 0x00, itpos = 0x00, itmask = 0x00;
;;;391      uint32_t usartxbase = 0x00;
;;;392      /* Check the parameters */
;;;393      assert_param(IS_USART_ALL_PERIPH(USARTx));
0002f6  f8df8108          LDR      r8,|L1.1024|
0002fa  f8df9108          LDR      r9,|L1.1028|
0002fe  f8dfa108          LDR      r10,|L1.1032|
000302  4616              MOV      r6,r2                 ;389
000304  460d              MOV      r5,r1                 ;389
000306  4604              MOV      r4,r0                 ;389
000308  4540              CMP      r0,r8
00030a  d00e              BEQ      |L1.810|
00030c  454c              CMP      r4,r9
00030e  d00c              BEQ      |L1.810|
000310  4554              CMP      r4,r10
000312  d00a              BEQ      |L1.810|
000314  483d              LDR      r0,|L1.1036|
000316  4284              CMP      r4,r0
000318  d007              BEQ      |L1.810|
00031a  483d              LDR      r0,|L1.1040|
00031c  4284              CMP      r4,r0
00031e  d004              BEQ      |L1.810|
000320  f2401189          MOV      r1,#0x189
000324  a03b              ADR      r0,|L1.1044|
000326  f7fffffe          BL       assert_failed
                  |L1.810|
;;;394      assert_param(IS_USART_CONFIG_IT(USART_IT));
00032a  f640176a          MOV      r7,#0x96a
00032e  2d28              CMP      r5,#0x28
000330  d01c              BEQ      |L1.876|
000332  f5a560e0          SUB      r0,r5,#0x700
000336  3827              SUBS     r0,r0,#0x27
000338  d018              BEQ      |L1.876|
00033a  f5a560c0          SUB      r0,r5,#0x600
00033e  3826              SUBS     r0,r0,#0x26
000340  d014              BEQ      |L1.876|
000342  f5a560a0          SUB      r0,r5,#0x500
000346  3825              SUBS     r0,r0,#0x25
000348  d010              BEQ      |L1.876|
00034a  f5a56080          SUB      r0,r5,#0x400
00034e  3824              SUBS     r0,r0,#0x24
000350  d00c              BEQ      |L1.876|
000352  f5a56000          SUB      r0,r5,#0x800
000356  3846              SUBS     r0,r0,#0x46
000358  d008              BEQ      |L1.876|
00035a  42bd              CMP      r5,r7
00035c  d006              BEQ      |L1.876|
00035e  2d60              CMP      r5,#0x60
000360  d004              BEQ      |L1.876|
000362  f44f71c5          MOV      r1,#0x18a
000366  a02b              ADR      r0,|L1.1044|
000368  f7fffffe          BL       assert_failed
                  |L1.876|
;;;395      assert_param(IS_FUNCTIONAL_STATE(NewState));
00036c  b136              CBZ      r6,|L1.892|
00036e  2e01              CMP      r6,#1
000370  d004              BEQ      |L1.892|
000372  f240118b          MOV      r1,#0x18b
000376  a027              ADR      r0,|L1.1044|
000378  f7fffffe          BL       assert_failed
                  |L1.892|
;;;396      /* The CTS interrupt is not available for UART4 and UART5 */
;;;397      if (USART_IT == USART_IT_CTS)
00037c  42bd              CMP      r5,r7
00037e  d10a              BNE      |L1.918|
;;;398      {
;;;399        assert_param(IS_USART_123_PERIPH(USARTx));
000380  4544              CMP      r4,r8
000382  d008              BEQ      |L1.918|
000384  454c              CMP      r4,r9
000386  d006              BEQ      |L1.918|
000388  4554              CMP      r4,r10
00038a  d004              BEQ      |L1.918|
00038c  f240118f          MOV      r1,#0x18f
000390  a020              ADR      r0,|L1.1044|
000392  f7fffffe          BL       assert_failed
                  |L1.918|
;;;400      }   
;;;401      
;;;402      usartxbase = (uint32_t)USARTx;
;;;403    
;;;404      /* Get the USART register index */
;;;405      usartreg = (((uint8_t)USART_IT) >> 0x05);
;;;406    
;;;407      /* Get the interrupt position */
;;;408      itpos = USART_IT & IT_Mask;
000396  f005021f          AND      r2,r5,#0x1f
;;;409      itmask = (((uint32_t)0x01) << itpos);
00039a  2001              MOVS     r0,#1
00039c  f3c51142          UBFX     r1,r5,#5,#3           ;405
0003a0  4090              LSLS     r0,r0,r2
;;;410        
;;;411      if (usartreg == 0x01) /* The IT is in CR1 register */
0003a2  2901              CMP      r1,#1
0003a4  d006              BEQ      |L1.948|
;;;412      {
;;;413        usartxbase += 0x0C;
;;;414      }
;;;415      else if (usartreg == 0x02) /* The IT is in CR2 register */
0003a6  2902              CMP      r1,#2
0003a8  d006              BEQ      |L1.952|
0003aa  3414              ADDS     r4,r4,#0x14
                  |L1.940|
;;;416      {
;;;417        usartxbase += 0x10;
;;;418      }
;;;419      else /* The IT is in CR3 register */
;;;420      {
;;;421        usartxbase += 0x14; 
;;;422      }
;;;423      if (NewState != DISABLE)
;;;424      {
;;;425        *(__IO uint32_t*)usartxbase  |= itmask;
;;;426      }
;;;427      else
;;;428      {
;;;429        *(__IO uint32_t*)usartxbase &= ~itmask;
0003ac  6821              LDR      r1,[r4,#0]
0003ae  b12e              CBZ      r6,|L1.956|
0003b0  4301              ORRS     r1,r1,r0              ;425
0003b2  e004              B        |L1.958|
                  |L1.948|
0003b4  340c              ADDS     r4,r4,#0xc            ;425
0003b6  e7f9              B        |L1.940|
                  |L1.952|
0003b8  3410              ADDS     r4,r4,#0x10           ;413
0003ba  e7f7              B        |L1.940|
                  |L1.956|
0003bc  4381              BICS     r1,r1,r0
                  |L1.958|
0003be  6021              STR      r1,[r4,#0]            ;425
                  |L1.960|
;;;430      }
;;;431    }
0003c0  e8bd87f0          POP      {r4-r10,pc}
;;;432    
                          ENDP

                  USART_DMACmd PROC
;;;447      */
;;;448    void USART_DMACmd(USART_TypeDef* USARTx, uint16_t USART_DMAReq, FunctionalState NewState)
0003c4  b570              PUSH     {r4-r6,lr}
;;;449    {
0003c6  4604              MOV      r4,r0
;;;450      /* Check the parameters */
;;;451      assert_param(IS_USART_ALL_PERIPH(USARTx));
0003c8  480d              LDR      r0,|L1.1024|
0003ca  4616              MOV      r6,r2                 ;449
0003cc  460d              MOV      r5,r1                 ;449
0003ce  4284              CMP      r4,r0
0003d0  d010              BEQ      |L1.1012|
0003d2  480c              LDR      r0,|L1.1028|
0003d4  4284              CMP      r4,r0
0003d6  d00d              BEQ      |L1.1012|
0003d8  480b              LDR      r0,|L1.1032|
0003da  4284              CMP      r4,r0
0003dc  d00a              BEQ      |L1.1012|
0003de  480b              LDR      r0,|L1.1036|
0003e0  4284              CMP      r4,r0
0003e2  d007              BEQ      |L1.1012|
0003e4  480a              LDR      r0,|L1.1040|
0003e6  4284              CMP      r4,r0
0003e8  d004              BEQ      |L1.1012|
0003ea  f24011c3          MOV      r1,#0x1c3
0003ee  a009              ADR      r0,|L1.1044|
0003f0  f7fffffe          BL       assert_failed
                  |L1.1012|
;;;452      assert_param(IS_USART_DMAREQ(USART_DMAReq));  
0003f4  f03500c0          BICS     r0,r5,#0xc0
0003f8  d100              BNE      |L1.1020|
0003fa  b905              CBNZ     r5,|L1.1022|
                  |L1.1020|
0003fc  e026              B        |L1.1100|
                  |L1.1022|
0003fe  e02b              B        |L1.1112|
                  |L1.1024|
                          DCD      0x40013800
                  |L1.1028|
                          DCD      0x40004400
                  |L1.1032|
                          DCD      0x40004800
                  |L1.1036|
                          DCD      0x40004c00
                  |L1.1040|
                          DCD      0x40005000
                  |L1.1044|
000414  2e2e5c53          DCB      "..\\STM32F10x_StdPeriph_Driver\\src\\stm32f10x_usart.c",0
000418  544d3332
00041c  46313078
000420  5f537464
000424  50657269
000428  70685f44
00042c  72697665
000430  725c7372
000434  635c7374
000438  6d333266
00043c  3130785f
000440  75736172
000444  742e6300
                  |L1.1096|
                          DCD      0x0044aa20
                  |L1.1100|
00044c  f44f71e2          MOV      r1,#0x1c4
000450  f2af0040          ADR      r0,|L1.1044|
000454  f7fffffe          BL       assert_failed
                  |L1.1112|
;;;453      assert_param(IS_FUNCTIONAL_STATE(NewState)); 
000458  b156              CBZ      r6,|L1.1136|
00045a  2e01              CMP      r6,#1
00045c  d005              BEQ      |L1.1130|
00045e  f24011c5          MOV      r1,#0x1c5
000462  f2af0050          ADR      r0,|L1.1044|
000466  f7fffffe          BL       assert_failed
                  |L1.1130|
;;;454      if (NewState != DISABLE)
;;;455      {
;;;456        /* Enable the DMA transfer for selected requests by setting the DMAT and/or
;;;457           DMAR bits in the USART CR3 register */
;;;458        USARTx->CR3 |= USART_DMAReq;
00046a  8aa0              LDRH     r0,[r4,#0x14]
00046c  4328              ORRS     r0,r0,r5
00046e  e001              B        |L1.1140|
                  |L1.1136|
;;;459      }
;;;460      else
;;;461      {
;;;462        /* Disable the DMA transfer for selected requests by clearing the DMAT and/or
;;;463           DMAR bits in the USART CR3 register */
;;;464        USARTx->CR3 &= (uint16_t)~USART_DMAReq;
000470  8aa0              LDRH     r0,[r4,#0x14]
000472  43a8              BICS     r0,r0,r5
                  |L1.1140|
000474  82a0              STRH     r0,[r4,#0x14]         ;458
;;;465      }
;;;466    }
000476  bd70              POP      {r4-r6,pc}
;;;467    
                          ENDP

                  USART_SetAddress PROC
;;;475      */
;;;476    void USART_SetAddress(USART_TypeDef* USARTx, uint8_t USART_Address)
000478  b570              PUSH     {r4-r6,lr}
;;;477    {
00047a  4604              MOV      r4,r0
;;;478      /* Check the parameters */
;;;479      assert_param(IS_USART_ALL_PERIPH(USARTx));
00047c  48fc              LDR      r0,|L1.2160|
00047e  460d              MOV      r5,r1                 ;477
000480  4284              CMP      r4,r0
000482  d011              BEQ      |L1.1192|
000484  48fb              LDR      r0,|L1.2164|
000486  4284              CMP      r4,r0
000488  d00e              BEQ      |L1.1192|
00048a  48fb              LDR      r0,|L1.2168|
00048c  4284              CMP      r4,r0
00048e  d00b              BEQ      |L1.1192|
000490  48fa              LDR      r0,|L1.2172|
000492  4284              CMP      r4,r0
000494  d008              BEQ      |L1.1192|
000496  48fa              LDR      r0,|L1.2176|
000498  4284              CMP      r4,r0
00049a  d005              BEQ      |L1.1192|
00049c  f24011df          MOV      r1,#0x1df
0004a0  f2af0090          ADR      r0,|L1.1044|
0004a4  f7fffffe          BL       assert_failed
                  |L1.1192|
;;;480      assert_param(IS_USART_ADDRESS(USART_Address)); 
0004a8  2d0f              CMP      r5,#0xf
0004aa  d905              BLS      |L1.1208|
0004ac  f44f71f0          MOV      r1,#0x1e0
0004b0  f2af00a0          ADR      r0,|L1.1044|
0004b4  f7fffffe          BL       assert_failed
                  |L1.1208|
;;;481        
;;;482      /* Clear the USART address */
;;;483      USARTx->CR2 &= CR2_Address_Mask;
0004b8  8a20              LDRH     r0,[r4,#0x10]
0004ba  f020000f          BIC      r0,r0,#0xf
0004be  8220              STRH     r0,[r4,#0x10]
;;;484      /* Set the USART address node */
;;;485      USARTx->CR2 |= USART_Address;
0004c0  8a20              LDRH     r0,[r4,#0x10]
0004c2  4328              ORRS     r0,r0,r5
0004c4  8220              STRH     r0,[r4,#0x10]
;;;486    }
0004c6  bd70              POP      {r4-r6,pc}
;;;487    
                          ENDP

                  USART_WakeUpConfig PROC
;;;498      */
;;;499    void USART_WakeUpConfig(USART_TypeDef* USARTx, uint16_t USART_WakeUp)
0004c8  b570              PUSH     {r4-r6,lr}
;;;500    {
0004ca  4604              MOV      r4,r0
;;;501      /* Check the parameters */
;;;502      assert_param(IS_USART_ALL_PERIPH(USARTx));
0004cc  48e8              LDR      r0,|L1.2160|
0004ce  460d              MOV      r5,r1                 ;500
0004d0  4284              CMP      r4,r0
0004d2  d011              BEQ      |L1.1272|
0004d4  48e7              LDR      r0,|L1.2164|
0004d6  4284              CMP      r4,r0
0004d8  d00e              BEQ      |L1.1272|
0004da  48e7              LDR      r0,|L1.2168|
0004dc  4284              CMP      r4,r0
0004de  d00b              BEQ      |L1.1272|
0004e0  48e6              LDR      r0,|L1.2172|
0004e2  4284              CMP      r4,r0
0004e4  d008              BEQ      |L1.1272|
0004e6  48e6              LDR      r0,|L1.2176|
0004e8  4284              CMP      r4,r0
0004ea  d005              BEQ      |L1.1272|
0004ec  f44f71fb          MOV      r1,#0x1f6
0004f0  f2af00e0          ADR      r0,|L1.1044|
0004f4  f7fffffe          BL       assert_failed
                  |L1.1272|
;;;503      assert_param(IS_USART_WAKEUP(USART_WakeUp));
0004f8  b145              CBZ      r5,|L1.1292|
0004fa  f5b56f00          CMP      r5,#0x800
0004fe  d005              BEQ      |L1.1292|
000500  f24011f7          MOV      r1,#0x1f7
000504  f2af00f4          ADR      r0,|L1.1044|
000508  f7fffffe          BL       assert_failed
                  |L1.1292|
;;;504      
;;;505      USARTx->CR1 &= CR1_WAKE_Mask;
00050c  89a0              LDRH     r0,[r4,#0xc]
00050e  f4206000          BIC      r0,r0,#0x800
000512  81a0              STRH     r0,[r4,#0xc]
;;;506      USARTx->CR1 |= USART_WakeUp;
000514  89a0              LDRH     r0,[r4,#0xc]
000516  4328              ORRS     r0,r0,r5
000518  81a0              STRH     r0,[r4,#0xc]
;;;507    }
00051a  bd70              POP      {r4-r6,pc}
;;;508    
                          ENDP

                  USART_ReceiverWakeUpCmd PROC
;;;517      */
;;;518    void USART_ReceiverWakeUpCmd(USART_TypeDef* USARTx, FunctionalState NewState)
00051c  b570              PUSH     {r4-r6,lr}
;;;519    {
00051e  4604              MOV      r4,r0
;;;520      /* Check the parameters */
;;;521      assert_param(IS_USART_ALL_PERIPH(USARTx));
000520  48d3              LDR      r0,|L1.2160|
000522  460d              MOV      r5,r1                 ;519
000524  4284              CMP      r4,r0
000526  d011              BEQ      |L1.1356|
000528  48d2              LDR      r0,|L1.2164|
00052a  4284              CMP      r4,r0
00052c  d00e              BEQ      |L1.1356|
00052e  48d2              LDR      r0,|L1.2168|
000530  4284              CMP      r4,r0
000532  d00b              BEQ      |L1.1356|
000534  48d1              LDR      r0,|L1.2172|
000536  4284              CMP      r4,r0
000538  d008              BEQ      |L1.1356|
00053a  48d1              LDR      r0,|L1.2176|
00053c  4284              CMP      r4,r0
00053e  d005              BEQ      |L1.1356|
000540  f2402109          MOV      r1,#0x209
000544  f2af1034          ADR      r0,|L1.1044|
000548  f7fffffe          BL       assert_failed
                  |L1.1356|
;;;522      assert_param(IS_FUNCTIONAL_STATE(NewState)); 
00054c  b15d              CBZ      r5,|L1.1382|
00054e  2d01              CMP      r5,#1
000550  d005              BEQ      |L1.1374|
000552  f240210a          MOV      r1,#0x20a
000556  f2af1044          ADR      r0,|L1.1044|
00055a  f7fffffe          BL       assert_failed
                  |L1.1374|
;;;523      
;;;524      if (NewState != DISABLE)
;;;525      {
;;;526        /* Enable the USART mute mode  by setting the RWU bit in the CR1 register */
;;;527        USARTx->CR1 |= CR1_RWU_Set;
00055e  89a0              LDRH     r0,[r4,#0xc]
000560  f0400002          ORR      r0,r0,#2
000564  e002              B        |L1.1388|
                  |L1.1382|
;;;528      }
;;;529      else
;;;530      {
;;;531        /* Disable the USART mute mode by clearing the RWU bit in the CR1 register */
;;;532        USARTx->CR1 &= CR1_RWU_Reset;
000566  89a0              LDRH     r0,[r4,#0xc]
000568  f0200002          BIC      r0,r0,#2
                  |L1.1388|
00056c  81a0              STRH     r0,[r4,#0xc]          ;527
;;;533      }
;;;534    }
00056e  bd70              POP      {r4-r6,pc}
;;;535    
                          ENDP

                  USART_LINBreakDetectLengthConfig PROC
;;;546      */
;;;547    void USART_LINBreakDetectLengthConfig(USART_TypeDef* USARTx, uint16_t USART_LINBreakDetectLength)
000570  b570              PUSH     {r4-r6,lr}
;;;548    {
000572  4604              MOV      r4,r0
;;;549      /* Check the parameters */
;;;550      assert_param(IS_USART_ALL_PERIPH(USARTx));
000574  48be              LDR      r0,|L1.2160|
000576  460d              MOV      r5,r1                 ;548
000578  4284              CMP      r4,r0
00057a  d011              BEQ      |L1.1440|
00057c  48bd              LDR      r0,|L1.2164|
00057e  4284              CMP      r4,r0
000580  d00e              BEQ      |L1.1440|
000582  48bd              LDR      r0,|L1.2168|
000584  4284              CMP      r4,r0
000586  d00b              BEQ      |L1.1440|
000588  48bc              LDR      r0,|L1.2172|
00058a  4284              CMP      r4,r0
00058c  d008              BEQ      |L1.1440|
00058e  48bc              LDR      r0,|L1.2176|
000590  4284              CMP      r4,r0
000592  d005              BEQ      |L1.1440|
000594  f2402126          MOV      r1,#0x226
000598  f2af1088          ADR      r0,|L1.1044|
00059c  f7fffffe          BL       assert_failed
                  |L1.1440|
;;;551      assert_param(IS_USART_LIN_BREAK_DETECT_LENGTH(USART_LINBreakDetectLength));
0005a0  b13d              CBZ      r5,|L1.1458|
0005a2  2d20              CMP      r5,#0x20
0005a4  d005              BEQ      |L1.1458|
0005a6  f2402127          MOV      r1,#0x227
0005aa  f2af1098          ADR      r0,|L1.1044|
0005ae  f7fffffe          BL       assert_failed
                  |L1.1458|
;;;552      
;;;553      USARTx->CR2 &= CR2_LBDL_Mask;
0005b2  8a20              LDRH     r0,[r4,#0x10]
0005b4  f0200020          BIC      r0,r0,#0x20
0005b8  8220              STRH     r0,[r4,#0x10]
;;;554      USARTx->CR2 |= USART_LINBreakDetectLength;  
0005ba  8a20              LDRH     r0,[r4,#0x10]
0005bc  4328              ORRS     r0,r0,r5
0005be  8220              STRH     r0,[r4,#0x10]
;;;555    }
0005c0  bd70              POP      {r4-r6,pc}
;;;556    
                          ENDP

                  USART_LINCmd PROC
;;;565      */
;;;566    void USART_LINCmd(USART_TypeDef* USARTx, FunctionalState NewState)
0005c2  b570              PUSH     {r4-r6,lr}
;;;567    {
0005c4  4604              MOV      r4,r0
;;;568      /* Check the parameters */
;;;569      assert_param(IS_USART_ALL_PERIPH(USARTx));
0005c6  48aa              LDR      r0,|L1.2160|
0005c8  460d              MOV      r5,r1                 ;567
0005ca  4284              CMP      r4,r0
0005cc  d011              BEQ      |L1.1522|
0005ce  48a9              LDR      r0,|L1.2164|
0005d0  4284              CMP      r4,r0
0005d2  d00e              BEQ      |L1.1522|
0005d4  48a8              LDR      r0,|L1.2168|
0005d6  4284              CMP      r4,r0
0005d8  d00b              BEQ      |L1.1522|
0005da  48a8              LDR      r0,|L1.2172|
0005dc  4284              CMP      r4,r0
0005de  d008              BEQ      |L1.1522|
0005e0  48a7              LDR      r0,|L1.2176|
0005e2  4284              CMP      r4,r0
0005e4  d005              BEQ      |L1.1522|
0005e6  f2402139          MOV      r1,#0x239
0005ea  f2af10d8          ADR      r0,|L1.1044|
0005ee  f7fffffe          BL       assert_failed
                  |L1.1522|
;;;570      assert_param(IS_FUNCTIONAL_STATE(NewState));
0005f2  b15d              CBZ      r5,|L1.1548|
0005f4  2d01              CMP      r5,#1
0005f6  d005              BEQ      |L1.1540|
0005f8  f240213a          MOV      r1,#0x23a
0005fc  f2af10ec          ADR      r0,|L1.1044|
000600  f7fffffe          BL       assert_failed
                  |L1.1540|
;;;571      
;;;572      if (NewState != DISABLE)
;;;573      {
;;;574        /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
;;;575        USARTx->CR2 |= CR2_LINEN_Set;
000604  8a20              LDRH     r0,[r4,#0x10]
000606  f4404080          ORR      r0,r0,#0x4000
00060a  e002              B        |L1.1554|
                  |L1.1548|
;;;576      }
;;;577      else
;;;578      {
;;;579        /* Disable the LIN mode by clearing the LINEN bit in the CR2 register */
;;;580        USARTx->CR2 &= CR2_LINEN_Reset;
00060c  8a20              LDRH     r0,[r4,#0x10]
00060e  f4204080          BIC      r0,r0,#0x4000
                  |L1.1554|
000612  8220              STRH     r0,[r4,#0x10]         ;575
;;;581      }
;;;582    }
000614  bd70              POP      {r4-r6,pc}
;;;583    
                          ENDP

                  USART_SendData PROC
;;;591      */
;;;592    void USART_SendData(USART_TypeDef* USARTx, uint16_t Data)
000616  b570              PUSH     {r4-r6,lr}
;;;593    {
000618  4604              MOV      r4,r0
;;;594      /* Check the parameters */
;;;595      assert_param(IS_USART_ALL_PERIPH(USARTx));
00061a  4895              LDR      r0,|L1.2160|
00061c  460d              MOV      r5,r1                 ;593
00061e  4284              CMP      r4,r0
000620  d011              BEQ      |L1.1606|
000622  4894              LDR      r0,|L1.2164|
000624  4284              CMP      r4,r0
000626  d00e              BEQ      |L1.1606|
000628  4893              LDR      r0,|L1.2168|
00062a  4284              CMP      r4,r0
00062c  d00b              BEQ      |L1.1606|
00062e  4893              LDR      r0,|L1.2172|
000630  4284              CMP      r4,r0
000632  d008              BEQ      |L1.1606|
000634  4892              LDR      r0,|L1.2176|
000636  4284              CMP      r4,r0
000638  d005              BEQ      |L1.1606|
00063a  f2402153          MOV      r1,#0x253
00063e  f2af202c          ADR      r0,|L1.1044|
000642  f7fffffe          BL       assert_failed
                  |L1.1606|
;;;596      assert_param(IS_USART_DATA(Data)); 
000646  f5b57f00          CMP      r5,#0x200
00064a  d305              BCC      |L1.1624|
00064c  f44f7115          MOV      r1,#0x254
000650  f2af2040          ADR      r0,|L1.1044|
000654  f7fffffe          BL       assert_failed
                  |L1.1624|
;;;597        
;;;598      /* Transmit Data */
;;;599      USARTx->DR = (Data & (uint16_t)0x01FF);
000658  f3c50008          UBFX     r0,r5,#0,#9
00065c  80a0              STRH     r0,[r4,#4]
;;;600    }
00065e  bd70              POP      {r4-r6,pc}
;;;601    
                          ENDP

                  USART_ReceiveData PROC
;;;608      */
;;;609    uint16_t USART_ReceiveData(USART_TypeDef* USARTx)
000660  b510              PUSH     {r4,lr}
;;;610    {
000662  4604              MOV      r4,r0
;;;611      /* Check the parameters */
;;;612      assert_param(IS_USART_ALL_PERIPH(USARTx));
000664  4882              LDR      r0,|L1.2160|
000666  4284              CMP      r4,r0
000668  d011              BEQ      |L1.1678|
00066a  4882              LDR      r0,|L1.2164|
00066c  4284              CMP      r4,r0
00066e  d00e              BEQ      |L1.1678|
000670  4881              LDR      r0,|L1.2168|
000672  4284              CMP      r4,r0
000674  d00b              BEQ      |L1.1678|
000676  4881              LDR      r0,|L1.2172|
000678  4284              CMP      r4,r0
00067a  d008              BEQ      |L1.1678|
00067c  4880              LDR      r0,|L1.2176|
00067e  4284              CMP      r4,r0
000680  d005              BEQ      |L1.1678|
000682  f44f7119          MOV      r1,#0x264
000686  f2af2074          ADR      r0,|L1.1044|
00068a  f7fffffe          BL       assert_failed
                  |L1.1678|
;;;613      
;;;614      /* Receive Data */
;;;615      return (uint16_t)(USARTx->DR & (uint16_t)0x01FF);
00068e  88a0              LDRH     r0,[r4,#4]
000690  f3c00008          UBFX     r0,r0,#0,#9
;;;616    }
000694  bd10              POP      {r4,pc}
;;;617    
                          ENDP

                  USART_SendBreak PROC
;;;624      */
;;;625    void USART_SendBreak(USART_TypeDef* USARTx)
000696  b510              PUSH     {r4,lr}
;;;626    {
000698  4604              MOV      r4,r0
;;;627      /* Check the parameters */
;;;628      assert_param(IS_USART_ALL_PERIPH(USARTx));
00069a  4875              LDR      r0,|L1.2160|
00069c  4284              CMP      r4,r0
00069e  d011              BEQ      |L1.1732|
0006a0  4874              LDR      r0,|L1.2164|
0006a2  4284              CMP      r4,r0
0006a4  d00e              BEQ      |L1.1732|
0006a6  4874              LDR      r0,|L1.2168|
0006a8  4284              CMP      r4,r0
0006aa  d00b              BEQ      |L1.1732|
0006ac  4873              LDR      r0,|L1.2172|
0006ae  4284              CMP      r4,r0
0006b0  d008              BEQ      |L1.1732|
0006b2  4873              LDR      r0,|L1.2176|
0006b4  4284              CMP      r4,r0
0006b6  d005              BEQ      |L1.1732|
0006b8  f44f711d          MOV      r1,#0x274
0006bc  f2af20ac          ADR      r0,|L1.1044|
0006c0  f7fffffe          BL       assert_failed
                  |L1.1732|
;;;629      
;;;630      /* Send break characters */
;;;631      USARTx->CR1 |= CR1_SBK_Set;
0006c4  89a0              LDRH     r0,[r4,#0xc]
0006c6  f0400001          ORR      r0,r0,#1
0006ca  81a0              STRH     r0,[r4,#0xc]
;;;632    }
0006cc  bd10              POP      {r4,pc}
;;;633    
                          ENDP

                  USART_SetGuardTime PROC
;;;640      */
;;;641    void USART_SetGuardTime(USART_TypeDef* USARTx, uint8_t USART_GuardTime)
0006ce  b570              PUSH     {r4-r6,lr}
;;;642    {    
0006d0  4604              MOV      r4,r0
;;;643      /* Check the parameters */
;;;644      assert_param(IS_USART_123_PERIPH(USARTx));
0006d2  4867              LDR      r0,|L1.2160|
0006d4  460d              MOV      r5,r1                 ;642
0006d6  4284              CMP      r4,r0
0006d8  d00b              BEQ      |L1.1778|
0006da  4866              LDR      r0,|L1.2164|
0006dc  4284              CMP      r4,r0
0006de  d008              BEQ      |L1.1778|
0006e0  4865              LDR      r0,|L1.2168|
0006e2  4284              CMP      r4,r0
0006e4  d005              BEQ      |L1.1778|
0006e6  f44f7121          MOV      r1,#0x284
0006ea  f2af20d8          ADR      r0,|L1.1044|
0006ee  f7fffffe          BL       assert_failed
                  |L1.1778|
;;;645      
;;;646      /* Clear the USART Guard time */
;;;647      USARTx->GTPR &= GTPR_LSB_Mask;
0006f2  8b20              LDRH     r0,[r4,#0x18]
0006f4  b2c0              UXTB     r0,r0
0006f6  8320              STRH     r0,[r4,#0x18]
;;;648      /* Set the USART guard time */
;;;649      USARTx->GTPR |= (uint16_t)((uint16_t)USART_GuardTime << 0x08);
0006f8  8b20              LDRH     r0,[r4,#0x18]
0006fa  ea402005          ORR      r0,r0,r5,LSL #8
0006fe  8320              STRH     r0,[r4,#0x18]
;;;650    }
000700  bd70              POP      {r4-r6,pc}
;;;651    
                          ENDP

                  USART_SetPrescaler PROC
;;;660      */
;;;661    void USART_SetPrescaler(USART_TypeDef* USARTx, uint8_t USART_Prescaler)
000702  b570              PUSH     {r4-r6,lr}
;;;662    { 
000704  4604              MOV      r4,r0
;;;663      /* Check the parameters */
;;;664      assert_param(IS_USART_ALL_PERIPH(USARTx));
000706  485a              LDR      r0,|L1.2160|
000708  460d              MOV      r5,r1                 ;662
00070a  4284              CMP      r4,r0
00070c  d011              BEQ      |L1.1842|
00070e  4859              LDR      r0,|L1.2164|
000710  4284              CMP      r4,r0
000712  d00e              BEQ      |L1.1842|
000714  4858              LDR      r0,|L1.2168|
000716  4284              CMP      r4,r0
000718  d00b              BEQ      |L1.1842|
00071a  4858              LDR      r0,|L1.2172|
00071c  4284              CMP      r4,r0
00071e  d008              BEQ      |L1.1842|
000720  4857              LDR      r0,|L1.2176|
000722  4284              CMP      r4,r0
000724  d005              BEQ      |L1.1842|
000726  f44f7126          MOV      r1,#0x298
00072a  f2af3018          ADR      r0,|L1.1044|
00072e  f7fffffe          BL       assert_failed
                  |L1.1842|
;;;665      
;;;666      /* Clear the USART prescaler */
;;;667      USARTx->GTPR &= GTPR_MSB_Mask;
000732  8b20              LDRH     r0,[r4,#0x18]
000734  f400407f          AND      r0,r0,#0xff00
000738  8320              STRH     r0,[r4,#0x18]
;;;668      /* Set the USART prescaler */
;;;669      USARTx->GTPR |= USART_Prescaler;
00073a  8b20              LDRH     r0,[r4,#0x18]
00073c  4328              ORRS     r0,r0,r5
00073e  8320              STRH     r0,[r4,#0x18]
;;;670    }
000740  bd70              POP      {r4-r6,pc}
;;;671    
                          ENDP

                  USART_SmartCardCmd PROC
;;;679      */
;;;680    void USART_SmartCardCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000742  b570              PUSH     {r4-r6,lr}
;;;681    {
000744  4604              MOV      r4,r0
;;;682      /* Check the parameters */
;;;683      assert_param(IS_USART_123_PERIPH(USARTx));
000746  484a              LDR      r0,|L1.2160|
000748  460d              MOV      r5,r1                 ;681
00074a  4284              CMP      r4,r0
00074c  d00b              BEQ      |L1.1894|
00074e  4849              LDR      r0,|L1.2164|
000750  4284              CMP      r4,r0
000752  d008              BEQ      |L1.1894|
000754  4848              LDR      r0,|L1.2168|
000756  4284              CMP      r4,r0
000758  d005              BEQ      |L1.1894|
00075a  f24021ab          MOV      r1,#0x2ab
00075e  f2af304c          ADR      r0,|L1.1044|
000762  f7fffffe          BL       assert_failed
                  |L1.1894|
;;;684      assert_param(IS_FUNCTIONAL_STATE(NewState));
000766  b15d              CBZ      r5,|L1.1920|
000768  2d01              CMP      r5,#1
00076a  d005              BEQ      |L1.1912|
00076c  f44f712b          MOV      r1,#0x2ac
000770  f2af3060          ADR      r0,|L1.1044|
000774  f7fffffe          BL       assert_failed
                  |L1.1912|
;;;685      if (NewState != DISABLE)
;;;686      {
;;;687        /* Enable the SC mode by setting the SCEN bit in the CR3 register */
;;;688        USARTx->CR3 |= CR3_SCEN_Set;
000778  8aa0              LDRH     r0,[r4,#0x14]
00077a  f0400020          ORR      r0,r0,#0x20
00077e  e002              B        |L1.1926|
                  |L1.1920|
;;;689      }
;;;690      else
;;;691      {
;;;692        /* Disable the SC mode by clearing the SCEN bit in the CR3 register */
;;;693        USARTx->CR3 &= CR3_SCEN_Reset;
000780  8aa0              LDRH     r0,[r4,#0x14]
000782  f0200020          BIC      r0,r0,#0x20
                  |L1.1926|
000786  82a0              STRH     r0,[r4,#0x14]         ;688
;;;694      }
;;;695    }
000788  bd70              POP      {r4-r6,pc}
;;;696    
                          ENDP

                  USART_SmartCardNACKCmd PROC
;;;704      */
;;;705    void USART_SmartCardNACKCmd(USART_TypeDef* USARTx, FunctionalState NewState)
00078a  b570              PUSH     {r4-r6,lr}
;;;706    {
00078c  4604              MOV      r4,r0
;;;707      /* Check the parameters */
;;;708      assert_param(IS_USART_123_PERIPH(USARTx));  
00078e  4838              LDR      r0,|L1.2160|
000790  460d              MOV      r5,r1                 ;706
000792  4284              CMP      r4,r0
000794  d00b              BEQ      |L1.1966|
000796  4837              LDR      r0,|L1.2164|
000798  4284              CMP      r4,r0
00079a  d008              BEQ      |L1.1966|
00079c  4836              LDR      r0,|L1.2168|
00079e  4284              CMP      r4,r0
0007a0  d005              BEQ      |L1.1966|
0007a2  f44f7131          MOV      r1,#0x2c4
0007a6  f2af3094          ADR      r0,|L1.1044|
0007aa  f7fffffe          BL       assert_failed
                  |L1.1966|
;;;709      assert_param(IS_FUNCTIONAL_STATE(NewState));
0007ae  b15d              CBZ      r5,|L1.1992|
0007b0  2d01              CMP      r5,#1
0007b2  d005              BEQ      |L1.1984|
0007b4  f24021c5          MOV      r1,#0x2c5
0007b8  f2af30a8          ADR      r0,|L1.1044|
0007bc  f7fffffe          BL       assert_failed
                  |L1.1984|
;;;710      if (NewState != DISABLE)
;;;711      {
;;;712        /* Enable the NACK transmission by setting the NACK bit in the CR3 register */
;;;713        USARTx->CR3 |= CR3_NACK_Set;
0007c0  8aa0              LDRH     r0,[r4,#0x14]
0007c2  f0400010          ORR      r0,r0,#0x10
0007c6  e002              B        |L1.1998|
                  |L1.1992|
;;;714      }
;;;715      else
;;;716      {
;;;717        /* Disable the NACK transmission by clearing the NACK bit in the CR3 register */
;;;718        USARTx->CR3 &= CR3_NACK_Reset;
0007c8  8aa0              LDRH     r0,[r4,#0x14]
0007ca  f0200010          BIC      r0,r0,#0x10
                  |L1.1998|
0007ce  82a0              STRH     r0,[r4,#0x14]         ;713
;;;719      }
;;;720    }
0007d0  bd70              POP      {r4-r6,pc}
;;;721    
                          ENDP

                  USART_HalfDuplexCmd PROC
;;;730      */
;;;731    void USART_HalfDuplexCmd(USART_TypeDef* USARTx, FunctionalState NewState)
0007d2  b570              PUSH     {r4-r6,lr}
;;;732    {
0007d4  4604              MOV      r4,r0
;;;733      /* Check the parameters */
;;;734      assert_param(IS_USART_ALL_PERIPH(USARTx));
0007d6  4826              LDR      r0,|L1.2160|
0007d8  460d              MOV      r5,r1                 ;732
0007da  4284              CMP      r4,r0
0007dc  d011              BEQ      |L1.2050|
0007de  4825              LDR      r0,|L1.2164|
0007e0  4284              CMP      r4,r0
0007e2  d00e              BEQ      |L1.2050|
0007e4  4824              LDR      r0,|L1.2168|
0007e6  4284              CMP      r4,r0
0007e8  d00b              BEQ      |L1.2050|
0007ea  4824              LDR      r0,|L1.2172|
0007ec  4284              CMP      r4,r0
0007ee  d008              BEQ      |L1.2050|
0007f0  4823              LDR      r0,|L1.2176|
0007f2  4284              CMP      r4,r0
0007f4  d005              BEQ      |L1.2050|
0007f6  f24021de          MOV      r1,#0x2de
0007fa  f2af30e8          ADR      r0,|L1.1044|
0007fe  f7fffffe          BL       assert_failed
                  |L1.2050|
;;;735      assert_param(IS_FUNCTIONAL_STATE(NewState));
000802  b15d              CBZ      r5,|L1.2076|
000804  2d01              CMP      r5,#1
000806  d005              BEQ      |L1.2068|
000808  f24021df          MOV      r1,#0x2df
00080c  f2af30fc          ADR      r0,|L1.1044|
000810  f7fffffe          BL       assert_failed
                  |L1.2068|
;;;736      
;;;737      if (NewState != DISABLE)
;;;738      {
;;;739        /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
;;;740        USARTx->CR3 |= CR3_HDSEL_Set;
000814  8aa0              LDRH     r0,[r4,#0x14]
000816  f0400008          ORR      r0,r0,#8
00081a  e002              B        |L1.2082|
                  |L1.2076|
;;;741      }
;;;742      else
;;;743      {
;;;744        /* Disable the Half-Duplex mode by clearing the HDSEL bit in the CR3 register */
;;;745        USARTx->CR3 &= CR3_HDSEL_Reset;
00081c  8aa0              LDRH     r0,[r4,#0x14]
00081e  f0200008          BIC      r0,r0,#8
                  |L1.2082|
000822  82a0              STRH     r0,[r4,#0x14]         ;740
;;;746      }
;;;747    }
000824  bd70              POP      {r4-r6,pc}
;;;748    
                          ENDP

                  USART_OverSampling8Cmd PROC
;;;761      */
;;;762    void USART_OverSampling8Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
000826  b570              PUSH     {r4-r6,lr}
;;;763    {
000828  4604              MOV      r4,r0
;;;764      /* Check the parameters */
;;;765      assert_param(IS_USART_ALL_PERIPH(USARTx));
00082a  4811              LDR      r0,|L1.2160|
00082c  460d              MOV      r5,r1                 ;763
00082e  4284              CMP      r4,r0
000830  d011              BEQ      |L1.2134|
000832  4810              LDR      r0,|L1.2164|
000834  4284              CMP      r4,r0
000836  d00e              BEQ      |L1.2134|
000838  480f              LDR      r0,|L1.2168|
00083a  4284              CMP      r4,r0
00083c  d00b              BEQ      |L1.2134|
00083e  480f              LDR      r0,|L1.2172|
000840  4284              CMP      r4,r0
000842  d008              BEQ      |L1.2134|
000844  480e              LDR      r0,|L1.2176|
000846  4284              CMP      r4,r0
000848  d005              BEQ      |L1.2134|
00084a  f24021fd          MOV      r1,#0x2fd
00084e  f2af403c          ADR      r0,|L1.1044|
000852  f7fffffe          BL       assert_failed
                  |L1.2134|
;;;766      assert_param(IS_FUNCTIONAL_STATE(NewState));
000856  b1ad              CBZ      r5,|L1.2180|
000858  2d01              CMP      r5,#1
00085a  d005              BEQ      |L1.2152|
00085c  f24021fe          MOV      r1,#0x2fe
000860  f2af4050          ADR      r0,|L1.1044|
000864  f7fffffe          BL       assert_failed
                  |L1.2152|
;;;767      
;;;768      if (NewState != DISABLE)
;;;769      {
;;;770        /* Enable the 8x Oversampling mode by setting the OVER8 bit in the CR1 register */
;;;771        USARTx->CR1 |= CR1_OVER8_Set;
000868  89a0              LDRH     r0,[r4,#0xc]
00086a  f4404000          ORR      r0,r0,#0x8000
00086e  e00c              B        |L1.2186|
                  |L1.2160|
                          DCD      0x40013800
                  |L1.2164|
                          DCD      0x40004400
                  |L1.2168|
                          DCD      0x40004800
                  |L1.2172|
                          DCD      0x40004c00
                  |L1.2176|
                          DCD      0x40005000
                  |L1.2180|
;;;772      }
;;;773      else
;;;774      {
;;;775        /* Disable the 8x Oversampling mode by clearing the OVER8 bit in the CR1 register */
;;;776        USARTx->CR1 &= CR1_OVER8_Reset;
000884  89a0              LDRH     r0,[r4,#0xc]
000886  f3c0000e          UBFX     r0,r0,#0,#15
                  |L1.2186|
00088a  81a0              STRH     r0,[r4,#0xc]          ;771
;;;777      }
;;;778    }
00088c  bd70              POP      {r4-r6,pc}
;;;779    
                          ENDP

                  USART_OneBitMethodCmd PROC
;;;788      */
;;;789    void USART_OneBitMethodCmd(USART_TypeDef* USARTx, FunctionalState NewState)
00088e  b570              PUSH     {r4-r6,lr}
;;;790    {
000890  4604              MOV      r4,r0
;;;791      /* Check the parameters */
;;;792      assert_param(IS_USART_ALL_PERIPH(USARTx));
000892  48d1              LDR      r0,|L1.3032|
000894  460d              MOV      r5,r1                 ;790
000896  4284              CMP      r4,r0
000898  d011              BEQ      |L1.2238|
00089a  48d0              LDR      r0,|L1.3036|
00089c  4284              CMP      r4,r0
00089e  d00e              BEQ      |L1.2238|
0008a0  48cf              LDR      r0,|L1.3040|
0008a2  4284              CMP      r4,r0
0008a4  d00b              BEQ      |L1.2238|
0008a6  48cf              LDR      r0,|L1.3044|
0008a8  4284              CMP      r4,r0
0008aa  d008              BEQ      |L1.2238|
0008ac  48ce              LDR      r0,|L1.3048|
0008ae  4284              CMP      r4,r0
0008b0  d005              BEQ      |L1.2238|
0008b2  f44f7146          MOV      r1,#0x318
0008b6  f2af40a4          ADR      r0,|L1.1044|
0008ba  f7fffffe          BL       assert_failed
                  |L1.2238|
;;;793      assert_param(IS_FUNCTIONAL_STATE(NewState));
0008be  b15d              CBZ      r5,|L1.2264|
0008c0  2d01              CMP      r5,#1
0008c2  d005              BEQ      |L1.2256|
0008c4  f2403119          MOV      r1,#0x319
0008c8  f2af40b8          ADR      r0,|L1.1044|
0008cc  f7fffffe          BL       assert_failed
                  |L1.2256|
;;;794      
;;;795      if (NewState != DISABLE)
;;;796      {
;;;797        /* Enable the one bit method by setting the ONEBITE bit in the CR3 register */
;;;798        USARTx->CR3 |= CR3_ONEBITE_Set;
0008d0  8aa0              LDRH     r0,[r4,#0x14]
0008d2  f4406000          ORR      r0,r0,#0x800
0008d6  e002              B        |L1.2270|
                  |L1.2264|
;;;799      }
;;;800      else
;;;801      {
;;;802        /* Disable tthe one bit method by clearing the ONEBITE bit in the CR3 register */
;;;803        USARTx->CR3 &= CR3_ONEBITE_Reset;
0008d8  8aa0              LDRH     r0,[r4,#0x14]
0008da  f4206000          BIC      r0,r0,#0x800
                  |L1.2270|
0008de  82a0              STRH     r0,[r4,#0x14]         ;798
;;;804      }
;;;805    }
0008e0  bd70              POP      {r4-r6,pc}
;;;806    
                          ENDP

                  USART_IrDAConfig PROC
;;;817      */
;;;818    void USART_IrDAConfig(USART_TypeDef* USARTx, uint16_t USART_IrDAMode)
0008e2  b570              PUSH     {r4-r6,lr}
;;;819    {
0008e4  4604              MOV      r4,r0
;;;820      /* Check the parameters */
;;;821      assert_param(IS_USART_ALL_PERIPH(USARTx));
0008e6  48bc              LDR      r0,|L1.3032|
0008e8  460d              MOV      r5,r1                 ;819
0008ea  4284              CMP      r4,r0
0008ec  d011              BEQ      |L1.2322|
0008ee  48bb              LDR      r0,|L1.3036|
0008f0  4284              CMP      r4,r0
0008f2  d00e              BEQ      |L1.2322|
0008f4  48ba              LDR      r0,|L1.3040|
0008f6  4284              CMP      r4,r0
0008f8  d00b              BEQ      |L1.2322|
0008fa  48ba              LDR      r0,|L1.3044|
0008fc  4284              CMP      r4,r0
0008fe  d008              BEQ      |L1.2322|
000900  48b9              LDR      r0,|L1.3048|
000902  4284              CMP      r4,r0
000904  d005              BEQ      |L1.2322|
000906  f2403135          MOV      r1,#0x335
00090a  f2af40f8          ADR      r0,|L1.1044|
00090e  f7fffffe          BL       assert_failed
                  |L1.2322|
;;;822      assert_param(IS_USART_IRDA_MODE(USART_IrDAMode));
000912  2d04              CMP      r5,#4
000914  d006              BEQ      |L1.2340|
000916  b12d              CBZ      r5,|L1.2340|
000918  f2403136          MOV      r1,#0x336
00091c  f2af500c          ADR      r0,|L1.1044|
000920  f7fffffe          BL       assert_failed
                  |L1.2340|
;;;823        
;;;824      USARTx->CR3 &= CR3_IRLP_Mask;
000924  8aa0              LDRH     r0,[r4,#0x14]
000926  f0200004          BIC      r0,r0,#4
00092a  82a0              STRH     r0,[r4,#0x14]
;;;825      USARTx->CR3 |= USART_IrDAMode;
00092c  8aa0              LDRH     r0,[r4,#0x14]
00092e  4328              ORRS     r0,r0,r5
000930  82a0              STRH     r0,[r4,#0x14]
;;;826    }
000932  bd70              POP      {r4-r6,pc}
;;;827    
                          ENDP

                  USART_IrDACmd PROC
;;;836      */
;;;837    void USART_IrDACmd(USART_TypeDef* USARTx, FunctionalState NewState)
000934  b570              PUSH     {r4-r6,lr}
;;;838    {
000936  4604              MOV      r4,r0
;;;839      /* Check the parameters */
;;;840      assert_param(IS_USART_ALL_PERIPH(USARTx));
000938  48a7              LDR      r0,|L1.3032|
00093a  460d              MOV      r5,r1                 ;838
00093c  4284              CMP      r4,r0
00093e  d011              BEQ      |L1.2404|
000940  48a6              LDR      r0,|L1.3036|
000942  4284              CMP      r4,r0
000944  d00e              BEQ      |L1.2404|
000946  48a6              LDR      r0,|L1.3040|
000948  4284              CMP      r4,r0
00094a  d00b              BEQ      |L1.2404|
00094c  48a5              LDR      r0,|L1.3044|
00094e  4284              CMP      r4,r0
000950  d008              BEQ      |L1.2404|
000952  48a5              LDR      r0,|L1.3048|
000954  4284              CMP      r4,r0
000956  d005              BEQ      |L1.2404|
000958  f44f7152          MOV      r1,#0x348
00095c  f2af504c          ADR      r0,|L1.1044|
000960  f7fffffe          BL       assert_failed
                  |L1.2404|
;;;841      assert_param(IS_FUNCTIONAL_STATE(NewState));
000964  b15d              CBZ      r5,|L1.2430|
000966  2d01              CMP      r5,#1
000968  d005              BEQ      |L1.2422|
00096a  f2403149          MOV      r1,#0x349
00096e  f2af505c          ADR      r0,|L1.1044|
000972  f7fffffe          BL       assert_failed
                  |L1.2422|
;;;842        
;;;843      if (NewState != DISABLE)
;;;844      {
;;;845        /* Enable the IrDA mode by setting the IREN bit in the CR3 register */
;;;846        USARTx->CR3 |= CR3_IREN_Set;
000976  8aa0              LDRH     r0,[r4,#0x14]
000978  f0400002          ORR      r0,r0,#2
00097c  e002              B        |L1.2436|
                  |L1.2430|
;;;847      }
;;;848      else
;;;849      {
;;;850        /* Disable the IrDA mode by clearing the IREN bit in the CR3 register */
;;;851        USARTx->CR3 &= CR3_IREN_Reset;
00097e  8aa0              LDRH     r0,[r4,#0x14]
000980  f0200002          BIC      r0,r0,#2
                  |L1.2436|
000984  82a0              STRH     r0,[r4,#0x14]         ;846
;;;852      }
;;;853    }
000986  bd70              POP      {r4-r6,pc}
;;;854    
                          ENDP

                  USART_GetFlagStatus PROC
;;;873      */
;;;874    FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint16_t USART_FLAG)
000988  e92d47f0          PUSH     {r4-r10,lr}
;;;875    {
;;;876      FlagStatus bitstatus = RESET;
;;;877      /* Check the parameters */
;;;878      assert_param(IS_USART_ALL_PERIPH(USARTx));
00098c  4f92              LDR      r7,|L1.3032|
00098e  2600              MOVS     r6,#0                 ;876
000990  f8df8248          LDR      r8,|L1.3036|
000994  f8df9248          LDR      r9,|L1.3040|
000998  460c              MOV      r4,r1                 ;875
00099a  4605              MOV      r5,r0                 ;875
00099c  42b8              CMP      r0,r7
00099e  d00f              BEQ      |L1.2496|
0009a0  4545              CMP      r5,r8
0009a2  d00d              BEQ      |L1.2496|
0009a4  454d              CMP      r5,r9
0009a6  d00b              BEQ      |L1.2496|
0009a8  488e              LDR      r0,|L1.3044|
0009aa  4285              CMP      r5,r0
0009ac  d008              BEQ      |L1.2496|
0009ae  488e              LDR      r0,|L1.3048|
0009b0  4285              CMP      r5,r0
0009b2  d005              BEQ      |L1.2496|
0009b4  f240316e          MOV      r1,#0x36e
0009b8  f2af50a8          ADR      r0,|L1.1044|
0009bc  f7fffffe          BL       assert_failed
                  |L1.2496|
;;;879      assert_param(IS_USART_FLAG(USART_FLAG));
0009c0  2c01              CMP      r4,#1
0009c2  d022              BEQ      |L1.2570|
0009c4  2c80              CMP      r4,#0x80
0009c6  d020              BEQ      |L1.2570|
0009c8  2c40              CMP      r4,#0x40
0009ca  d01e              BEQ      |L1.2570|
0009cc  2c20              CMP      r4,#0x20
0009ce  d01c              BEQ      |L1.2570|
0009d0  2c10              CMP      r4,#0x10
0009d2  d01a              BEQ      |L1.2570|
0009d4  f5b47f80          CMP      r4,#0x100
0009d8  d017              BEQ      |L1.2570|
0009da  f5b47f00          CMP      r4,#0x200
0009de  d008              BEQ      |L1.2546|
0009e0  2c08              CMP      r4,#8
0009e2  d012              BEQ      |L1.2570|
0009e4  2c04              CMP      r4,#4
0009e6  d010              BEQ      |L1.2570|
0009e8  2c02              CMP      r4,#2
0009ea  d00e              BEQ      |L1.2570|
0009ec  f240316f          MOV      r1,#0x36f
0009f0  e007              B        |L1.2562|
                  |L1.2546|
;;;880      /* The CTS flag is not available for UART4 and UART5 */
;;;881      if (USART_FLAG == USART_FLAG_CTS)
;;;882      {
;;;883        assert_param(IS_USART_123_PERIPH(USARTx));
0009f2  42bd              CMP      r5,r7
0009f4  d009              BEQ      |L1.2570|
0009f6  4545              CMP      r5,r8
0009f8  d007              BEQ      |L1.2570|
0009fa  454d              CMP      r5,r9
0009fc  d005              BEQ      |L1.2570|
0009fe  f2403173          MOV      r1,#0x373
                  |L1.2562|
000a02  f2af50f0          ADR      r0,|L1.1044|
000a06  f7fffffe          BL       assert_failed
                  |L1.2570|
;;;884      }  
;;;885      
;;;886      if ((USARTx->SR & USART_FLAG) != (uint16_t)RESET)
000a0a  8828              LDRH     r0,[r5,#0]
000a0c  4220              TST      r0,r4
000a0e  d000              BEQ      |L1.2578|
;;;887      {
;;;888        bitstatus = SET;
000a10  2601              MOVS     r6,#1
                  |L1.2578|
;;;889      }
;;;890      else
;;;891      {
;;;892        bitstatus = RESET;
;;;893      }
;;;894      return bitstatus;
000a12  4630              MOV      r0,r6
;;;895    }
000a14  e4d4              B        |L1.960|
;;;896    
                          ENDP

                  USART_ClearFlag PROC
;;;922      */
;;;923    void USART_ClearFlag(USART_TypeDef* USARTx, uint16_t USART_FLAG)
000a16  e92d41f0          PUSH     {r4-r8,lr}
;;;924    {
;;;925      /* Check the parameters */
;;;926      assert_param(IS_USART_ALL_PERIPH(USARTx));
000a1a  4e6f              LDR      r6,|L1.3032|
000a1c  4f6f              LDR      r7,|L1.3036|
000a1e  f8df81c0          LDR      r8,|L1.3040|
000a22  460d              MOV      r5,r1                 ;924
000a24  4604              MOV      r4,r0                 ;924
000a26  42b0              CMP      r0,r6
000a28  d00f              BEQ      |L1.2634|
000a2a  42bc              CMP      r4,r7
000a2c  d00d              BEQ      |L1.2634|
000a2e  4544              CMP      r4,r8
000a30  d00b              BEQ      |L1.2634|
000a32  486c              LDR      r0,|L1.3044|
000a34  4284              CMP      r4,r0
000a36  d008              BEQ      |L1.2634|
000a38  486b              LDR      r0,|L1.3048|
000a3a  4284              CMP      r4,r0
000a3c  d005              BEQ      |L1.2634|
000a3e  f240319e          MOV      r1,#0x39e
000a42  f2af6030          ADR      r0,|L1.1044|
000a46  f7fffffe          BL       assert_failed
                  |L1.2634|
;;;927      assert_param(IS_USART_CLEAR_FLAG(USART_FLAG));
000a4a  f4357058          BICS     r0,r5,#0x360
000a4e  d100              BNE      |L1.2642|
000a50  b92d              CBNZ     r5,|L1.2654|
                  |L1.2642|
000a52  f240319f          MOV      r1,#0x39f
000a56  f2af6044          ADR      r0,|L1.1044|
000a5a  f7fffffe          BL       assert_failed
                  |L1.2654|
;;;928      /* The CTS flag is not available for UART4 and UART5 */
;;;929      if ((USART_FLAG & USART_FLAG_CTS) == USART_FLAG_CTS)
000a5e  05a8              LSLS     r0,r5,#22
000a60  d50b              BPL      |L1.2682|
;;;930      {
;;;931        assert_param(IS_USART_123_PERIPH(USARTx));
000a62  42b4              CMP      r4,r6
000a64  d009              BEQ      |L1.2682|
000a66  42bc              CMP      r4,r7
000a68  d007              BEQ      |L1.2682|
000a6a  4544              CMP      r4,r8
000a6c  d005              BEQ      |L1.2682|
000a6e  f24031a3          MOV      r1,#0x3a3
000a72  f2af6060          ADR      r0,|L1.1044|
000a76  f7fffffe          BL       assert_failed
                  |L1.2682|
;;;932      } 
;;;933       
;;;934      USARTx->SR = (uint16_t)~USART_FLAG;
000a7a  43e8              MVNS     r0,r5
000a7c  8020              STRH     r0,[r4,#0]
                  |L1.2686|
;;;935    }
000a7e  e8bd81f0          POP      {r4-r8,pc}
;;;936    
                          ENDP

                  USART_GetITStatus PROC
;;;955      */
;;;956    ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT)
000a82  e92d47f0          PUSH     {r4-r10,lr}
;;;957    {
;;;958      uint32_t bitpos = 0x00, itmask = 0x00, usartreg = 0x00;
;;;959      ITStatus bitstatus = RESET;
;;;960      /* Check the parameters */
;;;961      assert_param(IS_USART_ALL_PERIPH(USARTx));
000a86  4f54              LDR      r7,|L1.3032|
000a88  2600              MOVS     r6,#0                 ;959
000a8a  f8df8150          LDR      r8,|L1.3036|
000a8e  f8df9150          LDR      r9,|L1.3040|
000a92  460c              MOV      r4,r1                 ;957
000a94  4605              MOV      r5,r0                 ;957
000a96  42b8              CMP      r0,r7
000a98  d00f              BEQ      |L1.2746|
000a9a  4545              CMP      r5,r8
000a9c  d00d              BEQ      |L1.2746|
000a9e  454d              CMP      r5,r9
000aa0  d00b              BEQ      |L1.2746|
000aa2  4850              LDR      r0,|L1.3044|
000aa4  4285              CMP      r5,r0
000aa6  d008              BEQ      |L1.2746|
000aa8  484f              LDR      r0,|L1.3048|
000aaa  4285              CMP      r5,r0
000aac  d005              BEQ      |L1.2746|
000aae  f24031c1          MOV      r1,#0x3c1
000ab2  f2af60a0          ADR      r0,|L1.1044|
000ab6  f7fffffe          BL       assert_failed
                  |L1.2746|
;;;962      assert_param(IS_USART_GET_IT(USART_IT));
000aba  f640106a          MOV      r0,#0x96a
000abe  2c28              CMP      r4,#0x28
000ac0  d02d              BEQ      |L1.2846|
000ac2  f5a461e0          SUB      r1,r4,#0x700
000ac6  3927              SUBS     r1,r1,#0x27
000ac8  d029              BEQ      |L1.2846|
000aca  f5a461c0          SUB      r1,r4,#0x600
000ace  3926              SUBS     r1,r1,#0x26
000ad0  d025              BEQ      |L1.2846|
000ad2  f5a461a0          SUB      r1,r4,#0x500
000ad6  3925              SUBS     r1,r1,#0x25
000ad8  d021              BEQ      |L1.2846|
000ada  f5a46180          SUB      r1,r4,#0x400
000ade  3924              SUBS     r1,r1,#0x24
000ae0  d01d              BEQ      |L1.2846|
000ae2  f5a46100          SUB      r1,r4,#0x800
000ae6  3946              SUBS     r1,r1,#0x46
000ae8  d019              BEQ      |L1.2846|
000aea  4284              CMP      r4,r0
000aec  d00b              BEQ      |L1.2822|
000aee  f5b47f58          CMP      r4,#0x360
000af2  d014              BEQ      |L1.2846|
000af4  f5b47f18          CMP      r4,#0x260
000af8  d011              BEQ      |L1.2846|
000afa  f5b47fb0          CMP      r4,#0x160
000afe  d00e              BEQ      |L1.2846|
000b00  f24031c2          MOV      r1,#0x3c2
000b04  e007              B        |L1.2838|
                  |L1.2822|
;;;963      /* The CTS interrupt is not available for UART4 and UART5 */ 
;;;964      if (USART_IT == USART_IT_CTS)
;;;965      {
;;;966        assert_param(IS_USART_123_PERIPH(USARTx));
000b06  42bd              CMP      r5,r7
000b08  d009              BEQ      |L1.2846|
000b0a  4545              CMP      r5,r8
000b0c  d007              BEQ      |L1.2846|
000b0e  454d              CMP      r5,r9
000b10  d005              BEQ      |L1.2846|
000b12  f24031c6          MOV      r1,#0x3c6
                  |L1.2838|
000b16  f2af7004          ADR      r0,|L1.1044|
000b1a  f7fffffe          BL       assert_failed
                  |L1.2846|
;;;967      }   
;;;968      
;;;969      /* Get the USART register index */
;;;970      usartreg = (((uint8_t)USART_IT) >> 0x05);
;;;971      /* Get the interrupt position */
;;;972      itmask = USART_IT & IT_Mask;
000b1e  f004031f          AND      r3,r4,#0x1f
;;;973      itmask = (uint32_t)0x01 << itmask;
000b22  2201              MOVS     r2,#1
000b24  f3c41042          UBFX     r0,r4,#5,#3           ;970
000b28  fa02f103          LSL      r1,r2,r3
;;;974      
;;;975      if (usartreg == 0x01) /* The IT  is in CR1 register */
000b2c  2801              CMP      r0,#1
000b2e  d00f              BEQ      |L1.2896|
;;;976      {
;;;977        itmask &= USARTx->CR1;
;;;978      }
;;;979      else if (usartreg == 0x02) /* The IT  is in CR2 register */
000b30  2802              CMP      r0,#2
000b32  d00f              BEQ      |L1.2900|
;;;980      {
;;;981        itmask &= USARTx->CR2;
;;;982      }
;;;983      else /* The IT  is in CR3 register */
;;;984      {
;;;985        itmask &= USARTx->CR3;
000b34  8aa8              LDRH     r0,[r5,#0x14]
                  |L1.2870|
000b36  4208              TST      r0,r1                 ;981
;;;986      }
;;;987      
;;;988      bitpos = USART_IT >> 0x08;
000b38  ea4f2114          LSR      r1,r4,#8
;;;989      bitpos = (uint32_t)0x01 << bitpos;
000b3c  fa02f201          LSL      r2,r2,r1
;;;990      bitpos &= USARTx->SR;
000b40  8829              LDRH     r1,[r5,#0]
000b42  ea010102          AND      r1,r1,r2
000b46  d001              BEQ      |L1.2892|
;;;991      if ((itmask != (uint16_t)RESET)&&(bitpos != (uint16_t)RESET))
000b48  b101              CBZ      r1,|L1.2892|
;;;992      {
;;;993        bitstatus = SET;
000b4a  2601              MOVS     r6,#1
                  |L1.2892|
;;;994      }
;;;995      else
;;;996      {
;;;997        bitstatus = RESET;
;;;998      }
;;;999      
;;;1000     return bitstatus;  
000b4c  4630              MOV      r0,r6
;;;1001   }
000b4e  e437              B        |L1.960|
                  |L1.2896|
000b50  89a8              LDRH     r0,[r5,#0xc]          ;977
000b52  e7f0              B        |L1.2870|
                  |L1.2900|
000b54  8a28              LDRH     r0,[r5,#0x10]         ;981
000b56  e7ee              B        |L1.2870|
;;;1002   
                          ENDP

                  USART_ClearITPendingBit PROC
;;;1029     */
;;;1030   void USART_ClearITPendingBit(USART_TypeDef* USARTx, uint16_t USART_IT)
000b58  e92d41f0          PUSH     {r4-r8,lr}
;;;1031   {
;;;1032     uint16_t bitpos = 0x00, itmask = 0x00;
;;;1033     /* Check the parameters */
;;;1034     assert_param(IS_USART_ALL_PERIPH(USARTx));
000b5c  4e1e              LDR      r6,|L1.3032|
000b5e  4f1f              LDR      r7,|L1.3036|
000b60  f8df807c          LDR      r8,|L1.3040|
000b64  460d              MOV      r5,r1                 ;1031
000b66  4604              MOV      r4,r0                 ;1031
000b68  42b0              CMP      r0,r6
000b6a  d00f              BEQ      |L1.2956|
000b6c  42bc              CMP      r4,r7
000b6e  d00d              BEQ      |L1.2956|
000b70  4544              CMP      r4,r8
000b72  d00b              BEQ      |L1.2956|
000b74  481b              LDR      r0,|L1.3044|
000b76  4284              CMP      r4,r0
000b78  d008              BEQ      |L1.2956|
000b7a  481b              LDR      r0,|L1.3048|
000b7c  4284              CMP      r4,r0
000b7e  d005              BEQ      |L1.2956|
000b80  f240410a          MOV      r1,#0x40a
000b84  f2af7074          ADR      r0,|L1.1044|
000b88  f7fffffe          BL       assert_failed
                  |L1.2956|
;;;1035     assert_param(IS_USART_CLEAR_IT(USART_IT));
000b8c  f5a561c0          SUB      r1,r5,#0x600
000b90  f640106a          MOV      r0,#0x96a
000b94  3926              SUBS     r1,r1,#0x26
000b96  d018              BEQ      |L1.3018|
000b98  f5a561a0          SUB      r1,r5,#0x500
000b9c  3925              SUBS     r1,r1,#0x25
000b9e  d014              BEQ      |L1.3018|
000ba0  f5a56100          SUB      r1,r5,#0x800
000ba4  3946              SUBS     r1,r1,#0x46
000ba6  d010              BEQ      |L1.3018|
000ba8  4285              CMP      r5,r0
000baa  d002              BEQ      |L1.2994|
000bac  f240410b          MOV      r1,#0x40b
000bb0  e007              B        |L1.3010|
                  |L1.2994|
;;;1036     /* The CTS interrupt is not available for UART4 and UART5 */
;;;1037     if (USART_IT == USART_IT_CTS)
;;;1038     {
;;;1039       assert_param(IS_USART_123_PERIPH(USARTx));
000bb2  42b4              CMP      r4,r6
000bb4  d009              BEQ      |L1.3018|
000bb6  42bc              CMP      r4,r7
000bb8  d007              BEQ      |L1.3018|
000bba  4544              CMP      r4,r8
000bbc  d005              BEQ      |L1.3018|
000bbe  f240410f          MOV      r1,#0x40f
                  |L1.3010|
000bc2  f2af70b0          ADR      r0,|L1.1044|
000bc6  f7fffffe          BL       assert_failed
                  |L1.3018|
;;;1040     }   
;;;1041     
;;;1042     bitpos = USART_IT >> 0x08;
000bca  0a29              LSRS     r1,r5,#8
;;;1043     itmask = ((uint16_t)0x01 << (uint16_t)bitpos);
000bcc  2001              MOVS     r0,#1
000bce  4088              LSLS     r0,r0,r1
;;;1044     USARTx->SR = (uint16_t)~itmask;
000bd0  43c0              MVNS     r0,r0
000bd2  8020              STRH     r0,[r4,#0]
;;;1045   }
000bd4  e753              B        |L1.2686|
;;;1046   /**
                          ENDP

000bd6  0000              DCW      0x0000
                  |L1.3032|
                          DCD      0x40013800
                  |L1.3036|
                          DCD      0x40004400
                  |L1.3040|
                          DCD      0x40004800
                  |L1.3044|
                          DCD      0x40004c00
                  |L1.3048|
                          DCD      0x40005000
