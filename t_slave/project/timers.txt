; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o.\timers.o --asm_dir=.\ --list_dir=.\ --depend=.\timers.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\project -I..\CMSIS\CM3\CoreSupport -I..\hooks -I..\lcd -I..\led -I..\load_cpu -I..\main -I..\printf -I..\rtos -I..\STM32F10x_StdPeriph_Driver\inc -I..\STM32F10x_StdPeriph_Driver\src -I..\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\limit_switch -I..\control_task -I..\mode_task -I..\lcdTask -I..\hit -I..\move_task -I"C:\Program Files\keil\ARM\RV31\INC" -I"C:\Program Files\keil\ARM\PACK\ARM\CMSIS\3.20.4\CMSIS\Include" -I"C:\Program Files\keil\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include" -DSTM32F10X_MD_VL -DUSE_STDPERIPH_DRIVER --omf_browse=.\timers.crf ..\rtos\timers.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  prvInsertTimerInActiveList PROC
;;;539    
;;;540    static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
000000  b570              PUSH     {r4-r6,lr}
;;;541    {
;;;542    BaseType_t xProcessTimerNow = pdFALSE;
000002  2400              MOVS     r4,#0
;;;543    
;;;544    	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
;;;545    	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
000004  6041              STR      r1,[r0,#4]
;;;546    
;;;547    	if( xNextExpiryTime <= xTimeNow )
;;;548    	{
;;;549    		/* Has the expiry time elapsed between the command to start/reset a
;;;550    		timer was issued, and the time the command was processed? */
;;;551    		if( ( xTimeNow - xCommandTime ) >= pxTimer->xTimerPeriodInTicks )
;;;552    		{
;;;553    			/* The time between a command being issued and the command being
;;;554    			processed actually exceeds the timers period.  */
;;;555    			xProcessTimerNow = pdTRUE;
;;;556    		}
;;;557    		else
;;;558    		{
;;;559    			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
000006  4dc3              LDR      r5,|L1.788|
000008  6100              STR      r0,[r0,#0x10]         ;545
00000a  4291              CMP      r1,r2                 ;547
00000c  d806              BHI      |L1.28|
00000e  1ad1              SUBS     r1,r2,r3              ;551
000010  6982              LDR      r2,[r0,#0x18]         ;551
000012  4291              CMP      r1,r2                 ;551
000014  d206              BCS      |L1.36|
000016  1d01              ADDS     r1,r0,#4
000018  68e8              LDR      r0,[r5,#0xc]  ; pxOverflowTimerList
00001a  e007              B        |L1.44|
                  |L1.28|
;;;560    		}
;;;561    	}
;;;562    	else
;;;563    	{
;;;564    		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
00001c  429a              CMP      r2,r3
00001e  d203              BCS      |L1.40|
000020  4299              CMP      r1,r3
000022  d301              BCC      |L1.40|
                  |L1.36|
;;;565    		{
;;;566    			/* If, since the command was issued, the tick count has overflowed
;;;567    			but the expiry time has not, then the timer must have already passed
;;;568    			its expiry time and should be processed immediately. */
;;;569    			xProcessTimerNow = pdTRUE;
000024  2401              MOVS     r4,#1
000026  e003              B        |L1.48|
                  |L1.40|
;;;570    		}
;;;571    		else
;;;572    		{
;;;573    			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
000028  1d01              ADDS     r1,r0,#4
00002a  68a8              LDR      r0,[r5,#8]  ; pxCurrentTimerList
                  |L1.44|
00002c  f7fffffe          BL       vListInsert
                  |L1.48|
;;;574    		}
;;;575    	}
;;;576    
;;;577    	return xProcessTimerNow;
000030  4620              MOV      r0,r4
;;;578    }
000032  bd70              POP      {r4-r6,pc}
;;;579    /*-----------------------------------------------------------*/
                          ENDP

                  xTimerGenericCommand PROC
;;;311    
;;;312    BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
000034  b5fe              PUSH     {r1-r7,lr}
;;;313    {
;;;314    BaseType_t xReturn = pdFAIL;
;;;315    DaemonTaskMessage_t xMessage;
;;;316    
;;;317    	/* Send a message to the timer service task to perform a particular action
;;;318    	on a particular timer definition. */
;;;319    	if( xTimerQueue != NULL )
000036  4cb7              LDR      r4,|L1.788|
000038  461f              MOV      r7,r3                 ;313
00003a  4603              MOV      r3,r0                 ;313
00003c  6826              LDR      r6,[r4,#0]            ;313  ; xTimerQueue
00003e  2000              MOVS     r0,#0                 ;314
000040  9d08              LDR      r5,[sp,#0x20]
000042  2e00              CMP      r6,#0                 ;313
000044  d00e              BEQ      |L1.100|
000046  e88d000e          STM      sp,{r1-r3}            ;313
;;;320    	{
;;;321    		/* Send a command to the timer service task to start the xTimer timer. */
;;;322    		xMessage.xMessageID = xCommandID;
;;;323    		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
;;;324    		xMessage.u.xTimerParameters.pxTimer = ( Timer_t * ) xTimer;
;;;325    
;;;326    		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
00004a  2906              CMP      r1,#6
00004c  da0d              BGE      |L1.106|
;;;327    		{
;;;328    			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
00004e  f7fffffe          BL       xTaskGetSchedulerState
000052  2802              CMP      r0,#2
;;;329    			{
;;;330    				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
;;;331    			}
;;;332    			else
;;;333    			{
;;;334    				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
000054  f04f0300          MOV      r3,#0
000058  d005              BEQ      |L1.102|
00005a  2200              MOVS     r2,#0
                  |L1.92|
00005c  4669              MOV      r1,sp                 ;330
00005e  6820              LDR      r0,[r4,#0]            ;330  ; xTimerQueue
000060  f7fffffe          BL       xQueueGenericSend
                  |L1.100|
;;;335    			}
;;;336    		}
;;;337    		else
;;;338    		{
;;;339    			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
;;;340    		}
;;;341    
;;;342    		traceTIMER_COMMAND_SEND( xTimer, xCommandID, xOptionalValue, xReturn );
;;;343    	}
;;;344    	else
;;;345    	{
;;;346    		mtCOVERAGE_TEST_MARKER();
;;;347    	}
;;;348    
;;;349    	return xReturn;
;;;350    }
000064  bdfe              POP      {r1-r7,pc}
                  |L1.102|
000066  462a              MOV      r2,r5                 ;330
000068  e7f8              B        |L1.92|
                  |L1.106|
00006a  2300              MOVS     r3,#0                 ;339
00006c  463a              MOV      r2,r7                 ;339
00006e  4669              MOV      r1,sp                 ;339
000070  4630              MOV      r0,r6                 ;339
000072  f7fffffe          BL       xQueueGenericSendFromISR
000076  bdfe              POP      {r1-r7,pc}
;;;351    /*-----------------------------------------------------------*/
                          ENDP

                  prvTimerTask PROC
;;;413    
;;;414    static void prvTimerTask( void *pvParameters )
000078  4ca6              LDR      r4,|L1.788|
                  |L1.122|
00007a  68a0              LDR      r0,[r4,#8]  ; pxCurrentTimerList
00007c  6801              LDR      r1,[r0,#0]
00007e  b141              CBZ      r1,|L1.146|
000080  68c0              LDR      r0,[r0,#0xc]
000082  2100              MOVS     r1,#0
000084  f8d00000          LDR.W    r0,[r0,#0]
                  |L1.136|
;;;415    {
;;;416    TickType_t xNextExpireTime;
;;;417    BaseType_t xListWasEmpty;
;;;418    
;;;419    	/* Just to avoid compiler warnings. */
;;;420    	( void ) pvParameters;
;;;421    
;;;422    	for( ;; )
;;;423    	{
;;;424    		/* Query the timers list to see if it contains any timers, and if so,
;;;425    		obtain the time at which the next timer will expire. */
;;;426    		xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
;;;427    
;;;428    		/* If a timer has expired, process it.  Otherwise, block this task
;;;429    		until either a timer does expire, or a command is received. */
;;;430    		prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
000088  f7fffffe          BL       prvProcessTimerOrBlockTask
;;;431    
;;;432    		/* Empty the command queue. */
;;;433    		prvProcessReceivedCommands();
00008c  f7fffffe          BL       prvProcessReceivedCommands
000090  e7f3              B        |L1.122|
                  |L1.146|
000092  2101              MOVS     r1,#1
000094  2000              MOVS     r0,#0
000096  e7f7              B        |L1.136|
;;;434    	}
;;;435    }
;;;436    /*-----------------------------------------------------------*/
                          ENDP

                  prvCheckForValidListAndQueue PROC
;;;765    
;;;766    static void prvCheckForValidListAndQueue( void )
000098  b510              PUSH     {r4,lr}
;;;767    {
;;;768    	/* Check that the list from which active timers are referenced, and the
;;;769    	queue used to communicate with the timer service, have been
;;;770    	initialised. */
;;;771    	taskENTER_CRITICAL();
00009a  f7fffffe          BL       vPortEnterCritical
;;;772    	{
;;;773    		if( xTimerQueue == NULL )
00009e  4c9d              LDR      r4,|L1.788|
0000a0  6820              LDR      r0,[r4,#0]  ; xTimerQueue
0000a2  b988              CBNZ     r0,|L1.200|
;;;774    		{
;;;775    			vListInitialise( &xActiveTimerList1 );
0000a4  489c              LDR      r0,|L1.792|
0000a6  f7fffffe          BL       vListInitialise
;;;776    			vListInitialise( &xActiveTimerList2 );
0000aa  489b              LDR      r0,|L1.792|
0000ac  3014              ADDS     r0,r0,#0x14
0000ae  f7fffffe          BL       vListInitialise
;;;777    			pxCurrentTimerList = &xActiveTimerList1;
0000b2  4899              LDR      r0,|L1.792|
;;;778    			pxOverflowTimerList = &xActiveTimerList2;
0000b4  60a0              STR      r0,[r4,#8]  ; pxCurrentTimerList
0000b6  3014              ADDS     r0,r0,#0x14
;;;779    			xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
0000b8  60e0              STR      r0,[r4,#0xc]  ; pxOverflowTimerList
0000ba  2200              MOVS     r2,#0
0000bc  210c              MOVS     r1,#0xc
0000be  2005              MOVS     r0,#5
0000c0  f7fffffe          BL       xQueueGenericCreate
;;;780    			configASSERT( xTimerQueue );
0000c4  6020              STR      r0,[r4,#0]  ; xTimerQueue
0000c6  b118              CBZ      r0,|L1.208|
                  |L1.200|
;;;781    
;;;782    			#if ( configQUEUE_REGISTRY_SIZE > 0 )
;;;783    			{
;;;784    				if( xTimerQueue != NULL )
;;;785    				{
;;;786    					vQueueAddToRegistry( xTimerQueue, "TmrQ" );
;;;787    				}
;;;788    				else
;;;789    				{
;;;790    					mtCOVERAGE_TEST_MARKER();
;;;791    				}
;;;792    			}
;;;793    			#endif /* configQUEUE_REGISTRY_SIZE */
;;;794    		}
;;;795    		else
;;;796    		{
;;;797    			mtCOVERAGE_TEST_MARKER();
;;;798    		}
;;;799    	}
;;;800    	taskEXIT_CRITICAL();
0000c8  e8bd4010          POP      {r4,lr}
0000cc  f7ffbffe          B.W      vPortExitCritical
                  |L1.208|
0000d0  f7fffffe          BL       ulPortSetInterruptMask
                  |L1.212|
0000d4  e7fe              B        |L1.212|
;;;801    }
;;;802    /*-----------------------------------------------------------*/
                          ENDP

                  xTimerCreateTimerTask PROC
;;;235    
;;;236    BaseType_t xTimerCreateTimerTask( void )
0000d6  b51f              PUSH     {r0-r4,lr}
;;;237    {
;;;238    BaseType_t xReturn = pdFAIL;
;;;239    
;;;240    	/* This function is called when the scheduler is started if
;;;241    	configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
;;;242    	timer service task has been created/initialised.  If timers have already
;;;243    	been created then the initialisation will already have been performed. */
;;;244    	prvCheckForValidListAndQueue();
0000d8  f7fffffe          BL       prvCheckForValidListAndQueue
;;;245    
;;;246    	if( xTimerQueue != NULL )
0000dc  488d              LDR      r0,|L1.788|
0000de  6800              LDR      r0,[r0,#0]  ; xTimerQueue
0000e0  b168              CBZ      r0,|L1.254|
;;;247    	{
;;;248    		#if ( INCLUDE_xTimerGetTimerDaemonTaskHandle == 1 )
;;;249    		{
;;;250    			/* Create the timer task, storing its handle in xTimerTaskHandle so
;;;251    			it can be returned by the xTimerGetTimerDaemonTaskHandle() function. */
;;;252    			xReturn = xTaskCreate( prvTimerTask, "Tmr Svc", ( uint16_t ) configTIMER_TASK_STACK_DEPTH, NULL, ( ( UBaseType_t ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT, &xTimerTaskHandle );
;;;253    		}
;;;254    		#else
;;;255    		{
;;;256    			/* Create the timer task without storing its handle. */
;;;257    			xReturn = xTaskCreate( prvTimerTask, "Tmr Svc", ( uint16_t ) configTIMER_TASK_STACK_DEPTH, NULL, ( ( UBaseType_t ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT, NULL);
0000e2  2000              MOVS     r0,#0
0000e4  2103              MOVS     r1,#3
0000e6  e9cd1000          STRD     r1,r0,[sp,#0]
0000ea  9002              STR      r0,[sp,#8]
0000ec  4603              MOV      r3,r0
0000ee  9003              STR      r0,[sp,#0xc]
0000f0  2246              MOVS     r2,#0x46
0000f2  a18a              ADR      r1,|L1.796|
0000f4  488b              LDR      r0,|L1.804|
0000f6  f7fffffe          BL       xTaskGenericCreate
0000fa  2800              CMP      r0,#0
0000fc  d102              BNE      |L1.260|
                  |L1.254|
;;;258    		}
;;;259    		#endif
;;;260    	}
;;;261    	else
;;;262    	{
;;;263    		mtCOVERAGE_TEST_MARKER();
;;;264    	}
;;;265    
;;;266    	configASSERT( xReturn );
0000fe  f7fffffe          BL       ulPortSetInterruptMask
                  |L1.258|
000102  e7fe              B        |L1.258|
                  |L1.260|
;;;267    	return xReturn;
;;;268    }
000104  b004              ADD      sp,sp,#0x10
000106  bd10              POP      {r4,pc}
;;;269    /*-----------------------------------------------------------*/
                          ENDP

                  xTimerCreate PROC
;;;270    
;;;271    TimerHandle_t xTimerCreate( const char * const pcTimerName, const TickType_t xTimerPeriodInTicks, const UBaseType_t uxAutoReload, void * const pvTimerID, TimerCallbackFunction_t pxCallbackFunction ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
000108  e92d47f0          PUSH     {r4-r10,lr}
;;;272    {
00010c  461e              MOV      r6,r3
00010e  f8dd9020          LDR      r9,[sp,#0x20]
000112  4617              MOV      r7,r2
000114  000d              MOVS     r5,r1
000116  4680              MOV      r8,r0
000118  d012              BEQ      |L1.320|
;;;273    Timer_t *pxNewTimer;
;;;274    
;;;275    	/* Allocate the timer structure. */
;;;276    	if( xTimerPeriodInTicks == ( TickType_t ) 0U )
;;;277    	{
;;;278    		pxNewTimer = NULL;
;;;279    	}
;;;280    	else
;;;281    	{
;;;282    		pxNewTimer = ( Timer_t * ) pvPortMalloc( sizeof( Timer_t ) );
00011a  2028              MOVS     r0,#0x28
00011c  f7fffffe          BL       pvPortMalloc
000120  0004              MOVS     r4,r0
;;;283    		if( pxNewTimer != NULL )
000122  d00a              BEQ      |L1.314|
;;;284    		{
;;;285    			/* Ensure the infrastructure used by the timer service task has been
;;;286    			created/initialised. */
;;;287    			prvCheckForValidListAndQueue();
000124  f7fffffe          BL       prvCheckForValidListAndQueue
;;;288    
;;;289    			/* Initialise the timer structure members using the function parameters. */
;;;290    			pxNewTimer->pcTimerName = pcTimerName;
;;;291    			pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
;;;292    			pxNewTimer->uxAutoReload = uxAutoReload;
;;;293    			pxNewTimer->pvTimerID = pvTimerID;
;;;294    			pxNewTimer->pxCallbackFunction = pxCallbackFunction;
;;;295    			vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
000128  f8c48000          STR      r8,[r4,#0]
00012c  e9c45706          STRD     r5,r7,[r4,#0x18]
000130  e9c46908          STRD     r6,r9,[r4,#0x20]
000134  1d20              ADDS     r0,r4,#4
000136  f7fffffe          BL       vListInitialiseItem
                  |L1.314|
;;;296    
;;;297    			traceTIMER_CREATE( pxNewTimer );
;;;298    		}
;;;299    		else
;;;300    		{
;;;301    			traceTIMER_CREATE_FAILED();
;;;302    		}
;;;303    	}
;;;304    
;;;305    	/* 0 is not a valid value for xTimerPeriodInTicks. */
;;;306    	configASSERT( ( xTimerPeriodInTicks > 0 ) );
;;;307    
;;;308    	return ( TimerHandle_t ) pxNewTimer;
00013a  4620              MOV      r0,r4
;;;309    }
00013c  e8bd87f0          POP      {r4-r10,pc}
                  |L1.320|
000140  f7fffffe          BL       ulPortSetInterruptMask
                  |L1.324|
000144  e7fe              B        |L1.324|
;;;310    /*-----------------------------------------------------------*/
                          ENDP

                  pcTimerGetTimerName PROC
;;;365    
;;;366    const char * pcTimerGetTimerName( TimerHandle_t xTimer )
000146  6800              LDR      r0,[r0,#0]
;;;367    {
;;;368    Timer_t *pxTimer = ( Timer_t * ) xTimer;
;;;369    
;;;370    	return pxTimer->pcTimerName;
;;;371    }
000148  4770              BX       lr
;;;372    /*-----------------------------------------------------------*/
                          ENDP

                  xTimerIsTimerActive PROC
;;;803    
;;;804    BaseType_t xTimerIsTimerActive( TimerHandle_t xTimer )
00014a  b510              PUSH     {r4,lr}
;;;805    {
;;;806    BaseType_t xTimerIsInActiveList;
;;;807    Timer_t *pxTimer = ( Timer_t * ) xTimer;
00014c  4604              MOV      r4,r0
;;;808    
;;;809    	/* Is the timer in the list of active timers? */
;;;810    	taskENTER_CRITICAL();
00014e  f7fffffe          BL       vPortEnterCritical
;;;811    	{
;;;812    		/* Checking to see if it is in the NULL list in effect checks to see if
;;;813    		it is referenced from either the current or the overflow timer lists in
;;;814    		one go, but the logic has to be reversed, hence the '!'. */
;;;815    		xTimerIsInActiveList = ( BaseType_t ) !( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) );
000152  6960              LDR      r0,[r4,#0x14]
000154  b108              CBZ      r0,|L1.346|
000156  2401              MOVS     r4,#1
000158  e000              B        |L1.348|
                  |L1.346|
00015a  2400              MOVS     r4,#0
                  |L1.348|
;;;816    	}
;;;817    	taskEXIT_CRITICAL();
00015c  f7fffffe          BL       vPortExitCritical
;;;818    
;;;819    	return xTimerIsInActiveList;
000160  4620              MOV      r0,r4
;;;820    } /*lint !e818 Can't be pointer to const due to the typedef. */
000162  bd10              POP      {r4,pc}
;;;821    /*-----------------------------------------------------------*/
                          ENDP

                  pvTimerGetTimerID PROC
;;;822    
;;;823    void *pvTimerGetTimerID( const TimerHandle_t xTimer )
000164  6a00              LDR      r0,[r0,#0x20]
;;;824    {
;;;825    Timer_t * const pxTimer = ( Timer_t * ) xTimer;
;;;826    
;;;827    	return pxTimer->pvTimerID;
;;;828    }
000166  4770              BX       lr
;;;829    /*-----------------------------------------------------------*/
                          ENDP

                  prvProcessReceivedCommands PROC
;;;580    
;;;581    static void	prvProcessReceivedCommands( void )
000168  b530              PUSH     {r4,r5,lr}
;;;582    {
00016a  b087              SUB      sp,sp,#0x1c
;;;583    DaemonTaskMessage_t xMessage;
;;;584    Timer_t *pxTimer;
;;;585    BaseType_t xTimerListsWereSwitched, xResult;
;;;586    TickType_t xTimeNow;
;;;587    
;;;588    	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
00016c  4d69              LDR      r5,|L1.788|
00016e  e042              B        |L1.502|
                  |L1.368|
;;;589    	{
;;;590    		#if ( INCLUDE_xTimerPendFunctionCall == 1 )
;;;591    		{
;;;592    			/* Negative commands are pended function calls rather than timer
;;;593    			commands. */
;;;594    			if( xMessage.xMessageID < ( BaseType_t ) 0 )
;;;595    			{
;;;596    				const CallbackParameters_t * const pxCallback = &( xMessage.u.xCallbackParameters );
;;;597    
;;;598    				/* The timer uses the xCallbackParameters member to request a
;;;599    				callback be executed.  Check the callback is not NULL. */
;;;600    				configASSERT( pxCallback );
;;;601    
;;;602    				/* Call the function. */
;;;603    				pxCallback->pxCallbackFunction( pxCallback->pvParameter1, pxCallback->ulParameter2 );
;;;604    			}
;;;605    			else
;;;606    			{
;;;607    				mtCOVERAGE_TEST_MARKER();
;;;608    			}
;;;609    		}
;;;610    		#endif /* INCLUDE_xTimerPendFunctionCall */
;;;611    
;;;612    		/* Commands that are positive are timer commands rather than pended
;;;613    		function calls. */
;;;614    		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
000170  9804              LDR      r0,[sp,#0x10]
000172  2800              CMP      r0,#0
000174  db3f              BLT      |L1.502|
;;;615    		{
;;;616    			/* The messages uses the xTimerParameters member to work on a
;;;617    			software timer. */
;;;618    			pxTimer = xMessage.u.xTimerParameters.pxTimer;
;;;619    
;;;620    			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE )
000176  9c06              LDR      r4,[sp,#0x18]
000178  6960              LDR      r0,[r4,#0x14]
00017a  b110              CBZ      r0,|L1.386|
00017c  1d20              ADDS     r0,r4,#4
;;;621    			{
;;;622    				/* The timer is in a list, remove it. */
;;;623    				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
00017e  f7fffffe          BL       uxListRemove
                  |L1.386|
;;;624    			}
;;;625    			else
;;;626    			{
;;;627    				mtCOVERAGE_TEST_MARKER();
;;;628    			}
;;;629    
;;;630    			traceTIMER_COMMAND_RECEIVED( pxTimer, xMessage.xMessageID, xMessage.u.xTimerParameters.xMessageValue );
;;;631    
;;;632    			/* In this case the xTimerListsWereSwitched parameter is not used, but
;;;633    			it must be present in the function call.  prvSampleTimeNow() must be
;;;634    			called after the message is received from xTimerQueue so there is no
;;;635    			possibility of a higher priority task adding a message to the message
;;;636    			queue with a time that is ahead of the timer daemon task (because it
;;;637    			pre-empted the timer daemon task after the xTimeNow value was set). */
;;;638    			xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
000182  a802              ADD      r0,sp,#8
000184  f7fffffe          BL       prvSampleTimeNow
000188  4602              MOV      r2,r0
;;;639    
;;;640    			switch( xMessage.xMessageID )
00018a  9804              LDR      r0,[sp,#0x10]
00018c  280a              CMP      r0,#0xa
00018e  d232              BCS      |L1.502|
000190  e8dff000          TBB      [pc,r0]
000194  05050531          DCB      0x05,0x05,0x05,0x31
000198  222e0505          DCB      0x22,0x2e,0x05,0x05
00019c  3122              DCB      0x31,0x22
;;;641    			{
;;;642    				case tmrCOMMAND_START :
;;;643    			    case tmrCOMMAND_START_FROM_ISR :
;;;644    			    case tmrCOMMAND_RESET :
;;;645    			    case tmrCOMMAND_RESET_FROM_ISR :
;;;646    				case tmrCOMMAND_START_DONT_TRACE :
;;;647    					/* Start or restart a timer. */
;;;648    					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) == pdTRUE )
00019e  9805              LDR      r0,[sp,#0x14]
0001a0  69a1              LDR      r1,[r4,#0x18]
0001a2  4603              MOV      r3,r0
0001a4  4401              ADD      r1,r1,r0
0001a6  4620              MOV      r0,r4
0001a8  f7fffffe          BL       prvInsertTimerInActiveList
0001ac  2801              CMP      r0,#1
0001ae  d122              BNE      |L1.502|
;;;649    					{
;;;650    						/* The timer expired before it was added to the active
;;;651    						timer list.  Process it now. */
;;;652    						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
0001b0  6a61              LDR      r1,[r4,#0x24]
0001b2  4620              MOV      r0,r4
0001b4  4788              BLX      r1
;;;653    						traceTIMER_EXPIRED( pxTimer );
;;;654    
;;;655    						if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
0001b6  69e0              LDR      r0,[r4,#0x1c]
0001b8  2801              CMP      r0,#1
0001ba  d11c              BNE      |L1.502|
;;;656    						{
;;;657    							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
0001bc  2000              MOVS     r0,#0
0001be  9000              STR      r0,[sp,#0]
0001c0  9805              LDR      r0,[sp,#0x14]
0001c2  69a1              LDR      r1,[r4,#0x18]
0001c4  2300              MOVS     r3,#0
0001c6  1842              ADDS     r2,r0,r1
0001c8  4619              MOV      r1,r3
0001ca  4620              MOV      r0,r4
0001cc  f7fffffe          BL       xTimerGenericCommand
;;;658    							configASSERT( xResult );
0001d0  b988              CBNZ     r0,|L1.502|
0001d2  f7fffffe          BL       ulPortSetInterruptMask
                  |L1.470|
0001d6  e7fe              B        |L1.470|
;;;659    							( void ) xResult;
;;;660    						}
;;;661    						else
;;;662    						{
;;;663    							mtCOVERAGE_TEST_MARKER();
;;;664    						}
;;;665    					}
;;;666    					else
;;;667    					{
;;;668    						mtCOVERAGE_TEST_MARKER();
;;;669    					}
;;;670    					break;
;;;671    
;;;672    				case tmrCOMMAND_STOP :
;;;673    				case tmrCOMMAND_STOP_FROM_ISR :
;;;674    					/* The timer has already been removed from the active list.
;;;675    					There is nothing to do here. */
;;;676    					break;
;;;677    
;;;678    				case tmrCOMMAND_CHANGE_PERIOD :
;;;679    				case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
;;;680    					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
0001d8  9805              LDR      r0,[sp,#0x14]
;;;681    					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
0001da  61a0              STR      r0,[r4,#0x18]
0001dc  b128              CBZ      r0,|L1.490|
;;;682    
;;;683    					/* The new period does not really have a reference, and can be
;;;684    					longer or shorter than the old one.  The command time is
;;;685    					therefore set to the current time, and as the period cannot be
;;;686    					zero the next expiry time can only be in the future, meaning
;;;687    					(unlike for the xTimerStart() case above) there is no fail case
;;;688    					that needs to be handled here. */
;;;689    					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
0001de  1881              ADDS     r1,r0,r2
0001e0  4613              MOV      r3,r2
0001e2  4620              MOV      r0,r4
0001e4  f7fffffe          BL       prvInsertTimerInActiveList
;;;690    					break;
0001e8  e005              B        |L1.502|
                  |L1.490|
0001ea  f7fffffe          BL       ulPortSetInterruptMask
                  |L1.494|
0001ee  e7fe              B        |L1.494|
;;;691    
;;;692    				case tmrCOMMAND_DELETE :
;;;693    					/* The timer has already been removed from the active list,
;;;694    					just free up the memory. */
;;;695    					vPortFree( pxTimer );
0001f0  4620              MOV      r0,r4
0001f2  f7fffffe          BL       vPortFree
                  |L1.502|
0001f6  2300              MOVS     r3,#0                 ;588
0001f8  461a              MOV      r2,r3                 ;588
0001fa  a904              ADD      r1,sp,#0x10           ;588
0001fc  6828              LDR      r0,[r5,#0]            ;588  ; xTimerQueue
0001fe  f7fffffe          BL       xQueueGenericReceive
000202  2800              CMP      r0,#0                 ;588
000204  d1b4              BNE      |L1.368|
;;;696    					break;
;;;697    
;;;698    				default	:
;;;699    					/* Don't expect to get here. */
;;;700    					break;
;;;701    			}
;;;702    		}
;;;703    	}
;;;704    }
000206  b007              ADD      sp,sp,#0x1c
000208  bd30              POP      {r4,r5,pc}
;;;705    /*-----------------------------------------------------------*/
                          ENDP

                  prvProcessTimerOrBlockTask PROC
;;;437    
;;;438    static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, const BaseType_t xListWasEmpty )
00020a  e92d41fc          PUSH     {r2-r8,lr}
;;;439    {
00020e  460f              MOV      r7,r1
000210  4605              MOV      r5,r0
;;;440    TickType_t xTimeNow;
;;;441    BaseType_t xTimerListsWereSwitched;
;;;442    
;;;443    	vTaskSuspendAll();
000212  f7fffffe          BL       vTaskSuspendAll
;;;444    	{
;;;445    		/* Obtain the time now to make an assessment as to whether the timer
;;;446    		has expired or not.  If obtaining the time causes the lists to switch
;;;447    		then don't process this timer as any timers that remained in the list
;;;448    		when the lists were switched will have been processed within the
;;;449    		prvSampleTimeNow() function. */
;;;450    		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
000216  a801              ADD      r0,sp,#4
000218  f7fffffe          BL       prvSampleTimeNow
00021c  4604              MOV      r4,r0
;;;451    		if( xTimerListsWereSwitched == pdFALSE )
00021e  9801              LDR      r0,[sp,#4]
000220  b118              CBZ      r0,|L1.554|
;;;452    		{
;;;453    			/* The tick count has not overflowed, has the timer expired? */
;;;454    			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
;;;455    			{
;;;456    				( void ) xTaskResumeAll();
;;;457    				prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
;;;458    			}
;;;459    			else
;;;460    			{
;;;461    				/* The tick count has not overflowed, and the next expire
;;;462    				time has not been reached yet.  This task should therefore
;;;463    				block to wait for the next expire time or a command to be
;;;464    				received - whichever comes first.  The following line cannot
;;;465    				be reached unless xNextExpireTime > xTimeNow, except in the
;;;466    				case when the current timer list is empty. */
;;;467    				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ) );
;;;468    
;;;469    				if( xTaskResumeAll() == pdFALSE )
;;;470    				{
;;;471    					/* Yield to wait for either a command to arrive, or the block time
;;;472    					to expire.  If a command arrived between the critical section being
;;;473    					exited and this yield then the yield will not cause the task
;;;474    					to block. */
;;;475    					portYIELD_WITHIN_API();
;;;476    				}
;;;477    				else
;;;478    				{
;;;479    					mtCOVERAGE_TEST_MARKER();
;;;480    				}
;;;481    			}
;;;482    		}
;;;483    		else
;;;484    		{
;;;485    			( void ) xTaskResumeAll();
000222  f7fffffe          BL       xTaskResumeAll
                  |L1.550|
;;;486    		}
;;;487    	}
;;;488    }
000226  e8bd81fc          POP      {r2-r8,pc}
                  |L1.554|
00022a  4e3a              LDR      r6,|L1.788|
00022c  bb37              CBNZ     r7,|L1.636|
00022e  42a5              CMP      r5,r4                 ;454
000230  d824              BHI      |L1.636|
000232  f7fffffe          BL       xTaskResumeAll
000236  68b0              LDR      r0,[r6,#8]            ;456  ; pxCurrentTimerList
000238  4627              MOV      r7,r4                 ;457
00023a  68c0              LDR      r0,[r0,#0xc]          ;457
00023c  68c4              LDR      r4,[r0,#0xc]          ;457
00023e  1d20              ADDS     r0,r4,#4              ;457
000240  f7fffffe          BL       uxListRemove
000244  69e0              LDR      r0,[r4,#0x1c]         ;457
000246  2801              CMP      r0,#1                 ;457
000248  d111              BNE      |L1.622|
00024a  69a0              LDR      r0,[r4,#0x18]         ;457
00024c  462b              MOV      r3,r5                 ;457
00024e  1941              ADDS     r1,r0,r5              ;457
000250  463a              MOV      r2,r7                 ;457
000252  4620              MOV      r0,r4                 ;457
000254  f7fffffe          BL       prvInsertTimerInActiveList
000258  2801              CMP      r0,#1                 ;457
00025a  d108              BNE      |L1.622|
00025c  2000              MOVS     r0,#0                 ;457
00025e  4603              MOV      r3,r0                 ;457
000260  4601              MOV      r1,r0                 ;457
000262  9000              STR      r0,[sp,#0]            ;457
000264  462a              MOV      r2,r5                 ;457
000266  4620              MOV      r0,r4                 ;457
000268  f7fffffe          BL       xTimerGenericCommand
00026c  b118              CBZ      r0,|L1.630|
                  |L1.622|
00026e  6a61              LDR      r1,[r4,#0x24]         ;457
000270  4620              MOV      r0,r4                 ;457
000272  4788              BLX      r1                    ;457
000274  e7d7              B        |L1.550|
                  |L1.630|
000276  f7fffffe          BL       ulPortSetInterruptMask
                  |L1.634|
00027a  e7fe              B        |L1.634|
                  |L1.636|
00027c  1b29              SUBS     r1,r5,r4              ;467
00027e  6830              LDR      r0,[r6,#0]            ;467  ; xTimerQueue
000280  f7fffffe          BL       vQueueWaitForMessageRestricted
000284  f7fffffe          BL       xTaskResumeAll
000288  2800              CMP      r0,#0                 ;469
00028a  d1cc              BNE      |L1.550|
00028c  f7fffffe          BL       vPortYield
000290  e7c9              B        |L1.550|
;;;489    /*-----------------------------------------------------------*/
                          ENDP

                  prvSampleTimeNow PROC
;;;516    
;;;517    static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
000292  b570              PUSH     {r4-r6,lr}
;;;518    {
000294  4605              MOV      r5,r0
;;;519    TickType_t xTimeNow;
;;;520    PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */
;;;521    
;;;522    	xTimeNow = xTaskGetTickCount();
000296  f7fffffe          BL       xTaskGetTickCount
;;;523    
;;;524    	if( xTimeNow < xLastTime )
00029a  4e1e              LDR      r6,|L1.788|
00029c  4604              MOV      r4,r0                 ;522
00029e  6870              LDR      r0,[r6,#4]  ; xLastTime
0002a0  4284              CMP      r4,r0
0002a2  d203              BCS      |L1.684|
;;;525    	{
;;;526    		prvSwitchTimerLists();
0002a4  f7fffffe          BL       prvSwitchTimerLists
;;;527    		*pxTimerListsWereSwitched = pdTRUE;
0002a8  2001              MOVS     r0,#1
0002aa  e000              B        |L1.686|
                  |L1.684|
;;;528    	}
;;;529    	else
;;;530    	{
;;;531    		*pxTimerListsWereSwitched = pdFALSE;
0002ac  2000              MOVS     r0,#0
                  |L1.686|
;;;532    	}
;;;533    
;;;534    	xLastTime = xTimeNow;
0002ae  6028              STR      r0,[r5,#0]
;;;535    
;;;536    	return xTimeNow;
0002b0  4620              MOV      r0,r4
0002b2  6074              STR      r4,[r6,#4]  ; xLastTime
;;;537    }
0002b4  bd70              POP      {r4-r6,pc}
;;;538    /*-----------------------------------------------------------*/
                          ENDP

                  prvSwitchTimerLists PROC
;;;706    
;;;707    static void prvSwitchTimerLists( void )
0002b6  b5f8              PUSH     {r3-r7,lr}
;;;708    {
;;;709    TickType_t xNextExpireTime, xReloadTime;
;;;710    List_t *pxTemp;
;;;711    Timer_t *pxTimer;
;;;712    BaseType_t xResult;
;;;713    
;;;714    	/* The tick count has overflowed.  The timer lists must be switched.
;;;715    	If there are any timers still referenced from the current timer list
;;;716    	then they must have expired and should be processed before the lists
;;;717    	are switched. */
;;;718    	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
;;;719    	{
;;;720    		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
0002b8  4d16              LDR      r5,|L1.788|
0002ba  e01f              B        |L1.764|
                  |L1.700|
0002bc  68c0              LDR      r0,[r0,#0xc]
;;;721    
;;;722    		/* Remove the timer from the list. */
;;;723    		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
;;;724    		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
0002be  68c4              LDR      r4,[r0,#0xc]
0002c0  6806              LDR      r6,[r0,#0]
0002c2  1d20              ADDS     r0,r4,#4
0002c4  f7fffffe          BL       uxListRemove
;;;725    		traceTIMER_EXPIRED( pxTimer );
;;;726    
;;;727    		/* Execute its callback, then send a command to restart the timer if
;;;728    		it is an auto-reload timer.  It cannot be restarted here as the lists
;;;729    		have not yet been switched. */
;;;730    		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
0002c8  6a61              LDR      r1,[r4,#0x24]
0002ca  4620              MOV      r0,r4
0002cc  4788              BLX      r1
;;;731    
;;;732    		if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
0002ce  69e0              LDR      r0,[r4,#0x1c]
0002d0  2801              CMP      r0,#1
0002d2  d113              BNE      |L1.764|
;;;733    		{
;;;734    			/* Calculate the reload value, and if the reload value results in
;;;735    			the timer going into the same timer list then it has already expired
;;;736    			and the timer should be re-inserted into the current list so it is
;;;737    			processed again within this loop.  Otherwise a command should be sent
;;;738    			to restart the timer to ensure it is only inserted into a list after
;;;739    			the lists have been swapped. */
;;;740    			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
0002d4  69a0              LDR      r0,[r4,#0x18]
0002d6  4430              ADD      r0,r0,r6
;;;741    			if( xReloadTime > xNextExpireTime )
0002d8  42b0              CMP      r0,r6
0002da  d906              BLS      |L1.746|
;;;742    			{
;;;743    				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
;;;744    				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
0002dc  6124              STR      r4,[r4,#0x10]
0002de  6060              STR      r0,[r4,#4]
;;;745    				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
0002e0  1d21              ADDS     r1,r4,#4
0002e2  68a8              LDR      r0,[r5,#8]  ; pxCurrentTimerList
0002e4  f7fffffe          BL       vListInsert
0002e8  e008              B        |L1.764|
                  |L1.746|
;;;746    			}
;;;747    			else
;;;748    			{
;;;749    				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
0002ea  2000              MOVS     r0,#0
0002ec  4603              MOV      r3,r0
0002ee  4601              MOV      r1,r0
0002f0  9000              STR      r0,[sp,#0]
0002f2  4632              MOV      r2,r6
0002f4  4620              MOV      r0,r4
0002f6  f7fffffe          BL       xTimerGenericCommand
;;;750    				configASSERT( xResult );
0002fa  b138              CBZ      r0,|L1.780|
                  |L1.764|
0002fc  68a8              LDR      r0,[r5,#8]            ;718  ; pxCurrentTimerList
0002fe  6801              LDR      r1,[r0,#0]            ;718
000300  2900              CMP      r1,#0                 ;718
000302  d1db              BNE      |L1.700|
;;;751    				( void ) xResult;
;;;752    			}
;;;753    		}
;;;754    		else
;;;755    		{
;;;756    			mtCOVERAGE_TEST_MARKER();
;;;757    		}
;;;758    	}
;;;759    
;;;760    	pxTemp = pxCurrentTimerList;
;;;761    	pxCurrentTimerList = pxOverflowTimerList;
000304  68e9              LDR      r1,[r5,#0xc]  ; pxOverflowTimerList
000306  e9c51002          STRD     r1,r0,[r5,#8]
;;;762    	pxOverflowTimerList = pxTemp;
;;;763    }
00030a  bdf8              POP      {r3-r7,pc}
                  |L1.780|
00030c  f7fffffe          BL       ulPortSetInterruptMask
                  |L1.784|
000310  e7fe              B        |L1.784|
;;;764    /*-----------------------------------------------------------*/
                          ENDP

000312  0000              DCW      0x0000
                  |L1.788|
                          DCD      ||.data||
                  |L1.792|
                          DCD      ||.bss||
                  |L1.796|
00031c  546d7220          DCB      "Tmr Svc",0
000320  53766300
                  |L1.804|
                          DCD      prvTimerTask

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  xActiveTimerList1
                          %        20
                  xActiveTimerList2
                          %        20

                          AREA ||.data||, DATA, ALIGN=2

                  xTimerQueue
                          DCD      0x00000000
                  xLastTime
                          DCD      0x00000000
                  pxCurrentTimerList
                          DCD      0x00000000
                  pxOverflowTimerList
                          DCD      0x00000000
