; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o.\stm32f10x_rcc.o --asm_dir=.\ --list_dir=.\ --depend=.\stm32f10x_rcc.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\project -I..\CMSIS\CM3\CoreSupport -I..\hooks -I..\lcd -I..\led -I..\load_cpu -I..\main -I..\printf -I..\rtos -I..\STM32F10x_StdPeriph_Driver\inc -I..\STM32F10x_StdPeriph_Driver\src -I..\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\limit_switch -I..\control_task -I..\mode_task -I..\lcdTask -I..\hit -I..\move_task -I"C:\Program Files\keil\ARM\RV31\INC" -I"C:\Program Files\keil\ARM\PACK\ARM\CMSIS\3.20.4\CMSIS\Include" -I"C:\Program Files\keil\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include" -DSTM32F10X_MD_VL -DUSE_STDPERIPH_DRIVER --omf_browse=.\stm32f10x_rcc.crf ..\STM32F10x_StdPeriph_Driver\src\stm32f10x_rcc.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  RCC_DeInit PROC
;;;216      */
;;;217    void RCC_DeInit(void)
000000  48fb              LDR      r0,|L1.1008|
;;;218    {
;;;219      /* Set HSION bit */
;;;220      RCC->CR |= (uint32_t)0x00000001;
000002  6801              LDR      r1,[r0,#0]
000004  f0410101          ORR      r1,r1,#1
000008  6001              STR      r1,[r0,#0]
;;;221    
;;;222      /* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */
;;;223    #ifndef STM32F10X_CL
;;;224      RCC->CFGR &= (uint32_t)0xF8FF0000;
00000a  6841              LDR      r1,[r0,#4]
00000c  4af9              LDR      r2,|L1.1012|
00000e  4011              ANDS     r1,r1,r2
000010  6041              STR      r1,[r0,#4]
;;;225    #else
;;;226      RCC->CFGR &= (uint32_t)0xF0FF0000;
;;;227    #endif /* STM32F10X_CL */   
;;;228      
;;;229      /* Reset HSEON, CSSON and PLLON bits */
;;;230      RCC->CR &= (uint32_t)0xFEF6FFFF;
000012  6801              LDR      r1,[r0,#0]
000014  4af8              LDR      r2,|L1.1016|
000016  4011              ANDS     r1,r1,r2
000018  6001              STR      r1,[r0,#0]
;;;231    
;;;232      /* Reset HSEBYP bit */
;;;233      RCC->CR &= (uint32_t)0xFFFBFFFF;
00001a  6801              LDR      r1,[r0,#0]
00001c  f4212180          BIC      r1,r1,#0x40000
000020  6001              STR      r1,[r0,#0]
;;;234    
;;;235      /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */
;;;236      RCC->CFGR &= (uint32_t)0xFF80FFFF;
000022  6841              LDR      r1,[r0,#4]
000024  f42101fe          BIC      r1,r1,#0x7f0000
000028  6041              STR      r1,[r0,#4]
;;;237    
;;;238    #ifdef STM32F10X_CL
;;;239      /* Reset PLL2ON and PLL3ON bits */
;;;240      RCC->CR &= (uint32_t)0xEBFFFFFF;
;;;241    
;;;242      /* Disable all interrupts and clear pending bits  */
;;;243      RCC->CIR = 0x00FF0000;
;;;244    
;;;245      /* Reset CFGR2 register */
;;;246      RCC->CFGR2 = 0x00000000;
;;;247    #elif defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)
;;;248      /* Disable all interrupts and clear pending bits  */
;;;249      RCC->CIR = 0x009F0000;
00002a  f44f011f          MOV      r1,#0x9f0000
00002e  6081              STR      r1,[r0,#8]
;;;250    
;;;251      /* Reset CFGR2 register */
;;;252      RCC->CFGR2 = 0x00000000;      
000030  2100              MOVS     r1,#0
000032  62c1              STR      r1,[r0,#0x2c]
;;;253    #else
;;;254      /* Disable all interrupts and clear pending bits  */
;;;255      RCC->CIR = 0x009F0000;
;;;256    #endif /* STM32F10X_CL */
;;;257    
;;;258    }
000034  4770              BX       lr
;;;259    
                          ENDP

                  RCC_HSEConfig PROC
;;;269      */
;;;270    void RCC_HSEConfig(uint32_t RCC_HSE)
000036  b570              PUSH     {r4-r6,lr}
;;;271    {
000038  0004              MOVS     r4,r0
;;;272      /* Check the parameters */
;;;273      assert_param(IS_RCC_HSE(RCC_HSE));
00003a  f44f3580          MOV      r5,#0x10000
00003e  f44f2680          MOV      r6,#0x40000
000042  d008              BEQ      |L1.86|
000044  42ac              CMP      r4,r5
000046  d006              BEQ      |L1.86|
000048  42b4              CMP      r4,r6
00004a  d004              BEQ      |L1.86|
00004c  f2401111          MOV      r1,#0x111
000050  a0ea              ADR      r0,|L1.1020|
000052  f7fffffe          BL       assert_failed
                  |L1.86|
;;;274      /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
;;;275      /* Reset HSEON bit */
;;;276      RCC->CR &= CR_HSEON_Reset;
000056  49e6              LDR      r1,|L1.1008|
000058  6808              LDR      r0,[r1,#0]
00005a  f4203080          BIC      r0,r0,#0x10000
00005e  6008              STR      r0,[r1,#0]
;;;277      /* Reset HSEBYP bit */
;;;278      RCC->CR &= CR_HSEBYP_Reset;
000060  6808              LDR      r0,[r1,#0]
000062  f4202080          BIC      r0,r0,#0x40000
000066  6008              STR      r0,[r1,#0]
;;;279      /* Configure HSE (RCC_HSE_OFF is already covered by the code section above) */
;;;280      switch(RCC_HSE)
000068  42ac              CMP      r4,r5
00006a  d006              BEQ      |L1.122|
00006c  42b4              CMP      r4,r6
00006e  d103              BNE      |L1.120|
;;;281      {
;;;282        case RCC_HSE_ON:
;;;283          /* Set HSEON bit */
;;;284          RCC->CR |= CR_HSEON_Set;
;;;285          break;
;;;286          
;;;287        case RCC_HSE_Bypass:
;;;288          /* Set HSEBYP and HSEON bits */
;;;289          RCC->CR |= CR_HSEBYP_Set | CR_HSEON_Set;
000070  6808              LDR      r0,[r1,#0]
000072  f44020a0          ORR      r0,r0,#0x50000
                  |L1.118|
000076  6008              STR      r0,[r1,#0]
                  |L1.120|
;;;290          break;
;;;291          
;;;292        default:
;;;293          break;
;;;294      }
;;;295    }
000078  bd70              POP      {r4-r6,pc}
                  |L1.122|
00007a  6808              LDR      r0,[r1,#0]            ;284
00007c  f4403080          ORR      r0,r0,#0x10000        ;284
000080  e7f9              B        |L1.118|
;;;296    
                          ENDP

                  RCC_GetFlagStatus PROC
;;;1325     */
;;;1326   FlagStatus RCC_GetFlagStatus(uint8_t RCC_FLAG)
000082  b570              PUSH     {r4-r6,lr}
;;;1327   {
;;;1328     uint32_t tmp = 0;
;;;1329     uint32_t statusreg = 0;
;;;1330     FlagStatus bitstatus = RESET;
000084  2500              MOVS     r5,#0
000086  4604              MOV      r4,r0                 ;1327
;;;1331     /* Check the parameters */
;;;1332     assert_param(IS_RCC_FLAG(RCC_FLAG));
000088  2821              CMP      r0,#0x21
00008a  d018              BEQ      |L1.190|
00008c  2c31              CMP      r4,#0x31
00008e  d016              BEQ      |L1.190|
000090  2c39              CMP      r4,#0x39
000092  d014              BEQ      |L1.190|
000094  2c41              CMP      r4,#0x41
000096  d012              BEQ      |L1.190|
000098  2c61              CMP      r4,#0x61
00009a  d010              BEQ      |L1.190|
00009c  2c7a              CMP      r4,#0x7a
00009e  d00e              BEQ      |L1.190|
0000a0  2c7b              CMP      r4,#0x7b
0000a2  d00c              BEQ      |L1.190|
0000a4  2c7c              CMP      r4,#0x7c
0000a6  d00a              BEQ      |L1.190|
0000a8  2c7d              CMP      r4,#0x7d
0000aa  d008              BEQ      |L1.190|
0000ac  2c7e              CMP      r4,#0x7e
0000ae  d006              BEQ      |L1.190|
0000b0  2c7f              CMP      r4,#0x7f
0000b2  d004              BEQ      |L1.190|
0000b4  f2405134          MOV      r1,#0x534
0000b8  a0d0              ADR      r0,|L1.1020|
0000ba  f7fffffe          BL       assert_failed
                  |L1.190|
;;;1333   
;;;1334     /* Get the RCC register index */
;;;1335     tmp = RCC_FLAG >> 5;
0000be  0961              LSRS     r1,r4,#5
;;;1336     if (tmp == 1)               /* The flag to check is in CR register */
;;;1337     {
;;;1338       statusreg = RCC->CR;
0000c0  48cb              LDR      r0,|L1.1008|
0000c2  2901              CMP      r1,#1                 ;1336
0000c4  d00b              BEQ      |L1.222|
;;;1339     }
;;;1340     else if (tmp == 2)          /* The flag to check is in BDCR register */
0000c6  2902              CMP      r1,#2
0000c8  d00b              BEQ      |L1.226|
;;;1341     {
;;;1342       statusreg = RCC->BDCR;
;;;1343     }
;;;1344     else                       /* The flag to check is in CSR register */
;;;1345     {
;;;1346       statusreg = RCC->CSR;
0000ca  6a40              LDR      r0,[r0,#0x24]
                  |L1.204|
;;;1347     }
;;;1348   
;;;1349     /* Get the flag position */
;;;1350     tmp = RCC_FLAG & FLAG_Mask;
0000cc  f004011f          AND      r1,r4,#0x1f
;;;1351     if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
0000d0  2201              MOVS     r2,#1
0000d2  408a              LSLS     r2,r2,r1
0000d4  4202              TST      r2,r0
0000d6  d000              BEQ      |L1.218|
;;;1352     {
;;;1353       bitstatus = SET;
0000d8  2501              MOVS     r5,#1
                  |L1.218|
;;;1354     }
;;;1355     else
;;;1356     {
;;;1357       bitstatus = RESET;
;;;1358     }
;;;1359   
;;;1360     /* Return the flag status */
;;;1361     return bitstatus;
0000da  4628              MOV      r0,r5
;;;1362   }
0000dc  bd70              POP      {r4-r6,pc}
                  |L1.222|
0000de  6800              LDR      r0,[r0,#0]            ;1338
0000e0  e7f4              B        |L1.204|
                  |L1.226|
0000e2  6a00              LDR      r0,[r0,#0x20]         ;1342
0000e4  e7f2              B        |L1.204|
;;;1363   
                          ENDP

                  RCC_WaitForHSEStartUp PROC
;;;303      */
;;;304    ErrorStatus RCC_WaitForHSEStartUp(void)
0000e6  b538              PUSH     {r3-r5,lr}
;;;305    {
;;;306      __IO uint32_t StartUpCounter = 0;
0000e8  2000              MOVS     r0,#0
;;;307      ErrorStatus status = ERROR;
;;;308      FlagStatus HSEStatus = RESET;
;;;309      
;;;310      /* Wait till HSE is ready and if Time out is reached exit */
;;;311      do
;;;312      {
;;;313        HSEStatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
;;;314        StartUpCounter++;  
;;;315      } while((StartUpCounter != HSE_STARTUP_TIMEOUT) && (HSEStatus == RESET));
0000ea  f44f64a0          MOV      r4,#0x500
0000ee  9000              STR      r0,[sp,#0]
                  |L1.240|
0000f0  2031              MOVS     r0,#0x31              ;313
0000f2  f7fffffe          BL       RCC_GetFlagStatus
0000f6  9900              LDR      r1,[sp,#0]            ;314
0000f8  1c49              ADDS     r1,r1,#1              ;314
0000fa  9100              STR      r1,[sp,#0]
0000fc  42a1              CMP      r1,r4
0000fe  d001              BEQ      |L1.260|
000100  2800              CMP      r0,#0
000102  d0f5              BEQ      |L1.240|
                  |L1.260|
;;;316      
;;;317      if (RCC_GetFlagStatus(RCC_FLAG_HSERDY) != RESET)
000104  2031              MOVS     r0,#0x31
000106  f7fffffe          BL       RCC_GetFlagStatus
00010a  2800              CMP      r0,#0
00010c  d000              BEQ      |L1.272|
;;;318      {
;;;319        status = SUCCESS;
00010e  2001              MOVS     r0,#1
                  |L1.272|
;;;320      }
;;;321      else
;;;322      {
;;;323        status = ERROR;
;;;324      }  
;;;325      return (status);
;;;326    }
000110  bd38              POP      {r3-r5,pc}
;;;327    
                          ENDP

                  RCC_AdjustHSICalibrationValue PROC
;;;333      */
;;;334    void RCC_AdjustHSICalibrationValue(uint8_t HSICalibrationValue)
000112  b510              PUSH     {r4,lr}
;;;335    {
000114  4604              MOV      r4,r0
;;;336      uint32_t tmpreg = 0;
;;;337      /* Check the parameters */
;;;338      assert_param(IS_RCC_CALIBRATION_VALUE(HSICalibrationValue));
000116  281f              CMP      r0,#0x1f
000118  d904              BLS      |L1.292|
00011a  f44f71a9          MOV      r1,#0x152
00011e  a0b7              ADR      r0,|L1.1020|
000120  f7fffffe          BL       assert_failed
                  |L1.292|
;;;339      tmpreg = RCC->CR;
000124  48b2              LDR      r0,|L1.1008|
000126  6801              LDR      r1,[r0,#0]
;;;340      /* Clear HSITRIM[4:0] bits */
;;;341      tmpreg &= CR_HSITRIM_Mask;
000128  f02101f8          BIC      r1,r1,#0xf8
;;;342      /* Set the HSITRIM[4:0] bits according to HSICalibrationValue value */
;;;343      tmpreg |= (uint32_t)HSICalibrationValue << 3;
00012c  ea4101c4          ORR      r1,r1,r4,LSL #3
;;;344      /* Store the new value */
;;;345      RCC->CR = tmpreg;
000130  6001              STR      r1,[r0,#0]
;;;346    }
000132  bd10              POP      {r4,pc}
;;;347    
                          ENDP

                  RCC_HSICmd PROC
;;;353      */
;;;354    void RCC_HSICmd(FunctionalState NewState)
000134  b510              PUSH     {r4,lr}
;;;355    {
000136  0004              MOVS     r4,r0
000138  d006              BEQ      |L1.328|
;;;356      /* Check the parameters */
;;;357      assert_param(IS_FUNCTIONAL_STATE(NewState));
00013a  2c01              CMP      r4,#1
00013c  d004              BEQ      |L1.328|
00013e  f2401165          MOV      r1,#0x165
000142  a0ae              ADR      r0,|L1.1020|
000144  f7fffffe          BL       assert_failed
                  |L1.328|
;;;358      *(__IO uint32_t *) CR_HSION_BB = (uint32_t)NewState;
000148  48b9              LDR      r0,|L1.1072|
00014a  6004              STR      r4,[r0,#0]
;;;359    }
00014c  bd10              POP      {r4,pc}
;;;360    
                          ENDP

                  RCC_PLLConfig PROC
;;;377      */
;;;378    void RCC_PLLConfig(uint32_t RCC_PLLSource, uint32_t RCC_PLLMul)
00014e  b570              PUSH     {r4-r6,lr}
;;;379    {
000150  460c              MOV      r4,r1
000152  0005              MOVS     r5,r0
000154  d007              BEQ      |L1.358|
;;;380      uint32_t tmpreg = 0;
;;;381    
;;;382      /* Check the parameters */
;;;383      assert_param(IS_RCC_PLL_SOURCE(RCC_PLLSource));
000156  f5b53f80          CMP      r5,#0x10000
00015a  d004              BEQ      |L1.358|
00015c  f240117f          MOV      r1,#0x17f
000160  a0a6              ADR      r0,|L1.1020|
000162  f7fffffe          BL       assert_failed
                  |L1.358|
;;;384      assert_param(IS_RCC_PLL_MUL(RCC_PLLMul));
000166  b374              CBZ      r4,|L1.454|
000168  f5b42f80          CMP      r4,#0x40000
00016c  d02b              BEQ      |L1.454|
00016e  f5b42f00          CMP      r4,#0x80000
000172  d028              BEQ      |L1.454|
000174  f5b42f40          CMP      r4,#0xc0000
000178  d025              BEQ      |L1.454|
00017a  f5b41f80          CMP      r4,#0x100000
00017e  d022              BEQ      |L1.454|
000180  f5b41fa0          CMP      r4,#0x140000
000184  d01f              BEQ      |L1.454|
000186  f5b41fc0          CMP      r4,#0x180000
00018a  d01c              BEQ      |L1.454|
00018c  f5b41fe0          CMP      r4,#0x1c0000
000190  d019              BEQ      |L1.454|
000192  f5b41f00          CMP      r4,#0x200000
000196  d016              BEQ      |L1.454|
000198  f5b41f10          CMP      r4,#0x240000
00019c  d013              BEQ      |L1.454|
00019e  f5b41f20          CMP      r4,#0x280000
0001a2  d010              BEQ      |L1.454|
0001a4  f5b41f30          CMP      r4,#0x2c0000
0001a8  d00d              BEQ      |L1.454|
0001aa  f5b41f40          CMP      r4,#0x300000
0001ae  d00a              BEQ      |L1.454|
0001b0  f5b41f50          CMP      r4,#0x340000
0001b4  d007              BEQ      |L1.454|
0001b6  f5b41f60          CMP      r4,#0x380000
0001ba  d004              BEQ      |L1.454|
0001bc  f44f71c0          MOV      r1,#0x180
0001c0  a08e              ADR      r0,|L1.1020|
0001c2  f7fffffe          BL       assert_failed
                  |L1.454|
;;;385    
;;;386      tmpreg = RCC->CFGR;
0001c6  488a              LDR      r0,|L1.1008|
0001c8  6841              LDR      r1,[r0,#4]
;;;387      /* Clear PLLSRC, PLLXTPRE and PLLMUL[3:0] bits */
;;;388      tmpreg &= CFGR_PLL_Mask;
;;;389      /* Set the PLL configuration bits */
;;;390      tmpreg |= RCC_PLLSource | RCC_PLLMul;
0001ca  4325              ORRS     r5,r5,r4
0001cc  f4211174          BIC      r1,r1,#0x3d0000       ;388
0001d0  430d              ORRS     r5,r5,r1
;;;391      /* Store the new value */
;;;392      RCC->CFGR = tmpreg;
0001d2  6045              STR      r5,[r0,#4]
;;;393    }
0001d4  bd70              POP      {r4-r6,pc}
;;;394    
                          ENDP

                  RCC_PLLCmd PROC
;;;400      */
;;;401    void RCC_PLLCmd(FunctionalState NewState)
0001d6  b510              PUSH     {r4,lr}
;;;402    {
0001d8  0004              MOVS     r4,r0
0001da  d006              BEQ      |L1.490|
;;;403      /* Check the parameters */
;;;404      assert_param(IS_FUNCTIONAL_STATE(NewState));
0001dc  2c01              CMP      r4,#1
0001de  d004              BEQ      |L1.490|
0001e0  f44f71ca          MOV      r1,#0x194
0001e4  a085              ADR      r0,|L1.1020|
0001e6  f7fffffe          BL       assert_failed
                  |L1.490|
;;;405    
;;;406      *(__IO uint32_t *) CR_PLLON_BB = (uint32_t)NewState;
0001ea  4891              LDR      r0,|L1.1072|
0001ec  6604              STR      r4,[r0,#0x60]
;;;407    }
0001ee  bd10              POP      {r4,pc}
;;;408    
                          ENDP

                  RCC_PREDIV1Config PROC
;;;425      */
;;;426    void RCC_PREDIV1Config(uint32_t RCC_PREDIV1_Source, uint32_t RCC_PREDIV1_Div)
0001f0  b570              PUSH     {r4-r6,lr}
;;;427    {
0001f2  460c              MOV      r4,r1
0001f4  0005              MOVS     r5,r0
0001f6  d004              BEQ      |L1.514|
;;;428      uint32_t tmpreg = 0;
;;;429      
;;;430      /* Check the parameters */
;;;431      assert_param(IS_RCC_PREDIV1_SOURCE(RCC_PREDIV1_Source));
0001f8  f24011af          MOV      r1,#0x1af
0001fc  a07f              ADR      r0,|L1.1020|
0001fe  f7fffffe          BL       assert_failed
                  |L1.514|
;;;432      assert_param(IS_RCC_PREDIV1(RCC_PREDIV1_Div));
000202  b314              CBZ      r4,|L1.586|
000204  2c01              CMP      r4,#1
000206  d020              BEQ      |L1.586|
000208  2c02              CMP      r4,#2
00020a  d01e              BEQ      |L1.586|
00020c  2c03              CMP      r4,#3
00020e  d01c              BEQ      |L1.586|
000210  2c04              CMP      r4,#4
000212  d01a              BEQ      |L1.586|
000214  2c05              CMP      r4,#5
000216  d018              BEQ      |L1.586|
000218  2c06              CMP      r4,#6
00021a  d016              BEQ      |L1.586|
00021c  2c07              CMP      r4,#7
00021e  d014              BEQ      |L1.586|
000220  2c08              CMP      r4,#8
000222  d012              BEQ      |L1.586|
000224  2c09              CMP      r4,#9
000226  d010              BEQ      |L1.586|
000228  2c0a              CMP      r4,#0xa
00022a  d00e              BEQ      |L1.586|
00022c  2c0b              CMP      r4,#0xb
00022e  d00c              BEQ      |L1.586|
000230  2c0c              CMP      r4,#0xc
000232  d00a              BEQ      |L1.586|
000234  2c0d              CMP      r4,#0xd
000236  d008              BEQ      |L1.586|
000238  2c0e              CMP      r4,#0xe
00023a  d006              BEQ      |L1.586|
00023c  2c0f              CMP      r4,#0xf
00023e  d004              BEQ      |L1.586|
000240  f44f71d8          MOV      r1,#0x1b0
000244  a06d              ADR      r0,|L1.1020|
000246  f7fffffe          BL       assert_failed
                  |L1.586|
;;;433    
;;;434      tmpreg = RCC->CFGR2;
00024a  4969              LDR      r1,|L1.1008|
00024c  6ac8              LDR      r0,[r1,#0x2c]
;;;435      /* Clear PREDIV1[3:0] and PREDIV1SRC bits */
;;;436      tmpreg &= ~(CFGR2_PREDIV1 | CFGR2_PREDIV1SRC);
00024e  4a79              LDR      r2,|L1.1076|
;;;437      /* Set the PREDIV1 clock source and division factor */
;;;438      tmpreg |= RCC_PREDIV1_Source | RCC_PREDIV1_Div ;
000250  4325              ORRS     r5,r5,r4
000252  4010              ANDS     r0,r0,r2              ;436
000254  4305              ORRS     r5,r5,r0
;;;439      /* Store the new value */
;;;440      RCC->CFGR2 = tmpreg;
000256  62cd              STR      r5,[r1,#0x2c]
;;;441    }
000258  bd70              POP      {r4-r6,pc}
;;;442    #endif
                          ENDP

                  RCC_SYSCLKConfig PROC
;;;563      */
;;;564    void RCC_SYSCLKConfig(uint32_t RCC_SYSCLKSource)
00025a  b510              PUSH     {r4,lr}
;;;565    {
00025c  0004              MOVS     r4,r0
00025e  d008              BEQ      |L1.626|
;;;566      uint32_t tmpreg = 0;
;;;567      /* Check the parameters */
;;;568      assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));
000260  2c01              CMP      r4,#1
000262  d006              BEQ      |L1.626|
000264  2c02              CMP      r4,#2
000266  d004              BEQ      |L1.626|
000268  f44f710e          MOV      r1,#0x238
00026c  a063              ADR      r0,|L1.1020|
00026e  f7fffffe          BL       assert_failed
                  |L1.626|
;;;569      tmpreg = RCC->CFGR;
000272  495f              LDR      r1,|L1.1008|
000274  6848              LDR      r0,[r1,#4]
;;;570      /* Clear SW[1:0] bits */
;;;571      tmpreg &= CFGR_SW_Mask;
000276  f0200003          BIC      r0,r0,#3
;;;572      /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
;;;573      tmpreg |= RCC_SYSCLKSource;
00027a  4320              ORRS     r0,r0,r4
;;;574      /* Store the new value */
;;;575      RCC->CFGR = tmpreg;
00027c  6048              STR      r0,[r1,#4]
;;;576    }
00027e  bd10              POP      {r4,pc}
;;;577    
                          ENDP

                  RCC_GetSYSCLKSource PROC
;;;586      */
;;;587    uint8_t RCC_GetSYSCLKSource(void)
000280  485b              LDR      r0,|L1.1008|
;;;588    {
;;;589      return ((uint8_t)(RCC->CFGR & CFGR_SWS_Mask));
000282  6840              LDR      r0,[r0,#4]
000284  f000000c          AND      r0,r0,#0xc
;;;590    }
000288  4770              BX       lr
;;;591    
                          ENDP

                  RCC_HCLKConfig PROC
;;;607      */
;;;608    void RCC_HCLKConfig(uint32_t RCC_SYSCLK)
00028a  b510              PUSH     {r4,lr}
;;;609    {
00028c  0004              MOVS     r4,r0
00028e  d014              BEQ      |L1.698|
;;;610      uint32_t tmpreg = 0;
;;;611      /* Check the parameters */
;;;612      assert_param(IS_RCC_HCLK(RCC_SYSCLK));
000290  2c80              CMP      r4,#0x80
000292  d012              BEQ      |L1.698|
000294  2c90              CMP      r4,#0x90
000296  d010              BEQ      |L1.698|
000298  2ca0              CMP      r4,#0xa0
00029a  d00e              BEQ      |L1.698|
00029c  2cb0              CMP      r4,#0xb0
00029e  d00c              BEQ      |L1.698|
0002a0  2cc0              CMP      r4,#0xc0
0002a2  d00a              BEQ      |L1.698|
0002a4  2cd0              CMP      r4,#0xd0
0002a6  d008              BEQ      |L1.698|
0002a8  2ce0              CMP      r4,#0xe0
0002aa  d006              BEQ      |L1.698|
0002ac  2cf0              CMP      r4,#0xf0
0002ae  d004              BEQ      |L1.698|
0002b0  f44f7119          MOV      r1,#0x264
0002b4  a051              ADR      r0,|L1.1020|
0002b6  f7fffffe          BL       assert_failed
                  |L1.698|
;;;613      tmpreg = RCC->CFGR;
0002ba  494d              LDR      r1,|L1.1008|
0002bc  6848              LDR      r0,[r1,#4]
;;;614      /* Clear HPRE[3:0] bits */
;;;615      tmpreg &= CFGR_HPRE_Reset_Mask;
0002be  f02000f0          BIC      r0,r0,#0xf0
;;;616      /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
;;;617      tmpreg |= RCC_SYSCLK;
0002c2  4320              ORRS     r0,r0,r4
;;;618      /* Store the new value */
;;;619      RCC->CFGR = tmpreg;
0002c4  6048              STR      r0,[r1,#4]
;;;620    }
0002c6  bd10              POP      {r4,pc}
;;;621    
                          ENDP

                  RCC_PCLK1Config PROC
;;;633      */
;;;634    void RCC_PCLK1Config(uint32_t RCC_HCLK)
0002c8  b510              PUSH     {r4,lr}
;;;635    {
0002ca  0004              MOVS     r4,r0
0002cc  d010              BEQ      |L1.752|
;;;636      uint32_t tmpreg = 0;
;;;637      /* Check the parameters */
;;;638      assert_param(IS_RCC_PCLK(RCC_HCLK));
0002ce  f5b46f80          CMP      r4,#0x400
0002d2  d00d              BEQ      |L1.752|
0002d4  f5b46fa0          CMP      r4,#0x500
0002d8  d00a              BEQ      |L1.752|
0002da  f5b46fc0          CMP      r4,#0x600
0002de  d007              BEQ      |L1.752|
0002e0  f5b46fe0          CMP      r4,#0x700
0002e4  d004              BEQ      |L1.752|
0002e6  f240217e          MOV      r1,#0x27e
0002ea  a044              ADR      r0,|L1.1020|
0002ec  f7fffffe          BL       assert_failed
                  |L1.752|
;;;639      tmpreg = RCC->CFGR;
0002f0  493f              LDR      r1,|L1.1008|
0002f2  6848              LDR      r0,[r1,#4]
;;;640      /* Clear PPRE1[2:0] bits */
;;;641      tmpreg &= CFGR_PPRE1_Reset_Mask;
0002f4  f42060e0          BIC      r0,r0,#0x700
;;;642      /* Set PPRE1[2:0] bits according to RCC_HCLK value */
;;;643      tmpreg |= RCC_HCLK;
0002f8  4320              ORRS     r0,r0,r4
;;;644      /* Store the new value */
;;;645      RCC->CFGR = tmpreg;
0002fa  6048              STR      r0,[r1,#4]
;;;646    }
0002fc  bd10              POP      {r4,pc}
;;;647    
                          ENDP

                  RCC_PCLK2Config PROC
;;;659      */
;;;660    void RCC_PCLK2Config(uint32_t RCC_HCLK)
0002fe  b510              PUSH     {r4,lr}
;;;661    {
000300  0004              MOVS     r4,r0
000302  d010              BEQ      |L1.806|
;;;662      uint32_t tmpreg = 0;
;;;663      /* Check the parameters */
;;;664      assert_param(IS_RCC_PCLK(RCC_HCLK));
000304  f5b46f80          CMP      r4,#0x400
000308  d00d              BEQ      |L1.806|
00030a  f5b46fa0          CMP      r4,#0x500
00030e  d00a              BEQ      |L1.806|
000310  f5b46fc0          CMP      r4,#0x600
000314  d007              BEQ      |L1.806|
000316  f5b46fe0          CMP      r4,#0x700
00031a  d004              BEQ      |L1.806|
00031c  f44f7126          MOV      r1,#0x298
000320  a036              ADR      r0,|L1.1020|
000322  f7fffffe          BL       assert_failed
                  |L1.806|
;;;665      tmpreg = RCC->CFGR;
000326  4832              LDR      r0,|L1.1008|
000328  6841              LDR      r1,[r0,#4]
;;;666      /* Clear PPRE2[2:0] bits */
;;;667      tmpreg &= CFGR_PPRE2_Reset_Mask;
00032a  f4215160          BIC      r1,r1,#0x3800
;;;668      /* Set PPRE2[2:0] bits according to RCC_HCLK value */
;;;669      tmpreg |= RCC_HCLK << 3;
00032e  ea4101c4          ORR      r1,r1,r4,LSL #3
;;;670      /* Store the new value */
;;;671      RCC->CFGR = tmpreg;
000332  6041              STR      r1,[r0,#4]
;;;672    }
000334  bd10              POP      {r4,pc}
;;;673    
                          ENDP

                  RCC_ITConfig PROC
;;;699      */
;;;700    void RCC_ITConfig(uint8_t RCC_IT, FunctionalState NewState)
000336  b570              PUSH     {r4-r6,lr}
;;;701    {
000338  4605              MOV      r5,r0
00033a  460e              MOV      r6,r1
;;;702      /* Check the parameters */
;;;703      assert_param(IS_RCC_IT(RCC_IT));
00033c  0940              LSRS     r0,r0,#5
00033e  d100              BNE      |L1.834|
000340  b925              CBNZ     r5,|L1.844|
                  |L1.834|
000342  f24021bf          MOV      r1,#0x2bf
000346  a02d              ADR      r0,|L1.1020|
000348  f7fffffe          BL       assert_failed
                  |L1.844|
;;;704      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;705      if (NewState != DISABLE)
;;;706      {
;;;707        /* Perform Byte access to RCC_CIR bits to enable the selected interrupts */
;;;708        *(__IO uint8_t *) CIR_BYTE2_ADDRESS |= RCC_IT;
00034c  4c28              LDR      r4,|L1.1008|
00034e  b14e              CBZ      r6,|L1.868|
000350  2e01              CMP      r6,#1                 ;704
000352  d004              BEQ      |L1.862|
000354  f44f7130          MOV      r1,#0x2c0             ;704
000358  a028              ADR      r0,|L1.1020|
00035a  f7fffffe          BL       assert_failed
                  |L1.862|
00035e  7a60              LDRB     r0,[r4,#9]
000360  4328              ORRS     r0,r0,r5
000362  e001              B        |L1.872|
                  |L1.868|
;;;709      }
;;;710      else
;;;711      {
;;;712        /* Perform Byte access to RCC_CIR bits to disable the selected interrupts */
;;;713        *(__IO uint8_t *) CIR_BYTE2_ADDRESS &= (uint8_t)~RCC_IT;
000364  7a60              LDRB     r0,[r4,#9]
000366  43a8              BICS     r0,r0,r5
                  |L1.872|
000368  7260              STRB     r0,[r4,#9]            ;708
;;;714      }
;;;715    }
00036a  bd70              POP      {r4-r6,pc}
;;;716    
                          ENDP

                  RCC_USBCLKConfig PROC
;;;727      */
;;;728    void RCC_USBCLKConfig(uint32_t RCC_USBCLKSource)
00036c  b510              PUSH     {r4,lr}
;;;729    {
00036e  0004              MOVS     r4,r0
000370  d006              BEQ      |L1.896|
;;;730      /* Check the parameters */
;;;731      assert_param(IS_RCC_USBCLK_SOURCE(RCC_USBCLKSource));
000372  2c01              CMP      r4,#1
000374  d004              BEQ      |L1.896|
000376  f24021db          MOV      r1,#0x2db
00037a  a020              ADR      r0,|L1.1020|
00037c  f7fffffe          BL       assert_failed
                  |L1.896|
;;;732    
;;;733      *(__IO uint32_t *) CFGR_USBPRE_BB = RCC_USBCLKSource;
000380  482b              LDR      r0,|L1.1072|
000382  f8c040d8          STR      r4,[r0,#0xd8]
;;;734    }
000386  bd10              POP      {r4,pc}
;;;735    #else
                          ENDP

                  RCC_ADCCLKConfig PROC
;;;765      */
;;;766    void RCC_ADCCLKConfig(uint32_t RCC_PCLK2)
000388  b510              PUSH     {r4,lr}
;;;767    {
00038a  0004              MOVS     r4,r0
00038c  d00d              BEQ      |L1.938|
;;;768      uint32_t tmpreg = 0;
;;;769      /* Check the parameters */
;;;770      assert_param(IS_RCC_ADCCLK(RCC_PCLK2));
00038e  f5b44f80          CMP      r4,#0x4000
000392  d00a              BEQ      |L1.938|
000394  f5b44f00          CMP      r4,#0x8000
000398  d007              BEQ      |L1.938|
00039a  f5b44f40          CMP      r4,#0xc000
00039e  d004              BEQ      |L1.938|
0003a0  f2403102          MOV      r1,#0x302
0003a4  a015              ADR      r0,|L1.1020|
0003a6  f7fffffe          BL       assert_failed
                  |L1.938|
;;;771      tmpreg = RCC->CFGR;
0003aa  4911              LDR      r1,|L1.1008|
0003ac  6848              LDR      r0,[r1,#4]
;;;772      /* Clear ADCPRE[1:0] bits */
;;;773      tmpreg &= CFGR_ADCPRE_Reset_Mask;
0003ae  f4204040          BIC      r0,r0,#0xc000
;;;774      /* Set ADCPRE[1:0] bits according to RCC_PCLK2 value */
;;;775      tmpreg |= RCC_PCLK2;
0003b2  4320              ORRS     r0,r0,r4
;;;776      /* Store the new value */
;;;777      RCC->CFGR = tmpreg;
0003b4  6048              STR      r0,[r1,#4]
;;;778    }
0003b6  bd10              POP      {r4,pc}
;;;779    
                          ENDP

                  RCC_LSEConfig PROC
;;;828      */
;;;829    void RCC_LSEConfig(uint8_t RCC_LSE)
0003b8  b510              PUSH     {r4,lr}
;;;830    {
0003ba  0004              MOVS     r4,r0
0003bc  d008              BEQ      |L1.976|
;;;831      /* Check the parameters */
;;;832      assert_param(IS_RCC_LSE(RCC_LSE));
0003be  2c01              CMP      r4,#1
0003c0  d006              BEQ      |L1.976|
0003c2  2c04              CMP      r4,#4
0003c4  d004              BEQ      |L1.976|
0003c6  f44f7150          MOV      r1,#0x340
0003ca  a00c              ADR      r0,|L1.1020|
0003cc  f7fffffe          BL       assert_failed
                  |L1.976|
;;;833      /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
;;;834      /* Reset LSEON bit */
;;;835      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
0003d0  4807              LDR      r0,|L1.1008|
0003d2  2100              MOVS     r1,#0
0003d4  f8801020          STRB     r1,[r0,#0x20]
;;;836      /* Reset LSEBYP bit */
;;;837      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
0003d8  f8801020          STRB     r1,[r0,#0x20]
;;;838      /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
;;;839      switch(RCC_LSE)
0003dc  2c01              CMP      r4,#1
0003de  d02b              BEQ      |L1.1080|
0003e0  2c04              CMP      r4,#4
0003e2  d103              BNE      |L1.1004|
;;;840      {
;;;841        case RCC_LSE_ON:
;;;842          /* Set LSEON bit */
;;;843          *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_ON;
;;;844          break;
;;;845          
;;;846        case RCC_LSE_Bypass:
;;;847          /* Set LSEBYP and LSEON bits */
;;;848          *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_Bypass | RCC_LSE_ON;
0003e4  f05f0105          MOVS.W   r1,#5
                  |L1.1000|
0003e8  f8801020          STRB     r1,[r0,#0x20]
                  |L1.1004|
;;;849          break;            
;;;850          
;;;851        default:
;;;852          break;      
;;;853      }
;;;854    }
0003ec  bd10              POP      {r4,pc}
0003ee  0000              DCW      0x0000
                  |L1.1008|
                          DCD      0x40021000
                  |L1.1012|
                          DCD      0xf8ff0000
                  |L1.1016|
                          DCD      0xfef6ffff
                  |L1.1020|
0003fc  2e2e5c53          DCB      "..\\STM32F10x_StdPeriph_Driver\\src\\stm32f10x_rcc.c",0
000400  544d3332
000404  46313078
000408  5f537464
00040c  50657269
000410  70685f44
000414  72697665
000418  725c7372
00041c  635c7374
000420  6d333266
000424  3130785f
000428  7263632e
00042c  6300    
00042e  00                DCB      0
00042f  00                DCB      0
                  |L1.1072|
                          DCD      0x42420000
                  |L1.1076|
                          DCD      0xfffefff0
                  |L1.1080|
000438  2101              MOVS     r1,#1                 ;843
00043a  e7d5              B        |L1.1000|
;;;855    
                          ENDP

                  RCC_LSICmd PROC
;;;861      */
;;;862    void RCC_LSICmd(FunctionalState NewState)
00043c  b510              PUSH     {r4,lr}
;;;863    {
00043e  0004              MOVS     r4,r0
000440  d007              BEQ      |L1.1106|
;;;864      /* Check the parameters */
;;;865      assert_param(IS_FUNCTIONAL_STATE(NewState));
000442  2c01              CMP      r4,#1
000444  d005              BEQ      |L1.1106|
000446  f2403161          MOV      r1,#0x361
00044a  f2af0050          ADR      r0,|L1.1020|
00044e  f7fffffe          BL       assert_failed
                  |L1.1106|
;;;866      *(__IO uint32_t *) CSR_LSION_BB = (uint32_t)NewState;
000452  48b3              LDR      r0,|L1.1824|
000454  6004              STR      r4,[r0,#0]
;;;867    }
000456  e7c9              B        |L1.1004|
;;;868    
                          ENDP

                  RCC_RTCCLKConfig PROC
;;;878      */
;;;879    void RCC_RTCCLKConfig(uint32_t RCC_RTCCLKSource)
000458  b510              PUSH     {r4,lr}
;;;880    {
00045a  4604              MOV      r4,r0
;;;881      /* Check the parameters */
;;;882      assert_param(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));
00045c  f5b07f80          CMP      r0,#0x100
000460  d00b              BEQ      |L1.1146|
000462  f5b47f00          CMP      r4,#0x200
000466  d008              BEQ      |L1.1146|
000468  f5b47f40          CMP      r4,#0x300
00046c  d005              BEQ      |L1.1146|
00046e  f2403172          MOV      r1,#0x372
000472  f2af0078          ADR      r0,|L1.1020|
000476  f7fffffe          BL       assert_failed
                  |L1.1146|
;;;883      /* Select the RTC clock source */
;;;884      RCC->BDCR |= RCC_RTCCLKSource;
00047a  48aa              LDR      r0,|L1.1828|
00047c  6a01              LDR      r1,[r0,#0x20]
00047e  4321              ORRS     r1,r1,r4
000480  6201              STR      r1,[r0,#0x20]
;;;885    }
000482  e7b3              B        |L1.1004|
;;;886    
                          ENDP

                  RCC_RTCCLKCmd PROC
;;;892      */
;;;893    void RCC_RTCCLKCmd(FunctionalState NewState)
000484  b510              PUSH     {r4,lr}
;;;894    {
000486  0004              MOVS     r4,r0
000488  d007              BEQ      |L1.1178|
;;;895      /* Check the parameters */
;;;896      assert_param(IS_FUNCTIONAL_STATE(NewState));
00048a  2c01              CMP      r4,#1
00048c  d005              BEQ      |L1.1178|
00048e  f44f7160          MOV      r1,#0x380
000492  f2af0098          ADR      r0,|L1.1020|
000496  f7fffffe          BL       assert_failed
                  |L1.1178|
;;;897      *(__IO uint32_t *) BDCR_RTCEN_BB = (uint32_t)NewState;
00049a  48a1              LDR      r0,|L1.1824|
00049c  3844              SUBS     r0,r0,#0x44
00049e  6004              STR      r4,[r0,#0]
;;;898    }
0004a0  e7a4              B        |L1.1004|
;;;899    
                          ENDP

                  RCC_GetClocksFreq PROC
;;;907      */
;;;908    void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
0004a2  b530              PUSH     {r4,r5,lr}
;;;909    {
;;;910      uint32_t tmp = 0, pllmull = 0, pllsource = 0, presc = 0;
;;;911    
;;;912    #ifdef  STM32F10X_CL
;;;913      uint32_t prediv1source = 0, prediv1factor = 0, prediv2factor = 0, pll2mull = 0;
;;;914    #endif /* STM32F10X_CL */
;;;915    
;;;916    #if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)
;;;917      uint32_t prediv1factor = 0;
;;;918    #endif
;;;919        
;;;920      /* Get SYSCLK source -------------------------------------------------------*/
;;;921      tmp = RCC->CFGR & CFGR_SWS_Mask;
0004a4  499f              LDR      r1,|L1.1828|
0004a6  684a              LDR      r2,[r1,#4]
0004a8  f012030c          ANDS     r3,r2,#0xc
;;;922      
;;;923      switch (tmp)
;;;924      {
;;;925        case 0x00:  /* HSI used as system clock */
;;;926          RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
0004ac  4a9e              LDR      r2,|L1.1832|
0004ae  d003              BEQ      |L1.1208|
0004b0  2b04              CMP      r3,#4                 ;923
0004b2  d001              BEQ      |L1.1208|
0004b4  2b08              CMP      r3,#8                 ;923
0004b6  d001              BEQ      |L1.1212|
                  |L1.1208|
;;;927          break;
0004b8  6002              STR      r2,[r0,#0]
0004ba  e015              B        |L1.1256|
                  |L1.1212|
;;;928        case 0x04:  /* HSE used as system clock */
;;;929          RCC_Clocks->SYSCLK_Frequency = HSE_VALUE;
;;;930          break;
;;;931        case 0x08:  /* PLL used as system clock */
;;;932    
;;;933          /* Get PLL clock source and multiplication factor ----------------------*/
;;;934          pllmull = RCC->CFGR & CFGR_PLLMull_Mask;
0004bc  684b              LDR      r3,[r1,#4]
;;;935          pllsource = RCC->CFGR & CFGR_PLLSRC_Mask;
0004be  684c              LDR      r4,[r1,#4]
0004c0  f4031370          AND      r3,r3,#0x3c0000       ;934
;;;936          
;;;937    #ifndef STM32F10X_CL      
;;;938          pllmull = ( pllmull >> 18) + 2;
0004c4  f04f0502          MOV      r5,#2
0004c8  f4143f80          TST      r4,#0x10000           ;935
0004cc  eb054393          ADD      r3,r5,r3,LSR #18
;;;939          
;;;940          if (pllsource == 0x00)
0004d0  d007              BEQ      |L1.1250|
;;;941          {/* HSI oscillator clock divided by 2 selected as PLL clock entry */
;;;942            RCC_Clocks->SYSCLK_Frequency = (HSI_VALUE >> 1) * pllmull;
;;;943          }
;;;944          else
;;;945          {
;;;946     #if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)
;;;947           prediv1factor = (RCC->CFGR2 & CFGR2_PREDIV1) + 1;
0004d2  6acc              LDR      r4,[r1,#0x2c]
0004d4  f004040f          AND      r4,r4,#0xf
0004d8  1c64              ADDS     r4,r4,#1
;;;948           /* HSE oscillator clock selected as PREDIV1 clock entry */
;;;949           RCC_Clocks->SYSCLK_Frequency = (HSE_VALUE / prediv1factor) * pllmull; 
0004da  fbb2f2f4          UDIV     r2,r2,r4
0004de  435a              MULS     r2,r3,r2
0004e0  e7ea              B        |L1.1208|
                  |L1.1250|
0004e2  4a92              LDR      r2,|L1.1836|
0004e4  4353              MULS     r3,r2,r3              ;942
0004e6  6003              STR      r3,[r0,#0]            ;942
                  |L1.1256|
;;;950     #else
;;;951            /* HSE selected as PLL clock entry */
;;;952            if ((RCC->CFGR & CFGR_PLLXTPRE_Mask) != (uint32_t)RESET)
;;;953            {/* HSE oscillator clock divided by 2 */
;;;954              RCC_Clocks->SYSCLK_Frequency = (HSE_VALUE >> 1) * pllmull;
;;;955            }
;;;956            else
;;;957            {
;;;958              RCC_Clocks->SYSCLK_Frequency = HSE_VALUE * pllmull;
;;;959            }
;;;960     #endif
;;;961          }
;;;962    #else
;;;963          pllmull = pllmull >> 18;
;;;964          
;;;965          if (pllmull != 0x0D)
;;;966          {
;;;967             pllmull += 2;
;;;968          }
;;;969          else
;;;970          { /* PLL multiplication factor = PLL input clock * 6.5 */
;;;971            pllmull = 13 / 2; 
;;;972          }
;;;973                
;;;974          if (pllsource == 0x00)
;;;975          {/* HSI oscillator clock divided by 2 selected as PLL clock entry */
;;;976            RCC_Clocks->SYSCLK_Frequency = (HSI_VALUE >> 1) * pllmull;
;;;977          }
;;;978          else
;;;979          {/* PREDIV1 selected as PLL clock entry */
;;;980            
;;;981            /* Get PREDIV1 clock source and division factor */
;;;982            prediv1source = RCC->CFGR2 & CFGR2_PREDIV1SRC;
;;;983            prediv1factor = (RCC->CFGR2 & CFGR2_PREDIV1) + 1;
;;;984            
;;;985            if (prediv1source == 0)
;;;986            { /* HSE oscillator clock selected as PREDIV1 clock entry */
;;;987              RCC_Clocks->SYSCLK_Frequency = (HSE_VALUE / prediv1factor) * pllmull;          
;;;988            }
;;;989            else
;;;990            {/* PLL2 clock selected as PREDIV1 clock entry */
;;;991              
;;;992              /* Get PREDIV2 division factor and PLL2 multiplication factor */
;;;993              prediv2factor = ((RCC->CFGR2 & CFGR2_PREDIV2) >> 4) + 1;
;;;994              pll2mull = ((RCC->CFGR2 & CFGR2_PLL2MUL) >> 8 ) + 2; 
;;;995              RCC_Clocks->SYSCLK_Frequency = (((HSE_VALUE / prediv2factor) * pll2mull) / prediv1factor) * pllmull;                         
;;;996            }
;;;997          }
;;;998    #endif /* STM32F10X_CL */ 
;;;999          break;
;;;1000   
;;;1001       default:
;;;1002         RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
;;;1003         break;
;;;1004     }
;;;1005   
;;;1006     /* Compute HCLK, PCLK1, PCLK2 and ADCCLK clocks frequencies ----------------*/
;;;1007     /* Get HCLK prescaler */
;;;1008     tmp = RCC->CFGR & CFGR_HPRE_Set_Mask;
0004e8  684a              LDR      r2,[r1,#4]
;;;1009     tmp = tmp >> 4;
;;;1010     presc = APBAHBPrescTable[tmp];
;;;1011     /* HCLK clock frequency */
;;;1012     RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
;;;1013     /* Get PCLK1 prescaler */
;;;1014     tmp = RCC->CFGR & CFGR_PPRE1_Set_Mask;
;;;1015     tmp = tmp >> 8;
;;;1016     presc = APBAHBPrescTable[tmp];
;;;1017     /* PCLK1 clock frequency */
;;;1018     RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
;;;1019     /* Get PCLK2 prescaler */
;;;1020     tmp = RCC->CFGR & CFGR_PPRE2_Set_Mask;
;;;1021     tmp = tmp >> 11;
;;;1022     presc = APBAHBPrescTable[tmp];
;;;1023     /* PCLK2 clock frequency */
;;;1024     RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
;;;1025     /* Get ADCCLK prescaler */
;;;1026     tmp = RCC->CFGR & CFGR_ADCPRE_Set_Mask;
;;;1027     tmp = tmp >> 14;
;;;1028     presc = ADCPrescTable[tmp];
;;;1029     /* ADCCLK clock frequency */
;;;1030     RCC_Clocks->ADCCLK_Frequency = RCC_Clocks->PCLK2_Frequency / presc;
;;;1031   }
0004ea  230f              MOVS     r3,#0xf
0004ec  4c90              LDR      r4,|L1.1840|
0004ee  ea031212          AND      r2,r3,r2,LSR #4
0004f2  5ca3              LDRB     r3,[r4,r2]            ;1010
0004f4  6802              LDR      r2,[r0,#0]            ;1012
0004f6  40da              LSRS     r2,r2,r3              ;1012
0004f8  6042              STR      r2,[r0,#4]            ;1014
0004fa  684b              LDR      r3,[r1,#4]            ;1014
0004fc  2507              MOVS     r5,#7
0004fe  ea052313          AND      r3,r5,r3,LSR #8
000502  5ce3              LDRB     r3,[r4,r3]            ;1016
000504  fa22f303          LSR      r3,r2,r3              ;1018
000508  6083              STR      r3,[r0,#8]            ;1020
00050a  684b              LDR      r3,[r1,#4]            ;1020
00050c  ea0523d3          AND      r3,r5,r3,LSR #11
000510  5ce3              LDRB     r3,[r4,r3]            ;1022
000512  40da              LSRS     r2,r2,r3              ;1024
000514  60c2              STR      r2,[r0,#0xc]          ;1026
000516  6849              LDR      r1,[r1,#4]            ;1026
000518  2303              MOVS     r3,#3
00051a  ea033191          AND      r1,r3,r1,LSR #14
00051e  1f23              SUBS     r3,r4,#4              ;1028
000520  5c59              LDRB     r1,[r3,r1]            ;1028
000522  fbb2f1f1          UDIV     r1,r2,r1              ;1030
000526  6101              STR      r1,[r0,#0x10]         ;1030
000528  bd30              POP      {r4,r5,pc}
;;;1032   
                          ENDP

                  RCC_AHBPeriphClockCmd PROC
;;;1063     */
;;;1064   void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)
00052a  b570              PUSH     {r4-r6,lr}
;;;1065   {
00052c  4604              MOV      r4,r0
;;;1066     /* Check the parameters */
;;;1067     assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));
00052e  f2405057          MOV      r0,#0x557
000532  460e              MOV      r6,r1                 ;1065
000534  ea340000          BICS     r0,r4,r0
000538  d100              BNE      |L1.1340|
00053a  b92c              CBNZ     r4,|L1.1352|
                  |L1.1340|
00053c  f240412b          MOV      r1,#0x42b
000540  f2af1048          ADR      r0,|L1.1020|
000544  f7fffffe          BL       assert_failed
                  |L1.1352|
;;;1068     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1069   
;;;1070     if (NewState != DISABLE)
;;;1071     {
;;;1072       RCC->AHBENR |= RCC_AHBPeriph;
000548  4d76              LDR      r5,|L1.1828|
00054a  b156              CBZ      r6,|L1.1378|
00054c  2e01              CMP      r6,#1                 ;1068
00054e  d005              BEQ      |L1.1372|
000550  f240412c          MOV      r1,#0x42c             ;1068
000554  f2af105c          ADR      r0,|L1.1020|
000558  f7fffffe          BL       assert_failed
                  |L1.1372|
00055c  6968              LDR      r0,[r5,#0x14]
00055e  4320              ORRS     r0,r0,r4
000560  e001              B        |L1.1382|
                  |L1.1378|
;;;1073     }
;;;1074     else
;;;1075     {
;;;1076       RCC->AHBENR &= ~RCC_AHBPeriph;
000562  6968              LDR      r0,[r5,#0x14]
000564  43a0              BICS     r0,r0,r4
                  |L1.1382|
000566  6168              STR      r0,[r5,#0x14]         ;1072
;;;1077     }
;;;1078   }
000568  bd70              POP      {r4-r6,pc}
;;;1079   
                          ENDP

                  RCC_APB2PeriphClockCmd PROC
;;;1094     */
;;;1095   void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
00056a  b570              PUSH     {r4-r6,lr}
;;;1096   {
00056c  4604              MOV      r4,r0
;;;1097     /* Check the parameters */
;;;1098     assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
00056e  4871              LDR      r0,|L1.1844|
000570  460e              MOV      r6,r1                 ;1096
000572  4204              TST      r4,r0
000574  d100              BNE      |L1.1400|
000576  b92c              CBNZ     r4,|L1.1412|
                  |L1.1400|
000578  f240414a          MOV      r1,#0x44a
00057c  f2af1084          ADR      r0,|L1.1020|
000580  f7fffffe          BL       assert_failed
                  |L1.1412|
;;;1099     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1100     if (NewState != DISABLE)
;;;1101     {
;;;1102       RCC->APB2ENR |= RCC_APB2Periph;
000584  4d67              LDR      r5,|L1.1828|
000586  b156              CBZ      r6,|L1.1438|
000588  2e01              CMP      r6,#1                 ;1099
00058a  d005              BEQ      |L1.1432|
00058c  f240414b          MOV      r1,#0x44b             ;1099
000590  f2af1098          ADR      r0,|L1.1020|
000594  f7fffffe          BL       assert_failed
                  |L1.1432|
000598  69a8              LDR      r0,[r5,#0x18]
00059a  4320              ORRS     r0,r0,r4
00059c  e001              B        |L1.1442|
                  |L1.1438|
;;;1103     }
;;;1104     else
;;;1105     {
;;;1106       RCC->APB2ENR &= ~RCC_APB2Periph;
00059e  69a8              LDR      r0,[r5,#0x18]
0005a0  43a0              BICS     r0,r0,r4
                  |L1.1442|
0005a2  61a8              STR      r0,[r5,#0x18]         ;1102
;;;1107     }
;;;1108   }
0005a4  bd70              POP      {r4-r6,pc}
;;;1109   
                          ENDP

                  RCC_APB1PeriphClockCmd PROC
;;;1125     */
;;;1126   void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
0005a6  b570              PUSH     {r4-r6,lr}
;;;1127   {
0005a8  4604              MOV      r4,r0
;;;1128     /* Check the parameters */
;;;1129     assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
0005aa  4863              LDR      r0,|L1.1848|
0005ac  460e              MOV      r6,r1                 ;1127
0005ae  4204              TST      r4,r0
0005b0  d100              BNE      |L1.1460|
0005b2  b92c              CBNZ     r4,|L1.1472|
                  |L1.1460|
0005b4  f2404169          MOV      r1,#0x469
0005b8  f2af10c0          ADR      r0,|L1.1020|
0005bc  f7fffffe          BL       assert_failed
                  |L1.1472|
;;;1130     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1131     if (NewState != DISABLE)
;;;1132     {
;;;1133       RCC->APB1ENR |= RCC_APB1Periph;
0005c0  4d58              LDR      r5,|L1.1828|
0005c2  b156              CBZ      r6,|L1.1498|
0005c4  2e01              CMP      r6,#1                 ;1130
0005c6  d005              BEQ      |L1.1492|
0005c8  f240416a          MOV      r1,#0x46a             ;1130
0005cc  f2af10d4          ADR      r0,|L1.1020|
0005d0  f7fffffe          BL       assert_failed
                  |L1.1492|
0005d4  69e8              LDR      r0,[r5,#0x1c]
0005d6  4320              ORRS     r0,r0,r4
0005d8  e001              B        |L1.1502|
                  |L1.1498|
;;;1134     }
;;;1135     else
;;;1136     {
;;;1137       RCC->APB1ENR &= ~RCC_APB1Periph;
0005da  69e8              LDR      r0,[r5,#0x1c]
0005dc  43a0              BICS     r0,r0,r4
                  |L1.1502|
0005de  61e8              STR      r0,[r5,#0x1c]         ;1133
;;;1138     }
;;;1139   }
0005e0  bd70              POP      {r4-r6,pc}
;;;1140   
                          ENDP

                  RCC_APB2PeriphResetCmd PROC
;;;1184     */
;;;1185   void RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
0005e2  b570              PUSH     {r4-r6,lr}
;;;1186   {
0005e4  4604              MOV      r4,r0
;;;1187     /* Check the parameters */
;;;1188     assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
0005e6  4853              LDR      r0,|L1.1844|
0005e8  460e              MOV      r6,r1                 ;1186
0005ea  4204              TST      r4,r0
0005ec  d100              BNE      |L1.1520|
0005ee  b92c              CBNZ     r4,|L1.1532|
                  |L1.1520|
0005f0  f24041a4          MOV      r1,#0x4a4
0005f4  f2af10fc          ADR      r0,|L1.1020|
0005f8  f7fffffe          BL       assert_failed
                  |L1.1532|
;;;1189     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1190     if (NewState != DISABLE)
;;;1191     {
;;;1192       RCC->APB2RSTR |= RCC_APB2Periph;
0005fc  4d49              LDR      r5,|L1.1828|
0005fe  b156              CBZ      r6,|L1.1558|
000600  2e01              CMP      r6,#1                 ;1189
000602  d005              BEQ      |L1.1552|
000604  f24041a5          MOV      r1,#0x4a5             ;1189
000608  f2af2010          ADR      r0,|L1.1020|
00060c  f7fffffe          BL       assert_failed
                  |L1.1552|
000610  68e8              LDR      r0,[r5,#0xc]
000612  4320              ORRS     r0,r0,r4
000614  e001              B        |L1.1562|
                  |L1.1558|
;;;1193     }
;;;1194     else
;;;1195     {
;;;1196       RCC->APB2RSTR &= ~RCC_APB2Periph;
000616  68e8              LDR      r0,[r5,#0xc]
000618  43a0              BICS     r0,r0,r4
                  |L1.1562|
00061a  60e8              STR      r0,[r5,#0xc]          ;1192
;;;1197     }
;;;1198   }
00061c  bd70              POP      {r4-r6,pc}
;;;1199   
                          ENDP

                  RCC_APB1PeriphResetCmd PROC
;;;1215     */
;;;1216   void RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
00061e  b570              PUSH     {r4-r6,lr}
;;;1217   {
000620  4604              MOV      r4,r0
;;;1218     /* Check the parameters */
;;;1219     assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
000622  4845              LDR      r0,|L1.1848|
000624  460e              MOV      r6,r1                 ;1217
000626  4204              TST      r4,r0
000628  d100              BNE      |L1.1580|
00062a  b92c              CBNZ     r4,|L1.1592|
                  |L1.1580|
00062c  f24041c3          MOV      r1,#0x4c3
000630  f2af2038          ADR      r0,|L1.1020|
000634  f7fffffe          BL       assert_failed
                  |L1.1592|
;;;1220     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1221     if (NewState != DISABLE)
;;;1222     {
;;;1223       RCC->APB1RSTR |= RCC_APB1Periph;
000638  4d3a              LDR      r5,|L1.1828|
00063a  b156              CBZ      r6,|L1.1618|
00063c  2e01              CMP      r6,#1                 ;1220
00063e  d005              BEQ      |L1.1612|
000640  f24041c4          MOV      r1,#0x4c4             ;1220
000644  f2af204c          ADR      r0,|L1.1020|
000648  f7fffffe          BL       assert_failed
                  |L1.1612|
00064c  6928              LDR      r0,[r5,#0x10]
00064e  4320              ORRS     r0,r0,r4
000650  e001              B        |L1.1622|
                  |L1.1618|
;;;1224     }
;;;1225     else
;;;1226     {
;;;1227       RCC->APB1RSTR &= ~RCC_APB1Periph;
000652  6928              LDR      r0,[r5,#0x10]
000654  43a0              BICS     r0,r0,r4
                  |L1.1622|
000656  6128              STR      r0,[r5,#0x10]         ;1223
;;;1228     }
;;;1229   }
000658  bd70              POP      {r4-r6,pc}
;;;1230   
                          ENDP

                  RCC_BackupResetCmd PROC
;;;1236     */
;;;1237   void RCC_BackupResetCmd(FunctionalState NewState)
00065a  b510              PUSH     {r4,lr}
;;;1238   {
00065c  0004              MOVS     r4,r0
00065e  d007              BEQ      |L1.1648|
;;;1239     /* Check the parameters */
;;;1240     assert_param(IS_FUNCTIONAL_STATE(NewState));
000660  2c01              CMP      r4,#1
000662  d005              BEQ      |L1.1648|
000664  f44f619b          MOV      r1,#0x4d8
000668  f2af2070          ADR      r0,|L1.1020|
00066c  f7fffffe          BL       assert_failed
                  |L1.1648|
;;;1241     *(__IO uint32_t *) BDCR_BDRST_BB = (uint32_t)NewState;
000670  482b              LDR      r0,|L1.1824|
000672  3840              SUBS     r0,r0,#0x40
000674  6004              STR      r4,[r0,#0]
;;;1242   }
000676  e6b9              B        |L1.1004|
;;;1243   
                          ENDP

                  RCC_ClockSecuritySystemCmd PROC
;;;1249     */
;;;1250   void RCC_ClockSecuritySystemCmd(FunctionalState NewState)
000678  b510              PUSH     {r4,lr}
;;;1251   {
00067a  0004              MOVS     r4,r0
00067c  d007              BEQ      |L1.1678|
;;;1252     /* Check the parameters */
;;;1253     assert_param(IS_FUNCTIONAL_STATE(NewState));
00067e  2c01              CMP      r4,#1
000680  d005              BEQ      |L1.1678|
000682  f24041e5          MOV      r1,#0x4e5
000686  f2af208c          ADR      r0,|L1.1020|
00068a  f7fffffe          BL       assert_failed
                  |L1.1678|
;;;1254     *(__IO uint32_t *) CR_CSSON_BB = (uint32_t)NewState;
00068e  482b              LDR      r0,|L1.1852|
000690  64c4              STR      r4,[r0,#0x4c]
;;;1255   }
000692  e6ab              B        |L1.1004|
;;;1256   
                          ENDP

                  RCC_MCOConfig PROC
;;;1281     */
;;;1282   void RCC_MCOConfig(uint8_t RCC_MCO)
000694  b510              PUSH     {r4,lr}
;;;1283   {
000696  0004              MOVS     r4,r0
000698  d00d              BEQ      |L1.1718|
;;;1284     /* Check the parameters */
;;;1285     assert_param(IS_RCC_MCO(RCC_MCO));
00069a  2c05              CMP      r4,#5
00069c  d00b              BEQ      |L1.1718|
00069e  2c04              CMP      r4,#4
0006a0  d009              BEQ      |L1.1718|
0006a2  2c06              CMP      r4,#6
0006a4  d007              BEQ      |L1.1718|
0006a6  2c07              CMP      r4,#7
0006a8  d005              BEQ      |L1.1718|
0006aa  f2405105          MOV      r1,#0x505
0006ae  f2af20b4          ADR      r0,|L1.1020|
0006b2  f7fffffe          BL       assert_failed
                  |L1.1718|
;;;1286   
;;;1287     /* Perform Byte access to MCO bits to select the MCO source */
;;;1288     *(__IO uint8_t *) CFGR_BYTE4_ADDRESS = RCC_MCO;
0006b6  481b              LDR      r0,|L1.1828|
0006b8  71c4              STRB     r4,[r0,#7]
;;;1289   }
0006ba  e697              B        |L1.1004|
;;;1290   
                          ENDP

                  RCC_ClearFlag PROC
;;;1370     */
;;;1371   void RCC_ClearFlag(void)
0006bc  4819              LDR      r0,|L1.1828|
;;;1372   {
;;;1373     /* Set RMVF bit to clear the reset flags */
;;;1374     RCC->CSR |= CSR_RMVF_Set;
0006be  6a41              LDR      r1,[r0,#0x24]
0006c0  f0417180          ORR      r1,r1,#0x1000000
0006c4  6241              STR      r1,[r0,#0x24]
;;;1375   }
0006c6  4770              BX       lr
;;;1376   
                          ENDP

                  RCC_GetITStatus PROC
;;;1401     */
;;;1402   ITStatus RCC_GetITStatus(uint8_t RCC_IT)
0006c8  b570              PUSH     {r4-r6,lr}
;;;1403   {
;;;1404     ITStatus bitstatus = RESET;
0006ca  2500              MOVS     r5,#0
0006cc  4604              MOV      r4,r0                 ;1403
;;;1405     /* Check the parameters */
;;;1406     assert_param(IS_RCC_GET_IT(RCC_IT));
0006ce  2801              CMP      r0,#1
0006d0  d00f              BEQ      |L1.1778|
0006d2  2c02              CMP      r4,#2
0006d4  d00d              BEQ      |L1.1778|
0006d6  2c04              CMP      r4,#4
0006d8  d00b              BEQ      |L1.1778|
0006da  2c08              CMP      r4,#8
0006dc  d009              BEQ      |L1.1778|
0006de  2c10              CMP      r4,#0x10
0006e0  d007              BEQ      |L1.1778|
0006e2  2c80              CMP      r4,#0x80
0006e4  d005              BEQ      |L1.1778|
0006e6  f240517e          MOV      r1,#0x57e
0006ea  f2af20f0          ADR      r0,|L1.1020|
0006ee  f7fffffe          BL       assert_failed
                  |L1.1778|
;;;1407   
;;;1408     /* Check the status of the specified RCC interrupt */
;;;1409     if ((RCC->CIR & RCC_IT) != (uint32_t)RESET)
0006f2  480c              LDR      r0,|L1.1828|
0006f4  6880              LDR      r0,[r0,#8]
0006f6  4220              TST      r0,r4
0006f8  d000              BEQ      |L1.1788|
;;;1410     {
;;;1411       bitstatus = SET;
0006fa  2501              MOVS     r5,#1
                  |L1.1788|
;;;1412     }
;;;1413     else
;;;1414     {
;;;1415       bitstatus = RESET;
;;;1416     }
;;;1417   
;;;1418     /* Return the RCC_IT status */
;;;1419     return  bitstatus;
0006fc  4628              MOV      r0,r5
;;;1420   }
0006fe  bd70              POP      {r4-r6,pc}
;;;1421   
                          ENDP

                  RCC_ClearITPendingBit PROC
;;;1447     */
;;;1448   void RCC_ClearITPendingBit(uint8_t RCC_IT)
000700  b510              PUSH     {r4,lr}
;;;1449   {
000702  4604              MOV      r4,r0
;;;1450     /* Check the parameters */
;;;1451     assert_param(IS_RCC_CLEAR_IT(RCC_IT));
000704  f0100f60          TST      r0,#0x60
000708  d100              BNE      |L1.1804|
00070a  b92c              CBNZ     r4,|L1.1816|
                  |L1.1804|
00070c  f24051ab          MOV      r1,#0x5ab
000710  f2af3018          ADR      r0,|L1.1020|
000714  f7fffffe          BL       assert_failed
                  |L1.1816|
;;;1452   
;;;1453     /* Perform Byte access to RCC_CIR[23:16] bits to clear the selected interrupt
;;;1454        pending bits */
;;;1455     *(__IO uint8_t *) CIR_BYTE3_ADDRESS = RCC_IT;
000718  4802              LDR      r0,|L1.1828|
00071a  7284              STRB     r4,[r0,#0xa]
;;;1456   }
00071c  e666              B        |L1.1004|
;;;1457   
                          ENDP

00071e  0000              DCW      0x0000
                  |L1.1824|
                          DCD      0x42420480
                  |L1.1828|
                          DCD      0x40021000
                  |L1.1832|
                          DCD      0x007a1200
                  |L1.1836|
                          DCD      0x003d0900
                  |L1.1840|
                          DCD      ||.data||+0x4
                  |L1.1844|
                          DCD      0xffc00002
                  |L1.1848|
                          DCD      0x81013600
                  |L1.1852|
                          DCD      0x42420000

                          AREA ||.data||, DATA, ALIGN=0

                  ADCPrescTable
000000  02040608          DCB      0x02,0x04,0x06,0x08
                  APBAHBPrescTable
000004  00000000          DCB      0x00,0x00,0x00,0x00
000008  01020304          DCB      0x01,0x02,0x03,0x04
00000c  01020304          DCB      0x01,0x02,0x03,0x04
000010  06070809          DCB      0x06,0x07,0x08,0x09
