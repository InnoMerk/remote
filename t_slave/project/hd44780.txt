; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o.\hd44780.o --asm_dir=.\ --list_dir=.\ --depend=.\hd44780.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\hooks -I..\lcd -I..\led -I..\load_cpu -I..\main -I..\printf -I..\limit_switch -I..\control_task -I..\mode_task -I..\lcdTask -I..\hit -I..\move_task -I..\project -I..\..\rtos -I..\..\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\STM32F10x_StdPeriph_Driver\inc -I..\..\STM32F10x_StdPeriph_Driver\src -I"C:\Program Files\keil\ARM\RV31\INC" -I"C:\Program Files\keil\ARM\PACK\ARM\CMSIS\3.20.4\CMSIS\Include" -I"C:\Program Files\keil\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include" -DSTM32F10X_MD_VL -DUSE_STDPERIPH_DRIVER --omf_browse=.\hd44780.crf ..\lcd\hd44780.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  lcd_busy_delay PROC
;;;77     /*!	\brief	*/
;;;78     static void lcd_busy_delay(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;79     {
;;;80     	uint8_t BusyFlag;
;;;81     
;;;82     	Set_D7_as_Input(); /* Set D7 as input. */
000004  4dfe              LDR      r5,|L1.1024|
000006  6828              LDR      r0,[r5,#0]
000008  f4202070          BIC      r0,r0,#0xf0000
00000c  6028              STR      r0,[r5,#0]
00000e  6828              LDR      r0,[r5,#0]
000010  f4402080          ORR      r0,r0,#0x40000
000014  6028              STR      r0,[r5,#0]
;;;83     	/* When RS = 0 and R/W = 1, the busy flag is output to DB7. */
;;;84     	CLR(LCD_RS_OUT, LCD_RS);
000016  4cfa              LDR      r4,|L1.1024|
000018  340c              ADDS     r4,r4,#0xc
00001a  6820              LDR      r0,[r4,#0]
00001c  f0200008          BIC      r0,r0,#8
000020  6020              STR      r0,[r4,#0]
;;;85     	SET(LCD_RW_OUT, LCD_RW);
000022  6820              LDR      r0,[r4,#0]
000024  f0400004          ORR      r0,r0,#4
000028  6020              STR      r0,[r4,#0]
;;;86     
;;;87     	do
;;;88     	{/* Note: two cycles are needed for the busy flag check. */
;;;89     		/* Read busy flag. */
;;;90     		lcd_strobe();
;;;91     		/* D7 is used as busy flag. */
;;;92     		BusyFlag = GET(LCD_D7_IN, LCD_D7);
00002a  1f27              SUBS     r7,r4,#4
                  |L1.44|
00002c  f7fffffe          BL       lcd_strobe
000030  6838              LDR      r0,[r7,#0]
000032  f3c01600          UBFX     r6,r0,#4,#1
;;;93     		/* Discard D3. */
;;;94     		lcd_strobe();
000036  f7fffffe          BL       lcd_strobe
;;;95     		/* Verify the busy flag */
;;;96     	}while (BusyFlag);
00003a  2e00              CMP      r6,#0
00003c  d1f6              BNE      |L1.44|
;;;97     
;;;98     	CLR(LCD_RW_OUT, LCD_RW);
00003e  6820              LDR      r0,[r4,#0]
000040  f0200004          BIC      r0,r0,#4
000044  6020              STR      r0,[r4,#0]
;;;99     	Set_D7_as_Outut(); /* Restore D7 as the output. */
000046  6828              LDR      r0,[r5,#0]
000048  f4202070          BIC      r0,r0,#0xf0000
00004c  6028              STR      r0,[r5,#0]
00004e  6828              LDR      r0,[r5,#0]
000050  f4403040          ORR      r0,r0,#0x30000
000054  6028              STR      r0,[r5,#0]
;;;100    }
000056  e8bd81f0          POP      {r4-r8,pc}
;;;101    #endif /* USE_BUSY_FLAG */
                          ENDP

                  lcd_high PROC
;;;123    /*!	\brief	Send the msb nibble of the data / command to LCD. */
;;;124    static void lcd_high(uint8_t data)
00005a  49ea              LDR      r1,|L1.1028|
;;;125    {/* Low level function. */
;;;126    	if(data & LCD_D7_MASK) SET(LCD_D7_OUT, LCD_D7); else CLR(LCD_D7_OUT, LCD_D7);
00005c  0602              LSLS     r2,r0,#24
00005e  680a              LDR      r2,[r1,#0]
000060  d502              BPL      |L1.104|
000062  f0420210          ORR      r2,r2,#0x10
000066  e001              B        |L1.108|
                  |L1.104|
000068  f0220210          BIC      r2,r2,#0x10
                  |L1.108|
00006c  600a              STR      r2,[r1,#0]
;;;127    	if(data & LCD_D6_MASK) SET(LCD_D6_OUT, LCD_D6); else CLR(LCD_D6_OUT, LCD_D6);
00006e  0642              LSLS     r2,r0,#25
000070  680a              LDR      r2,[r1,#0]
000072  d502              BPL      |L1.122|
000074  f0420220          ORR      r2,r2,#0x20
000078  e001              B        |L1.126|
                  |L1.122|
00007a  f0220220          BIC      r2,r2,#0x20
                  |L1.126|
00007e  600a              STR      r2,[r1,#0]
;;;128    	if(data & LCD_D5_MASK) SET(LCD_D5_OUT, LCD_D5); else CLR(LCD_D5_OUT, LCD_D5);
000080  0682              LSLS     r2,r0,#26
000082  680a              LDR      r2,[r1,#0]
000084  d502              BPL      |L1.140|
000086  f0420240          ORR      r2,r2,#0x40
00008a  e001              B        |L1.144|
                  |L1.140|
00008c  f0220240          BIC      r2,r2,#0x40
                  |L1.144|
000090  600a              STR      r2,[r1,#0]
;;;129    	if(data & LCD_D4_MASK) SET(LCD_D4_OUT, LCD_D4); else CLR(LCD_D4_OUT, LCD_D4);
000092  06c0              LSLS     r0,r0,#27
000094  6808              LDR      r0,[r1,#0]
000096  d502              BPL      |L1.158|
000098  f0400080          ORR      r0,r0,#0x80
00009c  e001              B        |L1.162|
                  |L1.158|
00009e  f0200080          BIC      r0,r0,#0x80
                  |L1.162|
0000a2  6008              STR      r0,[r1,#0]
;;;130    }
0000a4  4770              BX       lr
;;;131    
                          ENDP

                  lcd_low PROC
;;;132    /*!	\brief	Send the lsb nibble of the data / command to LCD. */
;;;133    static void lcd_low(uint8_t data)
0000a6  49d7              LDR      r1,|L1.1028|
;;;134    {/* Low level function. */
;;;135    	if(data & LCD_D3_MASK) SET(LCD_D7_OUT, LCD_D7); else CLR(LCD_D7_OUT, LCD_D7);
0000a8  0702              LSLS     r2,r0,#28
0000aa  680a              LDR      r2,[r1,#0]
0000ac  d502              BPL      |L1.180|
0000ae  f0420210          ORR      r2,r2,#0x10
0000b2  e001              B        |L1.184|
                  |L1.180|
0000b4  f0220210          BIC      r2,r2,#0x10
                  |L1.184|
0000b8  600a              STR      r2,[r1,#0]
;;;136    	if(data & LCD_D2_MASK) SET(LCD_D6_OUT, LCD_D6); else CLR(LCD_D6_OUT, LCD_D6);
0000ba  0742              LSLS     r2,r0,#29
0000bc  680a              LDR      r2,[r1,#0]
0000be  d502              BPL      |L1.198|
0000c0  f0420220          ORR      r2,r2,#0x20
0000c4  e001              B        |L1.202|
                  |L1.198|
0000c6  f0220220          BIC      r2,r2,#0x20
                  |L1.202|
0000ca  600a              STR      r2,[r1,#0]
;;;137    	if(data & LCD_D1_MASK) SET(LCD_D5_OUT, LCD_D5); else CLR(LCD_D5_OUT, LCD_D5);
0000cc  0782              LSLS     r2,r0,#30
0000ce  680a              LDR      r2,[r1,#0]
0000d0  d502              BPL      |L1.216|
0000d2  f0420240          ORR      r2,r2,#0x40
0000d6  e001              B        |L1.220|
                  |L1.216|
0000d8  f0220240          BIC      r2,r2,#0x40
                  |L1.220|
0000dc  600a              STR      r2,[r1,#0]
;;;138    	if(data & LCD_D0_MASK) SET(LCD_D4_OUT, LCD_D4); else CLR(LCD_D4_OUT, LCD_D4);
0000de  07c0              LSLS     r0,r0,#31
0000e0  6808              LDR      r0,[r1,#0]
0000e2  d002              BEQ      |L1.234|
0000e4  f0400080          ORR      r0,r0,#0x80
0000e8  e001              B        |L1.238|
                  |L1.234|
0000ea  f0200080          BIC      r0,r0,#0x80
                  |L1.238|
0000ee  6008              STR      r0,[r1,#0]
;;;139    }
0000f0  4770              BX       lr
;;;140    
                          ENDP

                  lcd_clrscr PROC
;;;192     * 				It also sets I/D to 1 (increment mode) in entry mode (S of entry mode does not change). */
;;;193    void lcd_clrscr(void)
0000f2  48c4              LDR      r0,|L1.1028|
;;;194    {
0000f4  b510              PUSH     {r4,lr}
;;;195    	/* Send a command to LCD. */
;;;196    	CLR(LCD_RS_OUT, LCD_RS);
0000f6  6801              LDR      r1,[r0,#0]
0000f8  f0210108          BIC      r1,r1,#8
0000fc  6001              STR      r1,[r0,#0]
;;;197    	/* Clear screen */
;;;198    	lcd_write(0x01u);
0000fe  2001              MOVS     r0,#1
000100  f7fffffe          BL       lcd_write
;;;199    	/* Busy delay */
;;;200    #if (USE_BUSY_FLAG)
;;;201    	lcd_busy_delay();
000104  e8bd4010          POP      {r4,lr}
000108  e7fe              B        lcd_busy_delay
;;;202    #else
;;;203    	lcd_10us_delay(CLRSCR_CYCLE_TIME);
;;;204    #endif /* USE_BUSY_FLAG */
;;;205    }
;;;206    
                          ENDP

                  lcd_return PROC
;;;211     * 				(in the first line if 2 lines are displayed). */
;;;212    void lcd_return(void)
00010a  48be              LDR      r0,|L1.1028|
;;;213    {
00010c  b510              PUSH     {r4,lr}
;;;214    	/* Send a command to LCD. */
;;;215    	CLR(LCD_RS_OUT, LCD_RS);
00010e  6801              LDR      r1,[r0,#0]
000110  f0210108          BIC      r1,r1,#8
000114  6001              STR      r1,[r0,#0]
;;;216    	/* Return home */
;;;217    	lcd_write(0x02u);
000116  2002              MOVS     r0,#2
000118  f7fffffe          BL       lcd_write
;;;218    	/* Busy delay */
;;;219    #if (USE_BUSY_FLAG)
;;;220    	lcd_busy_delay();
00011c  e8bd4010          POP      {r4,lr}
000120  e7fe              B        lcd_busy_delay
;;;221    #else
;;;222    	lcd_10us_delay(RETHOME_CYCLE_TIME);
;;;223    #endif /* USE_BUSY_FLAG */
;;;224    }
;;;225    
                          ENDP

                  lcd_scroll PROC
;;;228     *	\note		The first and second line displays will shift at the same time. */
;;;229    void lcd_scroll(uint8_t direction)
000122  49b8              LDR      r1,|L1.1028|
;;;230    {
;;;231    	/* Send a command to LCD. */
;;;232    	CLR(LCD_RS_OUT, LCD_RS);
000124  680a              LDR      r2,[r1,#0]
000126  f0220208          BIC      r2,r2,#8
00012a  600a              STR      r2,[r1,#0]
;;;233    	/* Scroll display */
;;;234    	switch (direction)
00012c  283c              CMP      r0,#0x3c
00012e  d005              BEQ      |L1.316|
000130  283e              CMP      r0,#0x3e
000132  d105              BNE      |L1.320|
;;;235    	{
;;;236    	/* To left */
;;;237    		case LEFT  :
;;;238    			lcd_write(0x18u);
;;;239    			break;
;;;240    
;;;241    		/* To right */
;;;242    		case RIGHT :
;;;243    			lcd_write(0x1Cu);
000134  f05f001c          MOVS.W   r0,#0x1c
                  |L1.312|
000138  f7ffbffe          B.W      lcd_write
                  |L1.316|
00013c  2018              MOVS     r0,#0x18              ;238
00013e  e7fb              B        |L1.312|
                  |L1.320|
;;;244    			break;
;;;245    
;;;246    		default:
;;;247    			/* Ignore this command */
;;;248    			break;
;;;249    	}
;;;250    }
000140  4770              BX       lr
;;;251    
                          ENDP

                  cursor_shift PROC
;;;256     * 				when it passes the 40th digit of the first line. */
;;;257    void cursor_shift(uint8_t direction)
000142  49b0              LDR      r1,|L1.1028|
;;;258    {
;;;259    	/* Send a command to LCD. */
;;;260    	CLR(LCD_RS_OUT, LCD_RS);
000144  680a              LDR      r2,[r1,#0]
000146  f0220208          BIC      r2,r2,#8
00014a  600a              STR      r2,[r1,#0]
;;;261    	/* Shift cursor */
;;;262    	switch (direction)
00014c  283c              CMP      r0,#0x3c
00014e  d005              BEQ      |L1.348|
000150  283e              CMP      r0,#0x3e
000152  d105              BNE      |L1.352|
;;;263    	{
;;;264    		/* To left */
;;;265    		case LEFT  :
;;;266    			lcd_write(0x10u);
;;;267    			break;
;;;268    
;;;269    		/* To right */
;;;270    		case RIGHT :
;;;271    			lcd_write(0x14u);
000154  f05f0014          MOVS.W   r0,#0x14
                  |L1.344|
000158  f7ffbffe          B.W      lcd_write
                  |L1.348|
00015c  2010              MOVS     r0,#0x10              ;266
00015e  e7fb              B        |L1.344|
                  |L1.352|
;;;272    			break;
;;;273    
;;;274    		default:
;;;275    			/* Ignore this command */
;;;276    			break;
;;;277    	}
;;;278    }
000160  4770              BX       lr
;;;279    
                          ENDP

                  lcd_goto PROC
;;;280    /*!	\details	Go to the specified (DDRAM/CGRAM) memory address.*/
;;;281    void lcd_goto(uint8_t line, uint8_t address)
000162  4aa8              LDR      r2,|L1.1028|
;;;282    {
;;;283    	/* Send a command to LCD. */
;;;284    	CLR(LCD_RS_OUT, LCD_RS);
000164  6813              LDR      r3,[r2,#0]
000166  f0230308          BIC      r3,r3,#8
00016a  6013              STR      r3,[r2,#0]
;;;285    	/* Set DDRAM/CGRAM address. */
;;;286    	switch (line)
00016c  2806              CMP      r0,#6
00016e  d214              BCS      |L1.410|
000170  e8dff000          TBB      [pc,r0]
000174  13030609          DCB      0x13,0x03,0x06,0x09
000178  0c0f              DCB      0x0c,0x0f
;;;287    	{
;;;288    		/* Set DDRAM address. */
;;;289    		case LCD_1st_LINE: lcd_write(0x80u | START_ADDRESS_1st_LINE | address); break;
00017a  f0410080          ORR      r0,r1,#0x80
00017e  e00a              B        |L1.406|
;;;290    		case LCD_2nd_LINE: lcd_write(0x80u | START_ADDRESS_2nd_LINE | address); break;
000180  f04100c0          ORR      r0,r1,#0xc0
000184  e007              B        |L1.406|
;;;291    		case LCD_3rd_LINE: lcd_write(0x80u | START_ADDRESS_3rd_LINE | address); break;
000186  f0410090          ORR      r0,r1,#0x90
00018a  e004              B        |L1.406|
;;;292    		case LCD_4th_LINE: lcd_write(0x80u | START_ADDRESS_4th_LINE | address); break;
00018c  f04100d0          ORR      r0,r1,#0xd0
000190  e001              B        |L1.406|
;;;293    		/* Set CGRAM address. */
;;;294    		case CGRAM : lcd_write(0x40u | address); break;
000192  f0410040          ORR      r0,r1,#0x40
                  |L1.406|
000196  f7ffbffe          B.W      lcd_write
                  |L1.410|
;;;295    
;;;296    		default:
;;;297    			/* Ignore this command */
;;;298    			break;
;;;299    	}
;;;300    }
00019a  4770              BX       lr
;;;301    
                          ENDP

                  lcd_setmode PROC
;;;302    /*!	\details	Change LCD settings. */
;;;303    void lcd_setmode(uint8_t param)
00019c  4999              LDR      r1,|L1.1028|
;;;304    {
;;;305    	/* Send a command to LCD. */
;;;306    	CLR(LCD_RS_OUT, LCD_RS);
00019e  680a              LDR      r2,[r1,#0]
0001a0  f0220208          BIC      r2,r2,#8
0001a4  600a              STR      r2,[r1,#0]
;;;307    	lcd_write(param);
0001a6  f7ffbffe          B.W      lcd_write
;;;308    }
;;;309    
                          ENDP

                  lcd_putc PROC
;;;310    /*!	\details	Write a single char to the current memory space (DDRAM/CGRAM). */
;;;311    void lcd_putc(uint8_t data)
0001aa  4996              LDR      r1,|L1.1028|
;;;312    {
0001ac  b510              PUSH     {r4,lr}
;;;313    	/* Send data to LCD. */
;;;314    	SET(LCD_RS_OUT, LCD_RS);
0001ae  680a              LDR      r2,[r1,#0]
0001b0  f0420208          ORR      r2,r2,#8
0001b4  600a              STR      r2,[r1,#0]
;;;315    	lcd_write(data);
0001b6  f7fffffe          BL       lcd_write
;;;316    	/* Note:
;;;317    	 * After execution of the CGRAM/DDRAM data write/read instruction, the RAM address counter is incremented
;;;318    	 * or decremented by 1. The RAM address counter is updated after the busy flag turns off.
;;;319    	 * tADD is the time elapsed after the busy flag turns off until the address counter is updated. */
;;;320    	lcd_10us_delay(AC_UPDATE_TIME);	/* Update RAM address counter delay. */
0001ba  e8bd4010          POP      {r4,lr}
0001be  2001              MOVS     r0,#1
0001c0  f7ffbffe          B.W      lcd_10us_delay
;;;321    }
;;;322    
                          ENDP

                  lcd_puts PROC
;;;323    /*!	\details	Writes ANSI-C string to LCD (DDRAM memory space). */
;;;324    void lcd_puts(const uint8_t *str)
0001c4  b570              PUSH     {r4-r6,lr}
;;;325    {
0001c6  4604              MOV      r4,r0
;;;326    	/* Send a ANSI-C string to LCD. */
;;;327    	while ('\0' != *str)
;;;328    	{
;;;329    #if ( USE_FORMATTED_OUTPUT )
;;;330    		if(('\n' == *str))
;;;331    		{/*New line */
;;;332    			lcd_goto(LCD_2nd_LINE, 0u);
;;;333    		}
;;;334    		else if(('\r' == *str))
;;;335    		{/* Return home */
;;;336    			lcd_return();
;;;337    		}
;;;338    		else if(('\t' == *str))
;;;339    		{/* Tab space */
;;;340    			uint8_t i;
;;;341    
;;;342    			for(i=0u; i<TAB_SPACE; i++)
;;;343    			{/* Shift cursor to the right. */
;;;344    				cursor_shift(RIGHT);
;;;345    			}
;;;346    		}
;;;347    		else
;;;348    #endif
;;;349    		{
;;;350    			/* Display a symbol. */
;;;351    			lcd_putc(*str);
;;;352    		}
;;;353    		/* Get the next symbol. */
;;;354    		str++;
0001c8  e008              B        |L1.476|
                  |L1.458|
0001ca  280a              CMP      r0,#0xa               ;330
0001cc  d00a              BEQ      |L1.484|
0001ce  280d              CMP      r0,#0xd               ;334
0001d0  d00d              BEQ      |L1.494|
0001d2  2809              CMP      r0,#9                 ;338
0001d4  d00e              BEQ      |L1.500|
0001d6  f7fffffe          BL       lcd_putc
                  |L1.474|
0001da  1c64              ADDS     r4,r4,#1              ;351
                  |L1.476|
0001dc  7820              LDRB     r0,[r4,#0]            ;327
0001de  2800              CMP      r0,#0                 ;327
0001e0  d1f3              BNE      |L1.458|
;;;355    	}
;;;356    }
0001e2  bd70              POP      {r4-r6,pc}
                  |L1.484|
0001e4  2100              MOVS     r1,#0                 ;332
0001e6  2002              MOVS     r0,#2                 ;332
0001e8  f7fffffe          BL       lcd_goto
0001ec  e7f5              B        |L1.474|
                  |L1.494|
0001ee  f7fffffe          BL       lcd_return
0001f2  e7f2              B        |L1.474|
                  |L1.500|
0001f4  2500              MOVS     r5,#0                 ;342
                  |L1.502|
0001f6  203e              MOVS     r0,#0x3e              ;344
0001f8  f7fffffe          BL       cursor_shift
0001fc  1c6d              ADDS     r5,r5,#1              ;344
0001fe  b2ed              UXTB     r5,r5                 ;342
000200  2d04              CMP      r5,#4                 ;342
000202  d3f8              BCC      |L1.502|
000204  e7e9              B        |L1.474|
;;;357    
                          ENDP

                  lcd_loadchar PROC
;;;358    /*!	\details	Load the user-defined symbol into the CGRAM memory. */
;;;359    void lcd_loadchar(uint8_t* vector, uint8_t position)
000206  b570              PUSH     {r4-r6,lr}
;;;360    {
000208  4605              MOV      r5,r0
00020a  06c8              LSLS     r0,r1,#27
;;;361    	uint8_t i;
;;;362    	/* Go to the CGRAM memory space: 0 to 7 */
;;;363    	lcd_goto(CGRAM, (position * FONT_HEIGHT));
00020c  0e01              LSRS     r1,r0,#24
00020e  2005              MOVS     r0,#5
000210  f7fffffe          BL       lcd_goto
;;;364    
;;;365    	for(i = 0u; i < FONT_HEIGHT; i++)
000214  2400              MOVS     r4,#0
                  |L1.534|
;;;366    	{/* Load one row of pixels into the CGRAM register. */
;;;367    		lcd_putc(vector[i]);
000216  5d28              LDRB     r0,[r5,r4]
000218  f7fffffe          BL       lcd_putc
00021c  1c64              ADDS     r4,r4,#1
00021e  b2e4              UXTB     r4,r4                 ;365
000220  2c08              CMP      r4,#8                 ;365
000222  d3f8              BCC      |L1.534|
;;;368    	}
;;;369    
;;;370    	/* Return to the DDRAM memory space. */
;;;371    	lcd_goto(LCD_1st_LINE, 0u);
000224  e8bd4070          POP      {r4-r6,lr}
000228  2100              MOVS     r1,#0
00022a  2001              MOVS     r0,#1
00022c  e7fe              B        lcd_goto
;;;372    }
;;;373    
                          ENDP

                  lcd_drawchar PROC
;;;374    /*!	\details	Load and display the user-defined symbol. */
;;;375    void lcd_drawchar( uint8_t* vector,
00022e  b570              PUSH     {r4-r6,lr}
;;;376    			   	   uint8_t position,
;;;377    			   	   uint8_t line,
;;;378    			   	   uint8_t address )
;;;379    {
000230  461c              MOV      r4,r3
000232  4615              MOV      r5,r2
000234  460e              MOV      r6,r1
;;;380    	/* Load the user-defined symbol into the CGRAM memory. */
;;;381    	lcd_loadchar(vector, position);
000236  f7fffffe          BL       lcd_loadchar
;;;382    	/* Select LCD position. */
;;;383    	lcd_goto(line, address);
00023a  4621              MOV      r1,r4
00023c  4628              MOV      r0,r5
00023e  f7fffffe          BL       lcd_goto
;;;384    	/* Display the user-defined symbol. */
;;;385    	lcd_putc(position);
000242  4630              MOV      r0,r6
000244  e8bd4070          POP      {r4-r6,lr}
000248  e7fe              B        lcd_putc
;;;386    }
;;;387    
                          ENDP

                  lcd_backspace PROC
;;;388    /*!	\details	Erase a symbol from the left of the cursor. */
;;;389    void lcd_backspace(void)
00024a  b510              PUSH     {r4,lr}
;;;390    {
;;;391    	cursor_shift(LEFT);		// Сдвигаем курсор на одну позицию влево
00024c  203c              MOVS     r0,#0x3c
00024e  f7fffffe          BL       cursor_shift
;;;392    	lcd_putc(' ');			// Очищаем, после чего происходит автоинкремент вправо
000252  2020              MOVS     r0,#0x20
000254  f7fffffe          BL       lcd_putc
;;;393    	cursor_shift(LEFT);		// Сдвигаем курсор на одну позицию влево
000258  e8bd4010          POP      {r4,lr}
00025c  203c              MOVS     r0,#0x3c
00025e  e7fe              B        cursor_shift
;;;394    }
;;;395    
                          ENDP

                  lcd_itos PROC
;;;410    /*!	\brief	Display a integer number: +/- 2147483647. */
;;;411    void lcd_itos(int32_t value)
000260  b570              PUSH     {r4-r6,lr}
;;;412    {
000262  0004              MOVS     r4,r0
000264  d503              BPL      |L1.622|
;;;413    	int32_t i;
;;;414    
;;;415    	if (value < 0)
;;;416    	{
;;;417    		lcd_putc('-');
000266  202d              MOVS     r0,#0x2d
000268  f7fffffe          BL       lcd_putc
;;;418    		value = -value;
00026c  4264              RSBS     r4,r4,#0
                  |L1.622|
;;;419    	}
;;;420    
;;;421    	i = 1;
00026e  2501              MOVS     r5,#1
;;;422    	while ((value / i) > 9)
000270  e003              B        |L1.634|
;;;423    	{
;;;424    		i *= 10;
000272  bf00              NOP      
                  |L1.628|
000274  eb050085          ADD      r0,r5,r5,LSL #2
000278  0045              LSLS     r5,r0,#1
                  |L1.634|
00027a  fb94f0f5          SDIV     r0,r4,r5              ;422
00027e  2809              CMP      r0,#9                 ;422
000280  dcf8              BGT      |L1.628|
;;;425    	}
;;;426    
;;;427    	lcd_putc(value/i + '0');	/* Display at least one symbol */
000282  fb94f0f5          SDIV     r0,r4,r5
000286  3030              ADDS     r0,r0,#0x30
000288  b2c0              UXTB     r0,r0
00028a  f7fffffe          BL       lcd_putc
;;;428    	i /= 10;
00028e  260a              MOVS     r6,#0xa
;;;429    
;;;430    	while (i > 0)
000290  e00d              B        |L1.686|
;;;431    	{
;;;432    		lcd_putc('0' + ((value % (i*10)) / i));
000292  bf00              NOP      
                  |L1.660|
000294  eb050085          ADD      r0,r5,r5,LSL #2
000298  0040              LSLS     r0,r0,#1
00029a  fb94f1f0          SDIV     r1,r4,r0
00029e  fb004011          MLS      r0,r0,r1,r4
0002a2  fb90f0f5          SDIV     r0,r0,r5
0002a6  3030              ADDS     r0,r0,#0x30
0002a8  b2c0              UXTB     r0,r0
0002aa  f7fffffe          BL       lcd_putc
                  |L1.686|
0002ae  fb95f5f6          SDIV     r5,r5,r6              ;428
0002b2  2d00              CMP      r5,#0                 ;430
0002b4  dcee              BGT      |L1.660|
;;;433    		i /= 10;
;;;434    	}
;;;435    }
0002b6  bd70              POP      {r4-r6,pc}
;;;436    
                          ENDP

                  lcd_ntos PROC
;;;456    /*!	\brief	Display "n" right digits of "value". */
;;;457    void lcd_ntos(uint32_t value, uint8_t n)
0002b8  b570              PUSH     {r4-r6,lr}
;;;458    {
0002ba  4606              MOV      r6,r0
0002bc  2900              CMP      r1,#0
0002be  d014              BEQ      |L1.746|
0002c0  1e49              SUBS     r1,r1,#1
;;;459    	if (n > 0u)
;;;460    	{
;;;461    		uint32_t i = lcd_pow10(n - 1u);
0002c2  b2c8              UXTB     r0,r1
0002c4  f7fffffe          BL       lcd_pow10
0002c8  4604              MOV      r4,r0
;;;462    
;;;463    		while (i > 0u)	/* Display at least one symbol */
;;;464    		{
;;;465    			lcd_putc('0' + ((value/i) % 10u));
0002ca  250a              MOVS     r5,#0xa
0002cc  e00b              B        |L1.742|
0002ce  bf00              NOP      
                  |L1.720|
0002d0  fbb6f0f4          UDIV     r0,r6,r4
0002d4  fbb0f1f5          UDIV     r1,r0,r5
0002d8  fb050011          MLS      r0,r5,r1,r0
0002dc  3030              ADDS     r0,r0,#0x30
0002de  f7fffffe          BL       lcd_putc
;;;466    
;;;467    			i /= 10u;
0002e2  fbb4f4f5          UDIV     r4,r4,r5
                  |L1.742|
0002e6  2c00              CMP      r4,#0                 ;463
0002e8  d1f2              BNE      |L1.720|
                  |L1.746|
;;;468    		}
;;;469    	}
;;;470    }
0002ea  bd70              POP      {r4-r6,pc}
;;;471    
                          ENDP

                  lcd_ftos PROC
;;;437    /*!	\brief	Display a floating point number. */
;;;438    void lcd_ftos(float value, uint8_t n)
0002ec  b570              PUSH     {r4-r6,lr}
;;;439    {
0002ee  460d              MOV      r5,r1
0002f0  4604              MOV      r4,r0
;;;440    	if (value < 0.0)
0002f2  f1104fff          CMN      r0,#0x7f800000
0002f6  d304              BCC      |L1.770|
;;;441    	{
;;;442    		lcd_putc('-');
0002f8  202d              MOVS     r0,#0x2d
0002fa  f7fffffe          BL       lcd_putc
;;;443    		value = -value;
0002fe  f0844400          EOR      r4,r4,#0x80000000
                  |L1.770|
;;;444    	}
;;;445    
;;;446    	lcd_itos((int32_t)value); // Вывод целой части
000302  4620              MOV      r0,r4
000304  f7fffffe          BL       __aeabi_f2iz
000308  f7fffffe          BL       lcd_itos
;;;447    
;;;448    	if (n > 0u)
00030c  2d00              CMP      r5,#0
00030e  d010              BEQ      |L1.818|
;;;449    	{
;;;450    		lcd_putc('.'); // Точка
000310  202e              MOVS     r0,#0x2e
000312  f7fffffe          BL       lcd_putc
;;;451    
;;;452    		lcd_ntos((uint32_t)(value * (float)lcd_pow10(n)), n); // Вывод дробной части
000316  4628              MOV      r0,r5
000318  f7fffffe          BL       lcd_pow10
00031c  f7fffffe          BL       __aeabi_ui2f
000320  4621              MOV      r1,r4
000322  f7fffffe          BL       __aeabi_fmul
000326  f7fffffe          BL       __aeabi_f2uiz
00032a  4629              MOV      r1,r5
00032c  e8bd4070          POP      {r4-r6,lr}
000330  e7fe              B        lcd_ntos
                  |L1.818|
;;;453    	}
;;;454    }
000332  bd70              POP      {r4-r6,pc}
;;;455    
                          ENDP

                  lcd_clrbar PROC
;;;570    /*!	\brief	Clear the entire progress bar. */
;;;571    void lcd_clrbar(void)
000334  b510              PUSH     {r4,lr}
;;;572    {
;;;573    	uint8_t i;
;;;574    	/* Go to the last cell in the progress bar. */
;;;575    	lcd_goto(PROGRESS_BAR_LINE, (PROGRESS_BAR_WIDTH - 1u));
000336  2109              MOVS     r1,#9
000338  2002              MOVS     r0,#2
00033a  f7fffffe          BL       lcd_goto
;;;576    	/* Set the decrement mode. */
;;;577    	lcd_setmode(ENTRY_MODE_DEC_NO_SHIFT);
00033e  2004              MOVS     r0,#4
000340  f7fffffe          BL       lcd_setmode
;;;578    
;;;579    	for(i = 0u; i < PROGRESS_BAR_WIDTH; i++)
000344  2400              MOVS     r4,#0
                  |L1.838|
;;;580    	{/* Display the "empty cell" symbol (i.e. clear the LCD cell). */
;;;581    		lcd_putc(EMPTY_LOAD);
000346  2000              MOVS     r0,#0
000348  f7fffffe          BL       lcd_putc
00034c  1c64              ADDS     r4,r4,#1
00034e  b2e4              UXTB     r4,r4                 ;579
000350  2c0a              CMP      r4,#0xa               ;579
000352  d3f8              BCC      |L1.838|
;;;582    	}
;;;583    
;;;584    	/* Reset the progress bar variables. */
;;;585    	current_bar_pixel = 0u;
000354  492c              LDR      r1,|L1.1032|
000356  2000              MOVS     r0,#0
000358  7008              STRB     r0,[r1,#0]
;;;586    	current_cell_load = EMPTY_LOAD;
00035a  7048              STRB     r0,[r1,#1]
;;;587    
;;;588    	/* Restore the default entry mode. */
;;;589    	lcd_setmode(DEFAULT_ENTRY_MODE);
00035c  2006              MOVS     r0,#6
00035e  f7fffffe          BL       lcd_setmode
;;;590    	/* Return home. */
;;;591    	lcd_goto(LCD_1st_LINE, 0u);
000362  2100              MOVS     r1,#0
000364  e8bd4010          POP      {r4,lr}
000368  2001              MOVS     r0,#1
00036a  e7fe              B        lcd_goto
;;;592    }
;;;593    #endif
                          ENDP

                  lcd_drawbar PROC
;;;500    /*!	\brief	Draw progress bar. */
;;;501    void lcd_drawbar(uint8_t next_bar_pixel)
00036c  b570              PUSH     {r4-r6,lr}
;;;502    {
;;;503    	/* Go to the current cell position in the progress bar. */
;;;504    	lcd_goto(PROGRESS_BAR_LINE, (current_bar_pixel / FONT_WIDTH));
00036e  4c26              LDR      r4,|L1.1032|
000370  4605              MOV      r5,r0                 ;502
000372  2605              MOVS     r6,#5
000374  7820              LDRB     r0,[r4,#0]  ; current_bar_pixel
000376  fbb0f1f6          UDIV     r1,r0,r6
00037a  2002              MOVS     r0,#2
00037c  f7fffffe          BL       lcd_goto
;;;505    
;;;506    	if (next_bar_pixel > current_bar_pixel)
000380  7820              LDRB     r0,[r4,#0]  ; current_bar_pixel
000382  4285              CMP      r5,r0
000384  d91b              BLS      |L1.958|
;;;507    	{
;;;508    		/* Increment LCD cursor */
;;;509    		lcd_setmode(ENTRY_MODE_INC_NO_SHIFT);
000386  f04f0006          MOV      r0,#6
00038a  f7fffffe          BL       lcd_setmode
;;;510    
;;;511    		/* Prevent the progress bar overflow */
;;;512    		if (next_bar_pixel > PROGRESS_BAR_MAX_LOAD)
00038e  2d32              CMP      r5,#0x32
000390  d900              BLS      |L1.916|
;;;513    		{
;;;514    			next_bar_pixel = PROGRESS_BAR_MAX_LOAD;
000392  2532              MOVS     r5,#0x32
                  |L1.916|
000394  2600              MOVS     r6,#0
                  |L1.918|
;;;515    		}
;;;516    
;;;517    		while (current_bar_pixel != next_bar_pixel)
000396  7820              LDRB     r0,[r4,#0]  ; current_bar_pixel
000398  42a8              CMP      r0,r5
00039a  d029              BEQ      |L1.1008|
00039c  1c40              ADDS     r0,r0,#1
;;;518    		{
;;;519    			/* Go to the next pixel. */
;;;520    			current_bar_pixel++;
00039e  7020              STRB     r0,[r4,#0]
;;;521    			current_cell_load++;
0003a0  7860              LDRB     r0,[r4,#1]  ; current_cell_load
0003a2  1c40              ADDS     r0,r0,#1
0003a4  b2c0              UXTB     r0,r0
0003a6  7060              STRB     r0,[r4,#1]
;;;522    			/* Display the load of the current cell. */
;;;523    			lcd_putc(current_cell_load);
0003a8  f7fffffe          BL       lcd_putc
;;;524    
;;;525    			if (current_cell_load < FULL_LOAD)
0003ac  7860              LDRB     r0,[r4,#1]  ; current_cell_load
0003ae  2805              CMP      r0,#5
0003b0  d203              BCS      |L1.954|
;;;526    			{/* Return the cursor to the current cell. */
;;;527    				cursor_shift(LEFT);
0003b2  203c              MOVS     r0,#0x3c
0003b4  f7fffffe          BL       cursor_shift
0003b8  e7ed              B        |L1.918|
                  |L1.954|
;;;528    			}
;;;529    			else
;;;530    			{/* Go to the next cell. */
;;;531    				current_cell_load = EMPTY_LOAD;
0003ba  7066              STRB     r6,[r4,#1]
0003bc  e7eb              B        |L1.918|
                  |L1.958|
;;;532    			}
;;;533    		}
;;;534    	 }
;;;535    #if (USE_REGRESS_BAR)
;;;536    	 else if (next_bar_pixel < current_bar_pixel)
0003be  d217              BCS      |L1.1008|
;;;537    	 {
;;;538    		 /* Decrement LCD cursor */
;;;539    		lcd_setmode(ENTRY_MODE_DEC_NO_SHIFT);
0003c0  2004              MOVS     r0,#4
0003c2  f7fffffe          BL       lcd_setmode
                  |L1.966|
;;;540    
;;;541    		do
;;;542    		{
;;;543    			if (EMPTY_LOAD == current_cell_load)
0003c6  7860              LDRB     r0,[r4,#1]  ; current_cell_load
0003c8  b918              CBNZ     r0,|L1.978|
;;;544    			{/* Go to the next cell. */
;;;545    				cursor_shift(LEFT);
0003ca  203c              MOVS     r0,#0x3c
0003cc  f7fffffe          BL       cursor_shift
;;;546    				current_cell_load = FULL_LOAD;
0003d0  7066              STRB     r6,[r4,#1]
                  |L1.978|
;;;547    			}
;;;548    			/* Go to the next pixel. */
;;;549    			current_bar_pixel--;
0003d2  7820              LDRB     r0,[r4,#0]  ; current_bar_pixel
0003d4  1e40              SUBS     r0,r0,#1
0003d6  7020              STRB     r0,[r4,#0]
;;;550    			current_cell_load--;
0003d8  7860              LDRB     r0,[r4,#1]  ; current_cell_load
0003da  1e40              SUBS     r0,r0,#1
0003dc  b2c0              UXTB     r0,r0
0003de  7060              STRB     r0,[r4,#1]
;;;551    			/* Display the load of the current cell. */
;;;552    			lcd_putc(current_cell_load);
0003e0  f7fffffe          BL       lcd_putc
;;;553    			/* Return the cursor to the current cell. */
;;;554    			cursor_shift(RIGHT);
0003e4  203e              MOVS     r0,#0x3e
0003e6  f7fffffe          BL       cursor_shift
;;;555    		}
;;;556    		while (current_bar_pixel != next_bar_pixel);
0003ea  7820              LDRB     r0,[r4,#0]  ; current_bar_pixel
0003ec  42a8              CMP      r0,r5
0003ee  d1ea              BNE      |L1.966|
                  |L1.1008|
;;;557    	 }
;;;558    #endif /* USE_REGRESS_BAR */
;;;559    	 else
;;;560    	 {
;;;561    		 /* Nothing to do. */
;;;562    	 }
;;;563    
;;;564    	/* Restore the default entry mode. */
;;;565    	lcd_setmode(DEFAULT_ENTRY_MODE);
0003f0  2006              MOVS     r0,#6
0003f2  f7fffffe          BL       lcd_setmode
;;;566    	/* Return home. */
;;;567    	lcd_goto(LCD_1st_LINE, 0u);
0003f6  e8bd4070          POP      {r4-r6,lr}
0003fa  2100              MOVS     r1,#0
0003fc  2001              MOVS     r0,#1
0003fe  e7fe              B        lcd_goto
                  |L1.1024|
                          DCD      0x40010800
                  |L1.1028|
                          DCD      0x4001080c
                  |L1.1032|
                          DCD      ||.data||
                          ENDP

                  lcd_init PROC
;;;596     * 	\note	This library use the 4-bit interface. */
;;;597    void lcd_init(void)
00040c  b570              PUSH     {r4-r6,lr}
;;;598    {
;;;599    	/* GPIO initialization. */
;;;600    	Set_All_pins_as_Outputs();
00040e  f7fffffe          BL       gpio_init
000412  493e              LDR      r1,|L1.1292|
;;;601    	/* LCD initialization. */
;;;602    	lcd_config(DEFAULT_DISPLAY_CONFIG);
000414  2428              MOVS     r4,#0x28
000416  6808              LDR      r0,[r1,#0]
000418  f0200008          BIC      r0,r0,#8
00041c  6008              STR      r0,[r1,#0]
00041e  6808              LDR      r0,[r1,#0]
000420  f0200004          BIC      r0,r0,#4
000424  6008              STR      r0,[r1,#0]
000426  4620              MOV      r0,r4
000428  f7fffffe          BL       lcd_high
00042c  f7fffffe          BL       lcd_strobe
000430  2005              MOVS     r0,#5
000432  f7fffffe          BL       lcd_10us_delay
000436  f7fffffe          BL       lcd_strobe
00043a  2005              MOVS     r0,#5
00043c  f7fffffe          BL       lcd_10us_delay
000440  4620              MOV      r0,r4
000442  f7fffffe          BL       lcd_low
000446  f7fffffe          BL       lcd_strobe
00044a  2005              MOVS     r0,#5
00044c  f7fffffe          BL       lcd_10us_delay
;;;603    	lcd_setmode(DEFAULT_VIEW_MODE);
000450  200c              MOVS     r0,#0xc
000452  f7fffffe          BL       lcd_setmode
;;;604    	lcd_setmode(DEFAULT_ENTRY_MODE);
000456  2006              MOVS     r0,#6
000458  f7fffffe          BL       lcd_setmode
;;;605    	lcd_clrscr();
00045c  f7fffffe          BL       lcd_clrscr
;;;606    	lcd_return();
000460  f7fffffe          BL       lcd_return
000464  4e2a              LDR      r6,|L1.1296|
000466  2400              MOVS     r4,#0
                  |L1.1128|
000468  06e0              LSLS     r0,r4,#27
00046a  0e01              LSRS     r1,r0,#24
00046c  2005              MOVS     r0,#5
00046e  f7fffffe          BL       lcd_goto
000472  2500              MOVS     r5,#0
000474  e001              B        |L1.1146|
                  |L1.1142|
000476  2d03              CMP      r5,#3
000478  d201              BCS      |L1.1150|
                  |L1.1146|
00047a  5d30              LDRB     r0,[r6,r4]
00047c  e000              B        |L1.1152|
                  |L1.1150|
00047e  2000              MOVS     r0,#0
                  |L1.1152|
000480  f7fffffe          BL       lcd_putc
000484  1c6d              ADDS     r5,r5,#1
000486  b2ed              UXTB     r5,r5
000488  2d08              CMP      r5,#8
00048a  d3f4              BCC      |L1.1142|
00048c  1c64              ADDS     r4,r4,#1
00048e  b2e4              UXTB     r4,r4
000490  2c06              CMP      r4,#6
000492  d3e9              BCC      |L1.1128|
000494  e8bd4070          POP      {r4-r6,lr}
000498  e7fe              B        lcd_clrbar
;;;607    #if (USE_PROGRESS_BAR)
;;;608    	lcd_initbar();
;;;609    #endif
;;;610    }
;;;611    
                          ENDP

                  lcd_10us_delay PROC
;;;103    /*!	\brief	Creates delay multiples of 10us. */
;;;104    static void lcd_10us_delay(volatile uint32_t us)
00049a  b501              PUSH     {r0,lr}
;;;105    {
;;;106    	/* Сonversion to us */
;;;107    	us *= MCU_FREQ_VALUE;
00049c  9800              LDR      r0,[sp,#0]
00049e  eb000040          ADD      r0,r0,r0,LSL #1
0004a2  00c0              LSLS     r0,r0,#3
                  |L1.1188|
0004a4  9000              STR      r0,[sp,#0]
0004a6  2800              CMP      r0,#0
0004a8  d001              BEQ      |L1.1198|
0004aa  1e40              SUBS     r0,r0,#1
;;;108    	/* Wait */
;;;109    	while (us > 0u)
;;;110    	{
;;;111    		us--;
0004ac  e7fa              B        |L1.1188|
                  |L1.1198|
;;;112    	}
;;;113    }
0004ae  bd08              POP      {r3,pc}
;;;114    
                          ENDP

                  lcd_strobe PROC
;;;115    /*!	\brief	Initiate the transfer of data/commands to LCD. */
;;;116    static void lcd_strobe(void)
0004b0  b510              PUSH     {r4,lr}
;;;117    {/* Low level function. */
;;;118    	SET(LCD_E_OUT, LCD_E);
0004b2  4c16              LDR      r4,|L1.1292|
0004b4  6820              LDR      r0,[r4,#0]
0004b6  f0400002          ORR      r0,r0,#2
0004ba  6020              STR      r0,[r4,#0]
;;;119    	lcd_10us_delay(ENABLE_CYCLE_TIME);
0004bc  2001              MOVS     r0,#1
0004be  f7fffffe          BL       lcd_10us_delay
;;;120    	CLR(LCD_E_OUT, LCD_E);	/* Enable strobe */
0004c2  6820              LDR      r0,[r4,#0]
0004c4  f0200002          BIC      r0,r0,#2
0004c8  6020              STR      r0,[r4,#0]
;;;121    }
0004ca  bd10              POP      {r4,pc}
;;;122    
                          ENDP

                  lcd_write PROC
;;;141    /*!	\brief	Send data/commands to the display. */
;;;142    static void lcd_write(uint8_t data)
0004cc  b510              PUSH     {r4,lr}
;;;143    {/* Low level function. */
;;;144    #if (USE_BUSY_FLAG)
;;;145    	/* Write data/commands to LCD. */
;;;146    	CLR(LCD_RW_OUT, LCD_RW);
0004ce  490f              LDR      r1,|L1.1292|
0004d0  4604              MOV      r4,r0                 ;143
0004d2  6808              LDR      r0,[r1,#0]
0004d4  f0200004          BIC      r0,r0,#4
0004d8  6008              STR      r0,[r1,#0]
;;;147    #endif /* USE_BUSY_FLAG */
;;;148    
;;;149    	lcd_high(data);
0004da  4620              MOV      r0,r4
0004dc  f7fffffe          BL       lcd_high
;;;150    	lcd_strobe();
0004e0  f7fffffe          BL       lcd_strobe
;;;151    	lcd_low(data);
0004e4  4620              MOV      r0,r4
0004e6  f7fffffe          BL       lcd_low
;;;152    	lcd_strobe();
0004ea  f7fffffe          BL       lcd_strobe
;;;153    
;;;154    	/* The busy flag must be checked after the 4-bit data has been transferred twice. */
;;;155    #if (USE_BUSY_FLAG)
;;;156    	lcd_busy_delay();
0004ee  e8bd4010          POP      {r4,lr}
0004f2  e7fe              B        lcd_busy_delay
;;;157    #else
;;;158    	lcd_10us_delay(BUSY_CYCLE_TIME);
;;;159    #endif /* USE_BUSY_FLAG */
;;;160    }
;;;161    
                          ENDP

                  lcd_pow10 PROC
;;;396    /*!	\brief	Returns 10^n value. */
;;;397    static uint32_t lcd_pow10(uint8_t n)
0004f4  4601              MOV      r1,r0
;;;398    {
;;;399    	uint32_t retval = 1u;
0004f6  2001              MOVS     r0,#1
0004f8  e005              B        |L1.1286|
;;;400    
;;;401    	while (n > 0u)
;;;402    	{
;;;403    		retval *= 10u;
0004fa  bf00              NOP      
                  |L1.1276|
0004fc  eb000080          ADD      r0,r0,r0,LSL #2
000500  0040              LSLS     r0,r0,#1
000502  1e49              SUBS     r1,r1,#1
;;;404    		n--;
000504  b2c9              UXTB     r1,r1
                  |L1.1286|
000506  2900              CMP      r1,#0                 ;401
000508  d1f8              BNE      |L1.1276|
;;;405    	}
;;;406    
;;;407    	return retval;
;;;408    }
00050a  4770              BX       lr
;;;409    
                          ENDP

                  |L1.1292|
                          DCD      0x4001080c
                  |L1.1296|
                          DCD      ||.constdata||

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  progress_bar
000000  0010181c          DCB      0x00,0x10,0x18,0x1c
000004  1e1f              DCB      0x1e,0x1f

                          AREA ||.data||, DATA, ALIGN=0

                  current_bar_pixel
000000  00                DCB      0x00
                  current_cell_load
000001  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\lcd\\hd44780.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___9_hd44780_c_797b7724____REV16|
#line 129 "C:\\Program Files\\keil\\ARM\\PACK\\ARM\\CMSIS\\3.20.4\\CMSIS\\Include\\core_cmInstr.h"
|__asm___9_hd44780_c_797b7724____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___9_hd44780_c_797b7724____REVSH|
#line 144
|__asm___9_hd44780_c_797b7724____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
